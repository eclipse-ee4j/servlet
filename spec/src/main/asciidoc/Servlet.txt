= Preface

[#50626603_pgfId-999643]##Specification: JSR-369 Java Servlet 4.0
("Specification")

[#50626603_pgfId-999644]##Version: 4.0

[#50626603_pgfId-999476]##Status: Final Approval Ballot

[#50626603_pgfId-999678]##Release: July 2017

[#50626603_pgfId-999679]## 

[#50626603_pgfId-999480]##Copyright 2015 Oracle America, Inc.

[#50626603_pgfId-999795]##500 Oracle Parkway, Redwood City, California
94065, U.S.A.

[#50626603_pgfId-999797]## 

[#50626603_pgfId-999481]##All rights reserved.

=== [#50626604_pgfId-4900]##

image:servlet-1.gif[image]

Preface

image:servlet-2.gif[image]

[#50626604_pgfId-5109]##This document is the Java™ Servlet
Specification, version 4.0. The standard for the Java Servlet API is
described herein.

==== [#50626604_pgfId-5110]##

image:servlet-3.gif[image]

Additional Sources

[#50626604_pgfId-5111]##The specification is intended to be a complete
and clear explanation of Java Servlets, but if questions remain, the
following sources may be consulted:

[#50626604_pgfId-8153]##A reference implementation (RI) has been made
available which provides a behavioral benchmark for this specification.
Where the specification leaves implementation of a particular feature
open to interpretation, implementors may use the reference
implementation as a model of how to carry out the intention of the
specification.

[#50626604_pgfId-5113]##A compatibility test suite (CTS) has been
provided for assessing whether implementations meet the compatibility
requirements of the Java Servlet API standard. The test results have
normative value for resolving questions about whether an implementation
is standard.

[#50626604_pgfId-5114]##If further clarification is required, the
working group for the Java Servlet API under the Java Community Process
should be consulted, and is the final arbiter of such issues.

[#50626604_pgfId-5115]##Comments and feedback are welcome, and will be
used to improve future versions.

==== [#50626604_pgfId-5116]##

image:servlet-3.gif[image]

Who Should Read This Specification

[#50626604_pgfId-5117]##The intended audience for this specification
includes the following groups:

[#50626604_pgfId-5118]##Web server and application server vendors that
want to provide servlet engines that conform to this standard.

[#50626604_pgfId-5119]##Authoring tool developers that want to support
Web applications that conform to this specification

[#50626604_pgfId-5120]##Experienced servlet authors who want to
understand the underlying mechanisms of servlet technology.

[#50626604_pgfId-5121]##We emphasize that this specification is not a
user’s guide for servlet developers and is not intended to be used as
such.

==== [#50626604_pgfId-5122]##

image:servlet-3.gif[image]

API Reference

[#50626604_pgfId-5126]##The full specifications of classes, interfaces,
and method signatures that define the Java Servlet API, as well as their
accompanying Javadoc™ documentation, is available online at
_http://docs.oracle.com/javaee/_ .

==== [#50626604_pgfId-5127]##

image:servlet-3.gif[image]

Other Java Platform Specifications

[#50626604_pgfId-5128]##The following Java API specifications are
referenced throughout this specification:

[#50626604_pgfId-5129]##Java Platform, Enterprise Edition ("Java EE"),
version 8

[#50626604_pgfId-5130]##JavaServer Pages™ ("JSP™"), version 2.3

[#50626604_pgfId-5131]##Java Naming and Directory Interface™
("J.N.D.I.").

[#50626604_pgfId-5850]##Context and Dependency Injection for the Java EE
Platform

[#50626604_pgfId-5853]##Managed Beans specification

[#50626604_pgfId-5132]##These specifications may be found at the Java
Platform, Enterprise Edition Web site: _http://docs.oracle.com/javaee/_
.

==== [#50626604_pgfId-5133]##

image:servlet-3.gif[image]

[#50626604_33785]##Other Important References

[#50626604_pgfId-5134]##The following Internet specifications provide
information relevant to the development and implementation of the Java
Servlet API and standard servlet engines:

[#50626604_pgfId-5135]##RFC 1630 Uniform Resource Identifiers (URI)

[#50626604_pgfId-5136]##RFC 1738 Uniform Resource Locators (URL)

[#50626604_pgfId-5137]##RFC 3986 Uniform Resource Identifiers (URI):
Generic Syntax

[#50626604_pgfId-5139]##RFC 1945 Hypertext Transfer Protocol (HTTP/1.0)

[#50626604_pgfId-5140]##RFC 2045 MIME Part One: Format of Internet
Message Bodies

[#50626604_pgfId-5141]##RFC 2046 MIME Part Two: Media Types

[#50626604_pgfId-5142]##RFC 2047 MIME Part Three: Message Header
Extensions for non-ASCII text

[#50626604_pgfId-5143]##RFC 2048 MIME Part Four: Registration Procedures

[#50626604_pgfId-5144]##RFC 2049 MIME Part Five: Conformance Criteria
and Examples

[#50626604_pgfId-5145]##RFC 6265 HTTP State Management Mechanism

[#50626604_pgfId-7828]##RFC 7258 Pervasive Monitoring Is an Attack

[#50626604_pgfId-7559]##RFC 7540 Hypertext Transfer Protocol Version 2
(HTTP/2)

[#50626604_pgfId-7620]##RFC 7541 HPACK: Header Compression for HTTP/2
(HPACK)

[#50626604_pgfId-5146]##RFC 7230 Hypertext Transfer Protocol (HTTP/1.1):
Message Syntax and Routing

[#50626604_pgfId-6933]##RFC 7231 Hypertext Transfer Protocol (HTTP/1.1):
Semantics and Content

[#50626604_pgfId-7010]##RFC 7232 Hypertext Transfer Protocol (HTTP/1.1):
Conditional Requests

[#50626604_pgfId-7082]##RFC 7233 Hypertext Transfer Protocol (HTTP/1.1):
Range Requests

[#50626604_pgfId-7149]##RFC 7234 Hypertext Transfer Protocol (HTTP/1.1):
Caching

[#50626604_pgfId-7211]##RFC 7235 Hypertext Transfer Protocol (HTTP/1.1):
Authentication

[#50626604_pgfId-7727]##RFC 7301 Transport Layer Security (TLS)
Application-Layer Protocol Negotiation Extension (ALPN)

{empty}[#50626604_pgfId-5150]##RFC 7168 The Hyper Text Coffee Pot
Control Protocol for Tea Ef (HTCPCP-TEA)link:#pgfId-5149[1]

[#50626604_pgfId-6886]##RFC 6585 Additional HTTP Status Codes

[#50626604_pgfId-5152]##RFC 2617 HTTP Authentication: Basic and Digest
Authentication

[#50626604_pgfId-5847]##RFC 3986 Uniform Resource Identifier (URI):
Generic Syntax

[#50626604_pgfId-7527]##RFC 2119 Key words for use in RFCs to Indicate
Requirement Levels

[#50626604_pgfId-5153]##Online versions of these RFCs are at
_http://www.ietf.org/rfc/_ .

[#50626604_pgfId-5154]##The World Wide Web Consortium (
_http://www.w3.org/_ ) is a definitive source of HTTP related
information affecting this specification and its implementations.

[#50626604_pgfId-5155]##The eXtensible Markup Language (XML) is used for
the specification of the Deployment Descriptors described in Chapter 13
of this specification.

[#50626604_pgfId-7494]##The key words "MUST", "MUST NOT", "REQUIRED",
"SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC2119.

==== [#50626604_pgfId-5158]##

image:servlet-3.gif[image]

Providing Feedback

[#50626604_pgfId-5159]##We welcome any and all feedback about this
specification. Please e-mail your comments to
_servlet-spec@javaee.groups.io_ _._

[#50626604_pgfId-5160]##Please note that due to the volume of feedback
that we receive, you will not normally receive a reply from an engineer.
However, each and every comment is read, evaluated, and archived by the
specification team.

[#50626604_pgfId-5821]## 

==== [#50626604_pgfId-7960]##

image:servlet-3.gif[image]

Expert Group members

[#50626604_pgfId-7962]##Euigeun Chung (TmaxSoft, Inc)

[#50626604_pgfId-7948]##Greg Wilkins (Webtide LLC)

[#50626604_pgfId-5775]##Justin Lee (MongoDB, Inc)

[#50626604_pgfId-8005]##Mark Thomas

[#50626604_pgfId-8090]##Martin Mulholland (IBM)

[#50626604_pgfId-7984]##Minehiko IIDA (Fujitsu Limited)

[#50626604_pgfId-8034]##Neil Griffin (Liferay Inc)

[#50626604_pgfId-8064]##Stuart Douglas (RedHat)

[#50626604_pgfId-6281]##Wenbo Zhu ( Google Inc.)

==== [#50626604_pgfId-6282]##

image:servlet-3.gif[image]

Acknowledgements

[#50626604_pgfId-5861]##Bill Shannon from Oracle has provided invaluable
technical input to the specification. Ron Monzillo from Oracle has
helped drive some of the proposals and technical discussions around
security aspects. Rajiv Mordani has capably lead this specification
since version 2.5 and has made an enormous contribution to its success
over time. Arjan Tijms has contributed much to the Java EE JCP expert
groups over the years, in particular to Security and JSF. Arjan
suggested the initial design of the Mapping Discovery API in Servlet
4.0.

[#50626604_pgfId-3932]## 

==== [#50626583_pgfId-108319]##

image:servlet-4.gif[image]

Contents

image:servlet-5.gif[image]

======= [#50626583_pgfId-1126329]##link:servlet.htm#50626583_pgfId-108319[Contents ix]

======= [#50626583_pgfId-1126331]##link:servlet.htm#50626602_pgfId-999462[Overview 1]

{empty}[#50626583_pgfId-1126333]##link:servlet.htm#50626602_pgfId-999786[1.1
What is a Servlet? 1]

{empty}[#50626583_pgfId-1126335]##link:servlet.htm#50626602_pgfId-999789[1.2
What is a Servlet Container? 1]

{empty}[#50626583_pgfId-1126337]##link:servlet.htm#50626602_pgfId-999795[1.3
An Example 2]

{empty}[#50626583_pgfId-1126339]##link:servlet.htm#50626602_pgfId-999802[1.4
Comparing Servlets with Other Technologies 3]

{empty}[#50626583_pgfId-1126341]##link:servlet.htm#50626602_pgfId-999809[1.5
Relationship to Java Platform, Enterprise Edition 3]

{empty}[#50626583_pgfId-1126343]##link:servlet.htm#50626602_pgfId-999814[1.6
Compatibility with Java Servlet Specification Version 2.5 4]

{empty}[#50626583_pgfId-1126345]##link:servlet.htm#50626602_pgfId-1000243[1.6.1
Processing annotations 4]

======= [#50626583_pgfId-1126347]##link:servlet.htm#50626601_pgfId-1009221[The Servlet Interface 5]

{empty}[#50626583_pgfId-1126349]##link:servlet.htm#50626601_pgfId-999468[2.1
Request Handling Methods 5]

{empty}[#50626583_pgfId-1126351]##link:servlet.htm#50626601_pgfId-999472[2.1.1
HTTP Specific Request Handling Methods 5]

{empty}[#50626583_pgfId-1126353]##link:servlet.htm#50626601_pgfId-999482[2.1.2
Additional Methods 6]

{empty}[#50626583_pgfId-1126355]##link:servlet.htm#50626601_pgfId-999484[2.1.3
Conditional GET Support 6]

{empty}[#50626583_pgfId-1126357]##link:servlet.htm#50626601_pgfId-1003413[2.2
Number of Instances 6]

{empty}[#50626583_pgfId-1126359]##link:servlet.htm#50626601_pgfId-999497[2.2.1
Note About The Single Thread Model 7]

{empty}[#50626583_pgfId-1126361]##link:servlet.htm#50626601_pgfId-999500[2.3
Servlet Life Cycle 7]

{empty}[#50626583_pgfId-1126363]##link:servlet.htm#50626601_pgfId-999502[2.3.1
Loading and Instantiation 7]

{empty}[#50626583_pgfId-1126365]##link:servlet.htm#50626601_pgfId-999506[2.3.2
Initialization 8]

{empty}[#50626583_pgfId-1126367]##link:servlet.htm#50626601_pgfId-999511[2.3.2.1
Error Conditions on Initialization 8]

{empty}[#50626583_pgfId-1126369]##link:servlet.htm#50626601_pgfId-999514[2.3.2.2
Tool Considerations 8]

{empty}[#50626583_pgfId-1126371]##link:servlet.htm#50626601_pgfId-999516[2.3.3
Request Handling 9]

{empty}[#50626583_pgfId-1126373]##link:servlet.htm#50626601_pgfId-999520[2.3.3.1
Multithreading Issues 9]

{empty}[#50626583_pgfId-1126375]##link:servlet.htm#50626601_pgfId-999524[2.3.3.2
Exceptions During Request Handling 9]

{empty}[#50626583_pgfId-1126377]##link:servlet.htm#50626601_pgfId-999530[2.3.3.3
Asynchronous processing 10]

{empty}[#50626583_pgfId-1126379]##link:servlet.htm#50626601_pgfId-1004048[2.3.3.4
Thread Safety 20]

{empty}[#50626583_pgfId-1126381]##link:servlet.htm#50626601_pgfId-1006826[2.3.3.5
Upgrade Processing 20]

{empty}[#50626583_pgfId-1126383]##link:servlet.htm#50626601_pgfId-1007759[2.3.4
End of Service 21]

======= [#50626583_pgfId-1126385]##link:servlet.htm#50626597_pgfId-1010231[The Request 23]

{empty}[#50626583_pgfId-1126387]##link:servlet.htm#50626597_pgfId-999464[3.1
HTTP Protocol Parameters 23]

{empty}[#50626583_pgfId-1126389]##link:servlet.htm#50626597_pgfId-999478[3.1.1
When Parameters Are Available 24]

{empty}[#50626583_pgfId-1126391]##link:servlet.htm#50626597_pgfId-999485[3.2
File upload 24]

{empty}[#50626583_pgfId-1126393]##link:servlet.htm#50626597_pgfId-1000957[3.3
Attributes 25]

{empty}[#50626583_pgfId-1126395]##link:servlet.htm#50626597_pgfId-999495[3.4
Headers 25]

{empty}[#50626583_pgfId-1126397]##link:servlet.htm#50626597_pgfId-999505[3.5
Request Path Elements 26]

{empty}[#50626583_pgfId-1126399]##link:servlet.htm#50626597_pgfId-999569[3.6
Path Translation Methods 27]

{empty}[#50626583_pgfId-1126401]##link:servlet.htm#50626597_pgfId-1001696[3.7
Non Blocking IO 28]

{empty}[#50626583_pgfId-1126403]##link:servlet.htm#50626597_pgfId-1006199[3.8
HTTP/2 Server Push 29]

{empty}[#50626583_pgfId-1126405]##link:servlet.htm#50626597_pgfId-1001616[3.9
Cookies 30]

{empty}[#50626583_pgfId-1126407]##link:servlet.htm#50626597_pgfId-999577[3.10
SSL Attributes 30]

{empty}[#50626583_pgfId-1126409]##link:servlet.htm#50626597_pgfId-999606[3.11
Internationalization 31]

{empty}[#50626583_pgfId-1126411]##link:servlet.htm#50626597_pgfId-999613[3.12
Request data encoding 31]

{empty}[#50626583_pgfId-1126413]##link:servlet.htm#50626597_pgfId-999617[3.13
Lifetime of the Request Object 32]

======= [#50626583_pgfId-1126415]##link:servlet.htm#50626599_pgfId-1000838[Servlet Context 33]

{empty}[#50626583_pgfId-1126417]##link:servlet.htm#50626599_pgfId-1000839[4.1
Introduction to the ServletContext Interface 33]

{empty}[#50626583_pgfId-1126419]##link:servlet.htm#50626599_pgfId-999467[4.2
Scope of a ServletContext Interface 33]

{empty}[#50626583_pgfId-1126421]##link:servlet.htm#50626599_pgfId-999470[4.3
Initialization Parameters 34]

{empty}[#50626583_pgfId-1126423]##link:servlet.htm#50626599_pgfId-999475[4.4
Configuration methods 34]

{empty}[#50626583_pgfId-1126425]##link:servlet.htm#50626599_pgfId-1000144[4.4.1
Programmatically adding and configuring Servlets 34]

{empty}[#50626583_pgfId-1126427]##link:servlet.htm#50626599_pgfId-1000403[4.4.1.1
addServlet(String servletName, String className) 35]

{empty}[#50626583_pgfId-1126429]##link:servlet.htm#50626599_pgfId-1000203[4.4.1.2
addServlet(String servletName, Servlet servlet) 35]

{empty}[#50626583_pgfId-1126431]##link:servlet.htm#50626599_pgfId-1000220[4.4.1.3
addServlet(String servletName, Class <? extends Servlet> servletClass)
35]

{empty}[#50626583_pgfId-1126433]##link:servlet.htm#50626599_pgfId-1002421[4.4.1.4
addJspFile(String servletName, String jspfile) 35]

{empty}[#50626583_pgfId-1126435]##link:servlet.htm#50626599_pgfId-1000344[4.4.1.5
<T extends Servlet> T createServlet(Class<T> clazz) 35]

{empty}[#50626583_pgfId-1126437]##link:servlet.htm#50626599_pgfId-1000425[4.4.1.6
ServletRegistration getServletRegistration(String servletName) 35]

{empty}[#50626583_pgfId-1126439]##link:servlet.htm#50626599_pgfId-1000468[4.4.1.7
Map<String, ? extends ServletRegistration> getServletRegistrations() 36]

{empty}[#50626583_pgfId-1126441]##link:servlet.htm#50626599_pgfId-999924[4.4.2
Programmatically adding and configuring Filters 36]

{empty}[#50626583_pgfId-1126443]##link:servlet.htm#50626599_pgfId-1000285[4.4.2.1
addFilter(String filterName, String className) 36]

{empty}[#50626583_pgfId-1126445]##link:servlet.htm#50626599_pgfId-1000287[4.4.2.2
addFilter(String filterName, Filter filter) 36]

{empty}[#50626583_pgfId-1126447]##link:servlet.htm#50626599_pgfId-1000289[4.4.2.3
addFilter(String filterName, Class <? extends Filter> filterClass) 36]

{empty}[#50626583_pgfId-1126449]##link:servlet.htm#50626599_pgfId-1000363[4.4.2.4
<T extends Filter> T createFilter(Class<T> clazz) 36]

{empty}[#50626583_pgfId-1126451]##link:servlet.htm#50626599_pgfId-1000496[4.4.2.5
FilterRegistration getFilterRegistration(String filterName) 37]

{empty}[#50626583_pgfId-1126453]##link:servlet.htm#50626599_pgfId-1000498[4.4.2.6
Map<String, ? extends FilterRegistration> getFilterRegistrations() 37]

{empty}[#50626583_pgfId-1126455]##link:servlet.htm#50626599_pgfId-1000520[4.4.3
Programmatically adding and configuring Listeners 37]

{empty}[#50626583_pgfId-1126457]##link:servlet.htm#50626599_pgfId-1000532[4.4.3.1
void addListener(String className) 37]

{empty}[#50626583_pgfId-1126459]##link:servlet.htm#50626599_pgfId-1000666[4.4.3.2
<T extends EventListener> void addListener(T t) 38]

{empty}[#50626583_pgfId-1126461]##link:servlet.htm#50626599_pgfId-1000705[4.4.3.3
void addListener(Class <? extends EventListener> listenerClass) 38]

{empty}[#50626583_pgfId-1126463]##link:servlet.htm#50626599_pgfId-1000748[4.4.3.4
<T extends EventListener> void createListener(Class<T> clazz) 39]

{empty}[#50626583_pgfId-1126465]##link:servlet.htm#50626599_pgfId-1000887[4.4.3.5
Annotation processing requirements for programmatically added Servlets,
Filters and Listeners 39]

{empty}[#50626583_pgfId-1126467]##link:servlet.htm#50626599_pgfId-1002859[4.4.4
Programmatically configuring session time out 40]

{empty}[#50626583_pgfId-1126469]##link:servlet.htm#50626599_pgfId-1003331[4.4.5
Programmatically configuring character encoding 40]

{empty}[#50626583_pgfId-1126471]##link:servlet.htm#50626599_pgfId-1003691[4.5
Context Attributes 40]

{empty}[#50626583_pgfId-1126473]##link:servlet.htm#50626599_pgfId-999481[4.5.1
Context Attributes in a Distributed Container 41]

{empty}[#50626583_pgfId-1126475]##link:servlet.htm#50626599_pgfId-999486[4.6
Resources 41]

{empty}[#50626583_pgfId-1126477]##link:servlet.htm#50626599_pgfId-999499[4.7
Multiple Hosts and Servlet Contexts 42]

{empty}[#50626583_pgfId-1126479]##link:servlet.htm#50626599_pgfId-999501[4.8
Reloading Considerations 42]

{empty}[#50626583_pgfId-1126481]##link:servlet.htm#50626599_pgfId-999507[4.8.1
Temporary Working Directories 42]

======= [#50626583_pgfId-1126483]##link:servlet.htm#50626600_pgfId-999462[The Response 45]

{empty}[#50626583_pgfId-1126485]##link:servlet.htm#50626600_pgfId-999464[5.1
Buffering 45]

{empty}[#50626583_pgfId-1126487]##link:servlet.htm#50626600_pgfId-999480[5.2
Headers 46]

{empty}[#50626583_pgfId-1126489]##link:servlet.htm#50626600_pgfId-1005248[5.3
HTTP Trailer 47]

{empty}[#50626583_pgfId-1126491]##link:servlet.htm#50626600_pgfId-1003693[5.4
Non Blocking IO 48]

{empty}[#50626583_pgfId-1126493]##link:servlet.htm#50626600_pgfId-1000474[5.5
Convenience Methods 49]

{empty}[#50626583_pgfId-1126495]##link:servlet.htm#50626600_pgfId-999505[5.6
Internationalization 49]

{empty}[#50626583_pgfId-1126497]##link:servlet.htm#50626600_pgfId-999519[5.7
Closure of Response Object 50]

{empty}[#50626583_pgfId-1126499]##link:servlet.htm#50626600_pgfId-999526[5.8
Lifetime of the Response Object 51]

======= [#50626583_pgfId-1126501]##link:servlet.htm#50626598_pgfId-999461[Filtering 53]

{empty}[#50626583_pgfId-1126503]##link:servlet.htm#50626598_pgfId-999471[6.1
What is a filter? 53]

{empty}[#50626583_pgfId-1126505]##link:servlet.htm#50626598_pgfId-999481[6.1.1
Examples of Filtering Components 54]

{empty}[#50626583_pgfId-1126507]##link:servlet.htm#50626598_pgfId-999492[6.2
Main Concepts 54]

{empty}[#50626583_pgfId-1126509]##link:servlet.htm#50626598_pgfId-999495[6.2.1
Filter Lifecycle 54]

{empty}[#50626583_pgfId-1126511]##link:servlet.htm#50626598_pgfId-999511[6.2.2
Wrapping Requests and Responses 56]

{empty}[#50626583_pgfId-1126513]##link:servlet.htm#50626598_pgfId-999516[6.2.3
Filter Environment 56]

{empty}[#50626583_pgfId-1126515]##link:servlet.htm#50626598_pgfId-999519[6.2.4
Configuration of Filters in a Web Application 56]

{empty}[#50626583_pgfId-1126517]##link:servlet.htm#50626598_pgfId-999588[6.2.5
Filters and the RequestDispatcher 59]

======= [#50626583_pgfId-1126519]##link:servlet.htm#50626609_pgfId-999462[Sessions 63]

{empty}[#50626583_pgfId-1126521]##link:servlet.htm#50626609_pgfId-999465[7.1
Session Tracking Mechanisms 63]

{empty}[#50626583_pgfId-1126523]##link:servlet.htm#50626609_pgfId-999467[7.1.1
Cookies 63]

{empty}[#50626583_pgfId-1126525]##link:servlet.htm#50626609_pgfId-999470[7.1.2
SSL Sessions 64]

{empty}[#50626583_pgfId-1126527]##link:servlet.htm#50626609_pgfId-999472[7.1.3
URL Rewriting 64]

{empty}[#50626583_pgfId-1126529]##link:servlet.htm#50626609_pgfId-999476[7.1.4
Session Integrity 64]

{empty}[#50626583_pgfId-1126531]##link:servlet.htm#50626609_pgfId-999478[7.2
Creating a Session 64]

{empty}[#50626583_pgfId-1126533]##link:servlet.htm#50626609_pgfId-999488[7.3
Session Scope 65]

{empty}[#50626583_pgfId-1126535]##link:servlet.htm#50626609_pgfId-999492[7.4
Binding Attributes into a Session 65]

{empty}[#50626583_pgfId-1126537]##link:servlet.htm#50626609_pgfId-999498[7.5
Session Timeouts 66]

{empty}[#50626583_pgfId-1126539]##link:servlet.htm#50626609_pgfId-999501[7.6
Last Accessed Times 66]

{empty}[#50626583_pgfId-1126541]##link:servlet.htm#50626609_pgfId-999504[7.7
Important Session Semantics 67]

{empty}[#50626583_pgfId-1126543]##link:servlet.htm#50626609_pgfId-999506[7.7.1
Threading Issues 67]

{empty}[#50626583_pgfId-1126545]##link:servlet.htm#50626609_pgfId-999508[7.7.2
Distributed Environments 67]

{empty}[#50626583_pgfId-1126547]##link:servlet.htm#50626609_pgfId-999520[7.7.3
Client Semantics 68]

======= [#50626583_pgfId-1126549]##link:servlet.htm#50626585_pgfId-1011339[Annotations and pluggability 69]

{empty}[#50626583_pgfId-1126551]##link:servlet.htm#50626585_pgfId-1001389[8.1
Annotations and pluggability 69]

{empty}[#50626583_pgfId-1126553]##link:servlet.htm#50626585_pgfId-1001326[8.1.1
@WebServlet 71]

{empty}[#50626583_pgfId-1126555]##link:servlet.htm#50626585_pgfId-999590[8.1.2
@WebFilter 72]

{empty}[#50626583_pgfId-1126557]##link:servlet.htm#50626585_pgfId-999611[8.1.3
@WebInitParam 73]

{empty}[#50626583_pgfId-1126559]##link:servlet.htm#50626585_pgfId-999626[8.1.4
@WebListener 73]

{empty}[#50626583_pgfId-1126561]##link:servlet.htm#50626585_pgfId-1006577[8.1.5
@MultipartConfig 73]

{empty}[#50626583_pgfId-1126563]##link:servlet.htm#50626585_pgfId-1003416[8.1.6
Other annotations / conventions 74]

{empty}[#50626583_pgfId-1126565]##link:servlet.htm#50626585_pgfId-1001739[8.2
Pluggability 74]

{empty}[#50626583_pgfId-1126567]##link:servlet.htm#50626585_pgfId-1001794[8.2.1
Modularity of web.xml 74]

{empty}[#50626583_pgfId-1126569]##link:servlet.htm#50626585_pgfId-1003406[8.2.2
Ordering of web.xml and web-fragment.xml 76]

{empty}[#50626583_pgfId-1126571]##link:servlet.htm#50626585_pgfId-1007270[8.2.3
Assembling the descriptor from web.xml, web-fragment.xml and annotations
81]

{empty}[#50626583_pgfId-1126573]##link:servlet.htm#50626585_pgfId-1007575[8.2.4
Shared libraries / runtimes pluggability 93]

{empty}[#50626583_pgfId-1126575]##link:servlet.htm#50626585_pgfId-1002823[8.3
JSP container pluggability 95]

{empty}[#50626583_pgfId-1126577]##link:servlet.htm#50626585_pgfId-1007902[8.4
Processing annotations and fragments 96]

======= [#50626583_pgfId-1126579]##link:servlet.htm#50626608_pgfId-999462[Dispatching Requests 97]

{empty}[#50626583_pgfId-1126581]##link:servlet.htm#50626608_pgfId-999464[9.1
Obtaining a RequestDispatcher 97]

{empty}[#50626583_pgfId-1126583]##link:servlet.htm#50626608_pgfId-999475[9.1.1
Query Strings in Request Dispatcher Paths 98]

{empty}[#50626583_pgfId-1126585]##link:servlet.htm#50626608_pgfId-999481[9.2
Using a Request Dispatcher 98]

{empty}[#50626583_pgfId-1126587]##link:servlet.htm#50626608_pgfId-999485[9.3
The Include Method 99]

{empty}[#50626583_pgfId-1126589]##link:servlet.htm#50626608_pgfId-999488[9.3.1
Included Request Parameters 99]

{empty}[#50626583_pgfId-1126591]##link:servlet.htm#50626608_pgfId-999498[9.4
The Forward Method 100]

{empty}[#50626583_pgfId-1126593]##link:servlet.htm#50626608_pgfId-999503[9.4.1
Query String 100]

{empty}[#50626583_pgfId-1126595]##link:servlet.htm#50626608_pgfId-999505[9.4.2
Forwarded Request Parameters 100]

{empty}[#50626583_pgfId-1126597]##link:servlet.htm#50626608_pgfId-999516[9.5
Error Handling 101]

{empty}[#50626583_pgfId-1126599]##link:servlet.htm#50626608_pgfId-1000148[9.6
Obtaining an AsyncContext 101]

{empty}[#50626583_pgfId-1126601]##link:servlet.htm#50626608_pgfId-1000560[9.7
The Dispatch Method 102]

{empty}[#50626583_pgfId-1126603]##link:servlet.htm#50626608_pgfId-1000354[9.7.1
Query String 102]

{empty}[#50626583_pgfId-1126605]##link:servlet.htm#50626608_pgfId-1000209[9.7.2
Dispatched Request Parameters 102]

======= [#50626583_pgfId-1126607]##link:servlet.htm#50626596_pgfId-999461[Web Applications 105]

{empty}[#50626583_pgfId-1126609]##link:servlet.htm#50626596_pgfId-999463[10.1
Web Applications Within Web Servers 105]

{empty}[#50626583_pgfId-1126611]##link:servlet.htm#50626596_pgfId-999467[10.2
Relationship to ServletContext 105]

{empty}[#50626583_pgfId-1126613]##link:servlet.htm#50626596_pgfId-999469[10.3
Elements of a Web Application 106]

{empty}[#50626583_pgfId-1126615]##link:servlet.htm#50626596_pgfId-999480[10.4
Deployment Hierarchies 106]

{empty}[#50626583_pgfId-1126617]##link:servlet.htm#50626596_pgfId-999483[10.5
Directory Structure 106]

{empty}[#50626583_pgfId-1126619]##link:servlet.htm#50626596_pgfId-999494[10.5.1
Example of Application Directory Structure 108]

{empty}[#50626583_pgfId-1126621]##link:servlet.htm#50626596_pgfId-999505[10.6
Web Application Archive File 108]

{empty}[#50626583_pgfId-1126623]##link:servlet.htm#50626596_pgfId-999508[10.7
Web Application Deployment Descriptor 108]

{empty}[#50626583_pgfId-1126625]##link:servlet.htm#50626596_pgfId-999521[10.7.1
Dependencies On Extensions 109]

{empty}[#50626583_pgfId-1126627]##link:servlet.htm#50626596_pgfId-999527[10.7.2
Web Application Class Loader 109]

{empty}[#50626583_pgfId-1126629]##link:servlet.htm#50626596_pgfId-999529[10.8
Replacing a Web Application 110]

{empty}[#50626583_pgfId-1126631]##link:servlet.htm#50626596_pgfId-999532[10.9
Error Handling 110]

{empty}[#50626583_pgfId-1126633]##link:servlet.htm#50626596_pgfId-999534[10.9.1
Request Attributes 110]

{empty}[#50626583_pgfId-1126635]##link:servlet.htm#50626596_pgfId-999579[10.9.2
Error Pages 111]

{empty}[#50626583_pgfId-1126637]##link:servlet.htm#50626596_pgfId-1000850[10.9.3
Error Filters 112]

{empty}[#50626583_pgfId-1126639]##link:servlet.htm#50626596_pgfId-999597[10.10
Welcome Files 113]

{empty}[#50626583_pgfId-1126641]##link:servlet.htm#50626596_pgfId-999628[10.11
Web Application Environment 114]

{empty}[#50626583_pgfId-1126643]##link:servlet.htm#50626596_pgfId-999633[10.12
Web Application Deployment 114]

{empty}[#50626583_pgfId-1126645]##link:servlet.htm#50626596_pgfId-999640[10.13
Inclusion of a web.xml Deployment Descriptor 115]

======= [#50626583_pgfId-1126647]##link:servlet.htm#50626595_pgfId-999462[Application Lifecycle Events 117]

{empty}[#50626583_pgfId-1126649]##link:servlet.htm#50626595_pgfId-999463[11.1
Introduction 117]

{empty}[#50626583_pgfId-1126651]##link:servlet.htm#50626595_pgfId-999466[11.2
Event Listeners 117]

{empty}[#50626583_pgfId-1126653]##link:servlet.htm#50626595_pgfId-999470[11.2.1
Event Types and Listener Interfaces 118]

{empty}[#50626583_pgfId-1126655]##link:servlet.htm#50626595_pgfId-999570[11.2.2
An Example of Listener Use 119]

{empty}[#50626583_pgfId-1126657]##link:servlet.htm#50626595_pgfId-999575[11.3
Listener Class Configuration 119]

{empty}[#50626583_pgfId-1126659]##link:servlet.htm#50626595_pgfId-999576[11.3.1
Provision of Listener Classes 119]

{empty}[#50626583_pgfId-1126661]##link:servlet.htm#50626595_pgfId-999578[11.3.2
Deployment Declarations 120]

{empty}[#50626583_pgfId-1126663]##link:servlet.htm#50626595_pgfId-999580[11.3.3
Listener Registration 120]

{empty}[#50626583_pgfId-1126665]##link:servlet.htm#50626595_pgfId-1001168[11.3.4
Notifications At Shutdown 120]

{empty}[#50626583_pgfId-1126667]##link:servlet.htm#50626595_pgfId-999584[11.4
Deployment Descriptor Example 120]

{empty}[#50626583_pgfId-1126669]##link:servlet.htm#50626595_pgfId-999588[11.5
Listener Instances and Threading 121]

{empty}[#50626583_pgfId-1126671]##link:servlet.htm#50626595_pgfId-999591[11.6
Listener Exceptions 121]

{empty}[#50626583_pgfId-1126673]##link:servlet.htm#50626595_pgfId-999598[11.7
Distributed Containers 122]

{empty}[#50626583_pgfId-1126675]##link:servlet.htm#50626595_pgfId-999600[11.8
Session Events 122]

======= [#50626583_pgfId-1126677]##link:servlet.htm#50626594_pgfId-999461[Mapping Requests to Servlets 123]

{empty}[#50626583_pgfId-1126679]##link:servlet.htm#50626594_pgfId-999468[12.1
Use of URL Paths 123]

{empty}[#50626583_pgfId-1126681]##link:servlet.htm#50626594_pgfId-999478[12.2
Specification of Mappings 124]

{empty}[#50626583_pgfId-1126683]##link:servlet.htm#50626594_pgfId-999484[12.2.1
Implicit Mappings 124]

{empty}[#50626583_pgfId-1126685]##link:servlet.htm#50626594_pgfId-999487[12.2.2
Example Mapping Set 125]

{empty}[#50626583_pgfId-1126687]##link:servlet.htm#50626594_pgfId-998874[12.3
Runtime Discovery of Mappings 125]

{empty}[#50626583_pgfId-1126689]##link:servlet.htm#50626594_pgfId-1000662[12.3.1
Runtime Discovery of Servlet Mappings 126]

======= [#50626583_pgfId-1126691]##link:servlet.htm#50626593_pgfId-999461[Security 127]

{empty}[#50626583_pgfId-1126693]##link:servlet.htm#50626593_pgfId-999464[13.1
Introduction 127]

{empty}[#50626583_pgfId-1126695]##link:servlet.htm#50626593_pgfId-999471[13.2
Declarative Security 128]

{empty}[#50626583_pgfId-1126697]##link:servlet.htm#50626593_pgfId-999475[13.3
Programmatic Security 128]

{empty}[#50626583_pgfId-1126699]##link:servlet.htm#50626593_pgfId-1000691[13.4
Programmatic Security Policy Configuration 130]

{empty}[#50626583_pgfId-1126701]##link:servlet.htm#50626593_pgfId-1002986[13.4.1
@ServletSecurity Annotation 130]

{empty}[#50626583_pgfId-1126703]##link:servlet.htm#50626593_pgfId-1003384[13.4.1.1
Examples 133]

{empty}[#50626583_pgfId-1126705]##link:servlet.htm#50626593_pgfId-1003421[13.4.1.2
Mapping @ServletSecurity to security-constraint 134]

{empty}[#50626583_pgfId-1126707]##link:servlet.htm#50626593_pgfId-1003464[13.4.1.3
Mapping @HttpConstraint and @HttpMethodConstraint to XML. 136]

{empty}[#50626583_pgfId-1126709]##link:servlet.htm#50626593_pgfId-1003497[13.4.2
setServletSecurity of ServletRegistration.Dynamic 138]

{empty}[#50626583_pgfId-1126711]##link:servlet.htm#50626593_pgfId-1000682[13.5
Roles 138]

{empty}[#50626583_pgfId-1126713]##link:servlet.htm#50626593_pgfId-999497[13.6
Authentication 139]

{empty}[#50626583_pgfId-1126715]##link:servlet.htm#50626593_pgfId-999503[13.6.1
HTTP Basic Authentication 139]

{empty}[#50626583_pgfId-1126717]##link:servlet.htm#50626593_pgfId-999506[13.6.2
HTTP Digest Authentication 139]

{empty}[#50626583_pgfId-1126719]##link:servlet.htm#50626593_pgfId-999509[13.6.3
Form Based Authentication 140]

{empty}[#50626583_pgfId-1126721]##link:servlet.htm#50626593_pgfId-999522[13.6.3.1
Login Form Notes 141]

{empty}[#50626583_pgfId-1126723]##link:servlet.htm#50626593_pgfId-999531[13.6.4
HTTPS Client Authentication 142]

{empty}[#50626583_pgfId-1126725]##link:servlet.htm#50626593_pgfId-1001086[13.6.5
Additional Container Authentication Mechanisms 142]

{empty}[#50626583_pgfId-1126727]##link:servlet.htm#50626593_pgfId-999533[13.7
Server Tracking of Authentication Information 142]

{empty}[#50626583_pgfId-1126729]##link:servlet.htm#50626593_pgfId-999540[13.8
Specifying Security Constraints 143]

{empty}[#50626583_pgfId-1126731]##link:servlet.htm#50626593_pgfId-999553[13.8.1
Combining Constraints 144]

{empty}[#50626583_pgfId-1126733]##link:servlet.htm#50626593_pgfId-999557[13.8.2
Example 145]

{empty}[#50626583_pgfId-1126735]##link:servlet.htm#50626593_pgfId-999734[13.8.3
Processing Requests 147]

{empty}[#50626583_pgfId-1126737]##link:servlet.htm#50626593_pgfId-1005375[13.8.4
Uncovered HTTP Protocol Methods 148]

{empty}[#50626583_pgfId-1126739]##link:servlet.htm#50626593_pgfId-1006487[13.8.4.1
Rules for Security Constraint Configuration 150]

{empty}[#50626583_pgfId-1126741]##link:servlet.htm#50626593_pgfId-1005509[13.8.4.2
Handling Uncovered HTTP Methods 150]

{empty}[#50626583_pgfId-1126743]##link:servlet.htm#50626593_pgfId-999741[13.9
Default Policies 151]

{empty}[#50626583_pgfId-1126745]##link:servlet.htm#50626593_pgfId-999743[13.10
Login and Logout 152]

======= [#50626583_pgfId-1126747]##link:servlet.htm#50626592_pgfId-1009100[Deployment Descriptor 153]

{empty}[#50626583_pgfId-1126749]##link:servlet.htm#50626592_pgfId-1009123[14.1
Deployment Descriptor Elements 153]

{empty}[#50626583_pgfId-1126751]##link:servlet.htm#50626592_pgfId-999481[14.2
Rules for Processing the Deployment Descriptor 154]

{empty}[#50626583_pgfId-1126753]##link:servlet.htm#50626592_pgfId-1004357[14.3
Deployment Descriptor 155]

{empty}[#50626583_pgfId-1126755]##link:servlet.htm#50626592_pgfId-1012707[14.4
Deployment Descriptor Diagram 155]

{empty}[#50626583_pgfId-1126757]##link:servlet.htm#50626592_pgfId-1000940[14.5
Examples 178]

{empty}[#50626583_pgfId-1126759]##link:servlet.htm#50626592_pgfId-1000942[14.5.1
A Basic Example 179]

{empty}[#50626583_pgfId-1126761]##link:servlet.htm#50626592_pgfId-1000944[14.5.2
An Example of Security 180]

======= [#50626583_pgfId-1126763]##link:servlet.htm#50626607_pgfId-999462[Requirements related to other Specifications 183]

{empty}[#50626583_pgfId-1126765]##link:servlet.htm#50626607_pgfId-999467[15.1
Sessions 183]

{empty}[#50626583_pgfId-1126767]##link:servlet.htm#50626607_pgfId-1002827[15.2
Web Applications 183]

{empty}[#50626583_pgfId-1126769]##link:servlet.htm#50626607_pgfId-1002829[15.2.1
Web Application Class Loader 183]

{empty}[#50626583_pgfId-1126771]##link:servlet.htm#50626607_pgfId-999477[15.2.2
Web Application Environment 184]

{empty}[#50626583_pgfId-1126773]##link:servlet.htm#50626607_pgfId-1001877[15.2.3
JNDI Name for Web Module Context Root URL 184]

{empty}[#50626583_pgfId-1126775]##link:servlet.htm#50626607_pgfId-1001878[15.3
Security 185]

{empty}[#50626583_pgfId-1126777]##link:servlet.htm#50626607_pgfId-999494[15.3.1
Propagation of Security Identity in EJB™ Calls 185]

{empty}[#50626583_pgfId-1126779]##link:servlet.htm#50626607_pgfId-1002577[15.3.2
Container Authorization Requirements 186]

{empty}[#50626583_pgfId-1126781]##link:servlet.htm#50626607_pgfId-1001652[15.3.3
Container Authentication Requirements 186]

{empty}[#50626583_pgfId-1126783]##link:servlet.htm#50626607_pgfId-999501[15.4
Deployment 186]

{empty}[#50626583_pgfId-1126785]##link:servlet.htm#50626607_pgfId-999503[15.4.1
Deployment Descriptor Elements 187]

{empty}[#50626583_pgfId-1126787]##link:servlet.htm#50626607_pgfId-999510[15.4.2
Packaging and Deployment of JAX-WS Components 187]

{empty}[#50626583_pgfId-1126789]##link:servlet.htm#50626607_pgfId-999527[15.4.3
Rules for Processing the Deployment Descriptor 188]

{empty}[#50626583_pgfId-1126791]##link:servlet.htm#50626607_pgfId-999531[15.5
Annotations and Resource Injection 188]

{empty}[#50626583_pgfId-1126793]##link:servlet.htm#50626607_pgfId-999570[15.5.1
@DeclareRoles 190]

{empty}[#50626583_pgfId-1126795]##link:servlet.htm#50626607_pgfId-999590[15.5.2
@EJB Annotation 191]

{empty}[#50626583_pgfId-1126797]##link:servlet.htm#50626607_pgfId-999599[15.5.3
@EJBs Annotation 191]

{empty}[#50626583_pgfId-1126799]##link:servlet.htm#50626607_pgfId-999611[15.5.4
@Resource Annotation 192]

{empty}[#50626583_pgfId-1126801]##link:servlet.htm#50626607_pgfId-999626[15.5.5
@PersistenceContext Annotation 192]

{empty}[#50626583_pgfId-1126803]##link:servlet.htm#50626607_pgfId-999635[15.5.6
@PersistenceContexts Annotation 193]

{empty}[#50626583_pgfId-1126805]##link:servlet.htm#50626607_pgfId-999637[15.5.7
@PersistenceUnit Annotation 193]

{empty}[#50626583_pgfId-1126807]##link:servlet.htm#50626607_pgfId-999646[15.5.8
@PersistenceUnits Annotation 193]

{empty}[#50626583_pgfId-1126809]##link:servlet.htm#50626607_pgfId-999648[15.5.9
@PostConstruct Annotation 193]

{empty}[#50626583_pgfId-1126811]##link:servlet.htm#50626607_pgfId-999662[15.5.10
@PreDestroy Annotation 194]

{empty}[#50626583_pgfId-1126813]##link:servlet.htm#50626607_pgfId-999677[15.5.11
@Resources Annotation 195]

{empty}[#50626583_pgfId-1126815]##link:servlet.htm#50626607_pgfId-999692[15.5.12
@RunAs Annotation 195]

{empty}[#50626583_pgfId-1126817]##link:servlet.htm#50626607_pgfId-999723[15.5.13
@WebServiceRef Annotation 196]

{empty}[#50626583_pgfId-1126819]##link:servlet.htm#50626607_pgfId-999732[15.5.14
@WebServiceRefs Annotation 196]

{empty}[#50626583_pgfId-1126821]##link:servlet.htm#50626607_pgfId-1002115[15.5.15
Contexts and Dependency Injection for Java EE requirements 197]

======= [#50626583_pgfId-1126823]##link:servlet.htm#50626587_pgfId-1007323[Change Log 199]

{empty}[#50626583_pgfId-1126825]##link:servlet.htm#50626587_pgfId-1004208[A.1
Changes Since Servlet 3.1 199]

{empty}[#50626583_pgfId-1126827]##link:servlet.htm#50626587_pgfId-1007297[A.2
Changes since Servlet 3.0 201]

{empty}[#50626583_pgfId-1126829]##link:servlet.htm#50626587_pgfId-1002163[A.3
Changes since Servlet 3.0 Proposed Final Draft 203]

{empty}[#50626583_pgfId-1126831]##link:servlet.htm#50626587_pgfId-1001456[A.4
Changes since Servlet 3.0 Public Review 203]

{empty}[#50626583_pgfId-1126833]##link:servlet.htm#50626587_pgfId-1001416[A.5
Changes since Servlet 3.0 EDR 204]

{empty}[#50626583_pgfId-1126835]##link:servlet.htm#50626587_pgfId-1001381[A.6
Changes since Servlet 2.5 MR6 204]

{empty}[#50626583_pgfId-1126837]##link:servlet.htm#50626587_pgfId-1001360[A.7
Changes since Servlet 2.5 MR 5 205]

{empty}[#50626583_pgfId-1126839]##link:servlet.htm#50626587_pgfId-1000067[A.7.1
Clarify SRV 8.4 "The Forward Method" 205]

{empty}[#50626583_pgfId-1126841]##link:servlet.htm#50626587_pgfId-1000073[A.7.2
Update Deployment descriptor "http-method values allowed" 205]

{empty}[#50626583_pgfId-1126843]##link:servlet.htm#50626587_pgfId-1000079[A.7.3
Clarify SRV 7.7.1 "Threading Issues" 205]

{empty}[#50626583_pgfId-1126845]##link:servlet.htm#50626587_pgfId-1000085[A.8
Changes Since Servlet 2.5 MR 2 206]

{empty}[#50626583_pgfId-1126847]##link:servlet.htm#50626587_pgfId-1000086[A.8.1
Updated Annotation Requirements for Java EE containers 206]

{empty}[#50626583_pgfId-1126849]##link:servlet.htm#50626587_pgfId-1000091[A.8.2
Updated Java Enterprise Edition Requirements 206]

{empty}[#50626583_pgfId-1126851]##link:servlet.htm#50626587_pgfId-1000093[A.8.3
Clarified HttpServletRequest.getRequestURL() 206]

{empty}[#50626583_pgfId-1126853]##link:servlet.htm#50626587_pgfId-1000100[A.8.4
Removal of IllegalStateException from HttpSession.getId() 207]

{empty}[#50626583_pgfId-1126855]##link:servlet.htm#50626587_pgfId-1000103[A.8.5
ServletContext.getContextPath() 207]

{empty}[#50626583_pgfId-1126857]##link:servlet.htm#50626587_pgfId-1000121[A.8.6
Requirement for web.xml in web applications 207]

{empty}[#50626583_pgfId-1126859]##link:servlet.htm#50626587_pgfId-1000128[A.9
Changes Since Servlet 2.4 208]

{empty}[#50626583_pgfId-1126861]##link:servlet.htm#50626587_pgfId-1000129[A.9.1
Session Clarification 208]

{empty}[#50626583_pgfId-1126863]##link:servlet.htm#50626587_pgfId-1000150[A.9.2
Filter All Dispatches 208]

{empty}[#50626583_pgfId-1126865]##link:servlet.htm#50626587_pgfId-1000165[A.9.3
Multiple Occurrences of Servlet Mappings 209]

{empty}[#50626583_pgfId-1126867]##link:servlet.htm#50626587_pgfId-1006109[A.9.4
Multiple Occurrences Filter Mappings 209]

{empty}[#50626583_pgfId-1126869]##link:servlet.htm#50626587_pgfId-1000214[A.9.5
Support Alternative HTTP Methods with Authorization Constraints 210]

{empty}[#50626583_pgfId-1126871]##link:servlet.htm#50626587_pgfId-1000247[A.9.6
Minimum J2SE Requirement 211]

{empty}[#50626583_pgfId-1126873]##link:servlet.htm#50626587_pgfId-1000252[A.9.7
Annotations and Resource Injection 211]

{empty}[#50626583_pgfId-1126875]##link:servlet.htm#50626587_pgfId-1000258[A.9.8
SRV.9.9 ("Error Handling") Requirement Removed 212]

{empty}[#50626583_pgfId-1126877]##link:servlet.htm#50626587_pgfId-1000271[A.9.9
HttpServletRequest.isRequestedSessionIdValid() Clarification 212]

{empty}[#50626583_pgfId-1126879]##link:servlet.htm#50626587_pgfId-1000279[A.9.10
SRV.5.5 ("Closure of Response Object") Clarification 212]

{empty}[#50626583_pgfId-1126881]##link:servlet.htm#50626587_pgfId-1000296[A.9.11
ServletRequest.setCharacterEncoding() Clarified 213]

{empty}[#50626583_pgfId-1126883]##link:servlet.htm#50626587_pgfId-1000301[A.9.12
Java Enterprise Edition Requirements 213]

{empty}[#50626583_pgfId-1126885]##link:servlet.htm#50626587_pgfId-1000306[A.9.13
Servlet 2.4 MR Change Log Updates Added 213]

{empty}[#50626583_pgfId-1126887]##link:servlet.htm#50626587_pgfId-1000308[A.9.14
Synchronized Access Session Object Clarified 213]

{empty}[#50626583_pgfId-1126889]##link:servlet.htm#50626587_pgfId-1000313[A.10
Changes Since Servlet 2.3 213]

== [#50626602_pgfId-999461]## 

=== [#50626602_pgfId-999462]##

image:servlet-6.gif[image]

Overview

image:servlet-7.gif[image]

==== [#50626602_pgfId-999786]##

image:servlet-8.gif[image]

[#50626602_52497]##What is a Servlet?

[#50626602_pgfId-999787]##A servlet is a Java™ technology-based Web
component, managed by a container, that generates dynamic content. Like
other Java technology-based components, servlets are
platform-independent Java classes that are compiled to platform-neutral
byte code that can be loaded dynamically into and run by a Java
technology-enabled Web server. Containers, sometimes called servlet
engines, are Web server extensions that provide servlet functionality.
Servlets interact with Web clients via a request/response paradigm
implemented by the servlet container.

==== [#50626602_pgfId-999789]##

image:servlet-8.gif[image]

[#50626602_95812]##What is a Servlet Container?

[#50626602_pgfId-999790]##The servlet container is a part of a Web
server or application server that provides the network services over
which requests and responses are sent, decodes MIME-based requests, and
formats MIME-based responses. A servlet container also contains and
manages servlets through their lifecycle.

[#50626602_pgfId-999791]##A servlet container can be built into a host
Web server, or installed as an add-on component to a Web Server via that
server’s native extension API. Servlet containers can also be built into
or possibly installed into Web-enabled application servers.

[#50626602_pgfId-999792]##All servlet containers must support HTTP as a
protocol for requests and responses, but additional
request/response-based protocols such as HTTPS (HTTP over SSL) may be
supported. The required versions of the HTTP specification that a
container must implement are HTTP/1.1 and HTTP/2. When supporting
HTTP/2, servlet containers must support the “h2” and “h2c” protocol
identifiers (as specified in section 3.1 of the HTTP/2 RFC). This
implies all servlet containers must support ALPN. Because the container
may have a caching mechanism described in RFC 7234 (HTTP/1.1 Caching),
it may modify requests from the clients before delivering them to the
servlet, may modify responses produced by servlets before sending them
to the clients, or may respond to requests without delivering them to
the servlet under the compliance with RFC 7234.

[#50626602_pgfId-1000432]##A servlet container may place security
restrictions on the environment in which a servlet executes. In a Java
__ Platform, Standard Edition (J2SE, v.1.3 or above) or Java Platform,
Enterprise Edition (Java EE, v.1.3 or above) environment, these
restrictions should be placed using the permission architecture defined
by the Java platform. For example some application servers may limit the
creation of a _Thread_ object to insure that other components of the
container are not negatively impacted.

[#50626602_pgfId-1000433]##Java SE 8 is the minimum version of the
underlying Java platform with which servlet containers must be built.

==== [#50626602_pgfId-999795]##

image:servlet-8.gif[image]

An Example

[#50626602_pgfId-999796]##The following is a typical sequence of events:

[#50626602_pgfId-999797]##A client (e.g., a Web browser) accesses a Web
server and makes an HTTP request.

[#50626602_pgfId-999798]##The request is received by the Web server and
handed off to the servlet container. The servlet container can be
running in the same process as the host Web server, in a different
process on the same host, or on a different host from the Web server for
which it processes requests.

[#50626602_pgfId-999799]##The servlet container determines which servlet
to invoke based on the configuration of its servlets, and calls it with
objects representing the request and response.

[#50626602_pgfId-999800]##The servlet uses the request object to find
out who the remote user is, what HTTP _POST_ parameters may have been
sent as part of this request, and other relevant data. The servlet
performs whatever logic it was programmed with, and generates data to
send back to the client. It sends this data back to the client via the
response object.

[#50626602_pgfId-999801]##Once the servlet has finished processing the
request, the servlet container ensures that the response is properly
flushed, and returns control back to the host Web server.

==== [#50626602_pgfId-999802]##

image:servlet-8.gif[image]

Comparing Servlets with Other Technologies

[#50626602_pgfId-999803]##In functionality, servlets provide a higher
level abstraction than Common Gateway Interface (CGI) programs but a
lower level of abstraction than that provided by web frameworks such as
JavaServer Faces.

[#50626602_pgfId-999804]##Servlets have the following advantages over
other server extension mechanisms:

[#50626602_pgfId-999805]##They are generally much faster than CGI
scripts because a different process model is used.

[#50626602_pgfId-999806]##They use a standard API that is supported by
many Web servers.

[#50626602_pgfId-999807]##They have all the advantages of the Java
programming language, including ease of development and platform
independence.

[#50626602_pgfId-999808]##They can access the large set of APIs
available for the Java platform.

==== [#50626602_pgfId-999809]##

image:servlet-8.gif[image]

Relationship to Java Platform, Enterprise Edition

[#50626602_pgfId-999810]##The Java Servlet API v.4.0 is a required API
of the Java Platform, Enterprise Edition, 8link:#pgfId-999813[2].
Servlet containers and servlets deployed into them must meet additional
requirements, described in the Java EE specification, for executing in a
Java EE environment.

==== [#50626602_pgfId-999814]##

image:servlet-8.gif[image]

[#50626602_67310]##Compatibility with Java Servlet Specification Version
2.5

===== [#50626602_pgfId-1000243]##[#50626602_31045]##Processing annotations

[#50626602_pgfId-1000570]##In Servlet 2.5, _metadata-complete_ only
affected the scanning of annotations at deployment time. The notion of
web-fragments did not exist in servlet 2.5. However in servlet 3.0 and
later, _metadata-complete_ affects scanning of all annotations that
specify deployment information and web-fragments at deployment time. The
version of the descriptor MUST not affect which annotations the
container scans for in a web application. An implementation of a
particular version of the specification MUST scan for all annotations
supported in that configuration, unless _metadata-complete_ is
specified.

[#50626602_pgfId-1000193]## 

== [#50626601_pgfId-1009220]## 

=== [#50626601_pgfId-1009221]##

image:servlet-9.gif[image]

The Servlet Interface

image:servlet-10.gif[image]

[#50626601_pgfId-999466]##The _Servlet_ interface is the central
abstraction of the Java Servlet API. All servlets implement this
interface either directly, or more commonly, by extending a class that
implements the interface. The two classes in the Java Servlet API that
implement the _Servlet_ interface are _GenericServlet_ and _HttpServlet_
. For most purposes, Developers will extend _HttpServlet_ to implement
their servlets.

==== [#50626601_pgfId-999468]##

image:servlet-11.gif[image]

[#50626601_28082]##Request Handling Methods

[#50626601_pgfId-999469]##The basic _Servlet_ interface defines a
_service_ method for handling client requests. This method is called for
each request that the servlet container routes to an instance of a
servlet.

[#50626601_pgfId-999470]##The handling of concurrent requests to a Web
application generally requires that the Web Developer design servlets
that can deal with multiple threads executing within the _service_
method at a particular time.

[#50626601_pgfId-999471]##Generally the Web container handles concurrent
requests to the same servlet by concurrent execution of the _service_
method on different threads.

===== [#50626601_pgfId-999472]##HTTP Specific Request Handling Methods

[#50626601_pgfId-999473]##The _HttpServlet_ abstract subclass adds
additional methods beyond the basic _Servlet_ interface that are
automatically called by the _service_ method in the _HttpServlet_ class
to aid in processing HTTP-based requests. These methods are:

[#50626601_pgfId-999474]## _doGet_ for handling HTTP _GET_ requests

[#50626601_pgfId-999475]## _doPost_ for handling HTTP _POST_ requests

[#50626601_pgfId-999476]## _doPut_ for handling HTTP _PUT_ requests

[#50626601_pgfId-999477]## _doDelete_ for handling HTTP _DELETE_
requests

[#50626601_pgfId-999478]## _doHead_ for handling HTTP _HEAD_ requests

[#50626601_pgfId-999479]## _doOptions_ for handling HTTP _OPTIONS_
requests

[#50626601_pgfId-999480]## _doTrace_ for handling HTTP _TRACE_ requests

[#50626601_pgfId-999481]##Typically when developing HTTP-based servlets,
a Servlet Developer will only concern himself with the _doGet_ and
_doPost_ methods. The other methods are considered to be methods for use
by programmers very familiar with HTTP programming.

===== [#50626601_pgfId-999482]##Additional Methods

[#50626601_pgfId-999483]##The _doPut_ and _doDelete_ methods allow
Servlet Developers to support HTTP/1.1 clients that employ these
features. The _doHead_ method in _HttpServlet_ is a specialized form of
the _doGet_ method that returns only the headers produced by the _doGet_
method. The _doOptions_ method responds with which HTTP methods are
supported by the servlet. The _doTrace_ method generates a response
containing all instances of the headers sent in the _TRACE_ request.

[#50626601_pgfId-1009055]##The _CONNECT_ method is not supported because
it applies to proxies and the Servlet API is targeted at endpoints.

===== [#50626601_pgfId-999484]##Conditional GET Support

[#50626601_pgfId-999485]##The _HttpServlet_ interface defines the
_getLastModified_ method to support conditional _GET_ operations. A
conditional _GET_ operation requests a resource be sent only if it has
been modified since a specified time. In appropriate situations,
implementation of this method may aid efficient utilization of network
resources.

==== [#50626601_pgfId-1003413]##

image:servlet-11.gif[image]

Number of Instances

[#50626601_pgfId-1003414]##The servlet declaration which is either via
the annotation as described in link:servlet.htm#50626585_94869[See
Annotations and pluggability] or part of the deployment descriptor of
the Web application containing the servlet, as described in
link:servlet.htm#50626592_84118[See Deployment Descriptor], controls how
the servlet container provides instances of the servlet.

[#50626601_pgfId-999491]##For a servlet not hosted in a distributed
environment (the default), the servlet container must use only one
instance per servlet declaration. However, for a servlet implementing
the _SingleThreadModel_ interface, the servlet container may instantiate
multiple instances to handle a heavy request load and serialize requests
to a particular instance.

[#50626601_pgfId-1000345]##In the case where a servlet was deployed as
part of an application marked in the deployment descriptor as
distributable, a container may have only one instance per servlet
declaration per Java Virtual Machine (JVM™)link:#pgfId-1000348[3].
However, if the servlet in a distributable application implements the
_SingleThreadModel_ interface, the container may instantiate multiple
instances of that servlet in each JVM of the container.

===== [#50626601_pgfId-999497]##Note About The Single Thread Model

[#50626601_pgfId-999498]##The use of the _SingleThreadModel_ interface
guarantees that only one thread at a time will execute in a given
servlet instance’s _service_ method. It is important to note that this
guarantee only applies to each servlet instance, since the container may
choose to pool such objects. Objects that are accessible to more than
one servlet instance at a time, such as instances of _HttpSession_ , may
be available at any particular time to multiple servlets, including
those that implement _SingleThreadModel_ .

[#50626601_pgfId-999499]##It is recommended that a developer take other
means to resolve those issues instead of implementing this interface,
such as avoiding the usage of an instance variable or synchronizing the
block of the code accessing those resources. The _SingleThreadModel_
Interface is deprecated in this version of the specification.

==== [#50626601_pgfId-999500]##

image:servlet-11.gif[image]

Servlet Life Cycle

[#50626601_pgfId-999501]##A servlet is managed through a well defined
life cycle that defines how it is loaded and instantiated, is
initialized, handles requests from clients, and is taken out of service.
This life cycle is expressed in the API by the _init_ , _service_ , and
_destroy_ methods of the _javax.servlet.Servlet_ interface that all
servlets must implement directly or indirectly through the
_GenericServlet_ or _HttpServlet_ abstract classes.

===== [#50626601_pgfId-999502]##Loading and Instantiation

[#50626601_pgfId-999503]##The servlet container is responsible for
loading and instantiating servlets. The loading and instantiation can
occur when the container is started, or delayed until the container
determines the servlet is needed to service a request.

[#50626601_pgfId-999504]##When the servlet engine is started, needed
servlet classes must be located by the servlet container. The servlet
container loads the servlet class using normal Java class loading
facilities. The loading may be from a local file system, a remote file
system, or other network services.

[#50626601_pgfId-999505]##After loading the _Servlet_ class, the
container instantiates it for use.

===== [#50626601_pgfId-999506]##Initialization

[#50626601_pgfId-999507]##After the servlet object is instantiated, the
container must initialize the servlet before it can handle requests from
clients. Initialization is provided so that a servlet can read
persistent configuration data, initialize costly resources (such as
JDBC™ API-based connections), and perform other one-time activities. The
container initializes the servlet instance by calling the _init_ method
of the _Servlet_ interface with a unique (per servlet declaration)
object implementing the _ServletConfig_ interface. This configuration
object allows the servlet to access name-value initialization parameters
from the Web application’s configuration information. The configuration
object also gives the servlet access to an object (implementing the
_ServletContext_ interface) that describes the servlet’s runtime
environment. See link:servlet.htm#50626599_56343[See Servlet Context]
for more information about the _ServletContext_ interface.

====== [#50626601_pgfId-999511]##Error Conditions on Initialization

[#50626601_pgfId-999512]##During initialization, the servlet instance
can throw an _UnavailableException_ or a _ServletException_ . In this
case, the servlet must not be placed into active service and must be
released by the servlet container. The _destroy_ method is not called as
it is considered unsuccessful initialization.

[#50626601_pgfId-999513]##A new instance may be instantiated and
initialized by the container after a failed initialization. The
exception to this rule is when an _UnavailableException_ indicates a
minimum time of unavailability, and the container must wait for the
period to pass before creating and initializing a new servlet instance.

====== [#50626601_pgfId-999514]##Tool Considerations

[#50626601_pgfId-999515]##The triggering of static initialization
methods when a tool loads and introspects a Web application is to be
distinguished from the calling of the _init_ method. Developers should
not assume a servlet is in an active container runtime until the _init_
method of the _Servlet_ interface is called. For example, a servlet
should not try to establish connections to databases or Enterprise
JavaBeans™ containers when only static (class) initialization methods
have been invoked.

===== [#50626601_pgfId-999516]##Request Handling

[#50626601_pgfId-999517]##After a servlet is properly initialized, the
servlet container may use it to handle client requests. Requests are
represented by request objects of type _ServletRequest._ The servlet
fills out response to requests by calling methods of a provided object
of type _ServletResponse_ . These objects are passed as parameters to
the _service_ method of the _Servlet_ interface.

[#50626601_pgfId-999518]##In the case of an HTTP request, the objects
provided by the container are of types _HttpServletRequest_ and
_HttpServletResponse_ .

[#50626601_pgfId-999519]##Note that a servlet instance placed into
service by a servlet container may handle no requests during its
lifetime.

====== [#50626601_pgfId-999520]##Multithreading Issues

[#50626601_pgfId-999521]##A servlet container may send concurrent
requests through the _service_ method of the servlet. To handle the
requests, the Servlet Developer must make adequate provisions for
concurrent processing with multiple threads in the _service_ method.

[#50626601_pgfId-999522]##Although it is not recommended, an alternative
for the Developer is to implement the _SingleThreadModel_ interface
which requires the container to guarantee that there is only one request
thread at a time in the _service_ method. A servlet container may
satisfy this requirement by serializing requests on a servlet, or by
maintaining a pool of servlet instances. If the servlet is part of a Web
application that has been marked as distributable, the container may
maintain a pool of servlet instances in each JVM that the application is
distributed across.

[#50626601_pgfId-999523]##For servlets not implementing the
_SingleThreadModel_ interface, if the _service_ method (or methods such
as _doGet_ or _doPost_ to which the _service_ method of the
_HttpServlet_ abstract class is dispatched) has been defined with the
_synchronized_ keyword, the servlet container cannot use the instance
pool approach, but must serialize requests through it. It is strongly
recommended that Developers not synchronize the _service_ method (or
methods dispatched to it) in these circumstances because of detrimental
effects on performance.

====== [#50626601_pgfId-999524]##Exceptions During Request Handling

[#50626601_pgfId-999525]##A servlet may throw either a
_ServletException_ or an _UnavailableException_ during the service of a
request. A _ServletException_ signals that some error occurred during
the processing of the request and that the container should take
appropriate measures to clean up the request.

[#50626601_pgfId-999526]##An _UnavailableException_ signals that the
servlet is unable to handle requests either temporarily or permanently.

[#50626601_pgfId-999527]##If a permanent unavailability is indicated by
the _UnavailableException_ , the servlet container must remove the
servlet from service, call its _destroy_ method, and release the servlet
instance. Any requests refused by the container by that cause must be
returned with a _SC_NOT_FOUND_ (404) response.

[#50626601_pgfId-999528]##If temporary unavailability is indicated by
the _UnavailableException_ , the container may choose to not route any
requests through the servlet during the time period of the temporary
unavailability. Any requests refused by the container during this period
must be returned with a _SC_SERVICE_UNAVAILABLE_ (503) response status
along with a _Retry-After_ header indicating when the unavailability
will terminate.

[#50626601_pgfId-999529]##The container may choose to ignore the
distinction between a permanent and temporary unavailability and treat
all _UnavailableExceptions_ as permanent, thereby removing a servlet
that throws any _UnavailableException_ from service.

====== [#50626601_pgfId-999530]##[#50626601_53655]##Asynchronous processing

[#50626601_pgfId-1001078]##Some times a filter and/or servlet is unable
to complete the processing of a request without waiting for a resource
or event before generating a response. For example, a servlet may need
to wait for an available JDBC connection, for a response from a remote
web service, for a JMS message, or for an application event, before
proceeding to generate a response. Waiting within the servlet is an
inefficient operation as it is a blocking operation that consumes a
thread and other limited resources. Frequently a slow resource such as a
database may have many threads blocked waiting for access and can cause
thread starvation and poor quality of service for an entire web
container.

[#50626601_pgfId-1001079]##The asynchronous processing of requests is
introduced to allow the thread to return to the container and perform
other tasks. When asynchronous processing begins on the request, another
thread or callback may either generate the response and call _complete_
or dispatch the request so that it may run in the context of the
container using the _AsyncContext.dispatch_ method. A typical sequence
of events for asynchronous processing is:

[#50626601_pgfId-1000496]##The request is received and passed via normal
filters for authentication etc. to the servlet.

[#50626601_pgfId-1000502]##The servlet processes the request parameters
and/or content to determine the nature of the request.

[#50626601_pgfId-1001307]##The servlet issues requests for resources or
data, for example, sends a remote web service request or joins a queue
waiting for a JDBC connection.

[#50626601_pgfId-1001308]##The servlet returns without generating a
response.

[#50626601_pgfId-1003774]##After some time, the requested resource
becomes available, the thread handling that event continues processing
either in the same thread or by dispatching to a resource in the
container using the _AsyncContext_ .

[#50626601_pgfId-1003775]##Java Enterprise Edition features such as
link:servlet.htm#50626607_Web%20Application%20Environment[See Web
Application Environment] and
link:servlet.htm#50626607_Propagation%20of%20Security%20Identity%20in%20EJB%20Calls[See
Propagation of Security Identity in EJB™ Calls] are available only to
threads executing the initial request or when the request is dispatched
to the container via the _AsyncContext.dispatch_ method. Java Enterprise
Edition features may be available to other threads operating directly on
the response object via the _AsyncContext.start(Runnable)_ method.

[#50626601_pgfId-1003202]##The _@WebServlet_ and _@WebFilter_
annotations described in Chapter 8 have an attribute _- asyncSupported_
that is a _boolean_ with a default value of _false_ . When
_asyncSupported_ is set to true the application can start asynchronous
processing in a separate thread by calling _startAsync_ (see below),
passing it a reference to the request and response objects, and then
exit from the container on the original thread. This means that the
response will traverse (in reverse order) the same filters (or filter
chain) that were traversed on the way in. The response isn't committed
till _complete_ (see below) is called on the _AsyncContext_ . The
application is responsible to handle concurrent access to the request
and response objects if the async task is executing before the
container-initiated dispatch that called _startAsync_ has returned to
the container.

[#50626601_pgfId-1001779]##Dispatching from a servlet that has
_asyncSupported=true_ to one where _asyncSupported_ is set to _false_ is
allowed. In this case, the response will be committed when the service
method of the servlet that does not support async is exited, and it is
the container's responsibility to call _complete_ on the _AsyncContext_
so that any interested _AsyncListener_ instances will be notified. The
_AsyncListener.onComplete_ notification should also be used by filters
as a mechanism to clear up resources that it has been holding on to for
the async task to complete.

[#50626601_pgfId-1001798]##Dispatching from a synchronous servlet to an
asynchronous servlet would be illegal. However the decision of throwing
an _IllegalStateException_ is deferred to the point when the application
calls _startAsync_ . This would allow a servlet to either function as a
synchronous or an asynchronous servlet.

[#50626601_pgfId-1000623]##The async task that the application is
waiting for could write directly to the response, on a different thread
than the one that was used for the initial request. This thread knows
nothing about any filters. If a filter wanted to manipulate the response
in the new thread, it would have to wrap the response when it was
processing the initial request "on the way in", and passed the wrapped
response to the next filter in the chain, and eventually to the servlet.
So if the response was wrapped (possibly multiple times, once per
filter), and the application processes the request and writes directly
to the response, it is really writing to the response wrapper(s), i.e.,
any output added to the response will still be processed by the response
wrapper(s). When an application reads from a request in a separate
thread, and adds output to the response, it really reads from the
request wrapper(s), and writes to the response wrapper(s), so any input
and/or output manipulation intended by the wrapper(s) will continue to
occur.

[#50626601_pgfId-1003119]##Alternately if the application chooses to do
so it can use the _AsyncContext_ to _dispatch_ the request from the new
thread to a resource in the container. This would enable using content
generation technologies like JSP within the scope of the container.

[#50626601_pgfId-1003121]##In addition to the annotation attributes we
have the following methods / classes added:

======= [#50626601_pgfId-1000979]## _ServletRequest_

[#50626601_pgfId-1003788]## _public AsyncContext
startAsync(ServletRequest req, ServletResponse res)_ . This method puts
the request into asynchronous mode and initializes its _AsyncContext_
with the given request and response objects and the time out returned by
_getAsyncTimeout_ . The _ServletRequest_ and _ServletResponse_
parameters MUST be either the same objects as were passed to the calling
servlet’s _service_ , or the filter’s _doFilter_ method, or be
subclasses of _ServletRequestWrapper_ or _ServletResponseWrapper_
classes that wrap them. A call to this method ensures that the response
isn't committed when the application exits out of the _service_ method.
It is committed when _AsyncContext.complete_ is called on the returned
_AsyncContext_ or the _AsyncContext_ times out and there are no
listeners associated to handle the time out. The timer for async time
outs will not start until the request and it’s associated response have
returned from the container. The _AsyncContext_ could be used to write
to the response from the async thread. It can also be used to just
notify that the response is not closed and committed.

[#50626601_pgfId-1004992]##It is illegal to call _startAsync_ if the
request is within the scope of a servlet or filter that does not support
asynchronous operations, or if the response has been committed and
closed, or is called again during the same _dispatch_ . The
_AsyncContext_ returned from a call to _startAsync_ can then be used for
further asynchronous processing. Calling the
_AsyncContext.hasOriginalRequestResponse()_ on the returned
_AsyncContext_ will return _false_ , unless the passed _ServletRequest_
and _ServletResponse_ arguments are the original ones or do not carry
application provided wrappers. Any filters invoked in the outboud
direction after this request was put into asynchronous mode MAY use this
as an indication that some of the request and / or response wrappers
that they added during their inbound invocation MAY need to stay in
place for the duration of the asynchronous operation, and their
associated resources MAY not be released. A _ServletRequestWrapper_
applied during the inbound invocation of a filter MAY be released by the
outbound invocation of the filter only if the given _ServletRequest_
which is used to initialize the _AsyncContext_ and will be returned by a
call to _AsyncContext.getRequest()_ , does not contain the said
_ServletRequestWrapper_ . The same holds true for
_ServletResponseWrapper_ instances.

[#50626601_pgfId-1001994]## _public AsyncContext startAsync()_ is
provided as a convenience that uses the original request and response
objects for the async processing. Please note users of this method
SHOULD flush the response if they are wrapped before calling this method
if you wish, to ensure that any data written to the wrapped response
isn’t lost.

[#50626601_pgfId-1001392]## _public AsyncContext getAsyncContext()_ -
returns the _AsyncContext_ that was created or re initialized by the
invocation of _startAsync_ . It is illegal to call _getAsyncContext_ if
the request has not been put in asynchronous mode.

[#50626601_pgfId-1001366]## _public boolean isAsyncSupported()_ -
Returns _true_ if the request supports async processing, and _false_
otherwise. Async support will be disabled as soon as the request has
passed a filter or servlet that does not support async processing
(either via the designated annotation or declaratively).

[#50626601_pgfId-1001367]## _public boolean isAsyncStarted()_ - Returns
_true_ if async processing has started on this request, and _false_
otherwise. If this request has been dispatched using one of the
_AsyncContext.dispatch_ methods since it was put in asynchronous mode,
or a call to _AsynContext.complete_ is made, this method returns _false_
.

[#50626601_pgfId-1010491]## _public DispatcherType getDispatcherType()_
- Returns the dispatcher type of a request. The dispatcher type of a
request is used by the container to select the filters that need to be
applied to the request. Only filters with the matching dispatcher type
and url patterns will be applied. Allowing a filter that has been
configured for multiple dispatcher types to query a request for it’s
dispatcher type allows the filter to process the request differently
depending on it’s dispatcher type. The initial dispatcher type of a
request is defined as _DispatcherType.REQUEST_ . The dispatcher type of
a request dispatched via _RequestDispatcher.forward(ServletRequest,
ServletResponse)_ or _RequestDispatcher.include(ServletRequest,
ServletResponse)_ is given as _DispatcherType.FORWARD_ or
_DispatcherType.INCLUDE_ respectively, while a dispatcher type of an
asynchronous request dispatched via one of the _AsyncContext.dispatch_
methods is given as _DispatcherType.ASYNC_ . Finally the dispatcher type
of a request dispatched to an error page by the container’s error
handling mechanism is given as _DispatcherType.ERROR_ .

======= [#50626601_pgfId-1010493]## _AsyncContext_ [#50626601_73767]##

[#50626601_pgfId-1010494]##This class represents the execution context
for the asynchronous operation that was started on the _ServletRequest_
. An _AsyncContext_ is created and initialized by a call to
_ServletRequest.startAsync_ as described above. The following methods
are in the _AsyncContext_ :

[#50626601_pgfId-1001488]## _public ServletRequest getRequest()_ -
returns the request that was used to initialize the _AsyncContext_ by
calling one of the _startAsync_ methods. Calling _getRequest_ when
complete or any of the dispatch methods has been previously called in
the asynchronous cycle will result in an _IllegalStateException_ .

[#50626601_pgfId-1006736]## _public ServletResponse getResponse()_ -
returns the response that was used to initialize the _AsyncContext_ by
calling one of the _startAsync_ methods. Calling _getResponse_ when
complete or any of the dispatch methods has been previously called in
the asynchronous cycle will result in an _IllegalStateException_ .

[#50626601_pgfId-1006611]## _public void setTimeout(long
timeoutMilliseconds)_ - Sets the time out for the asynchronous
processing to occur in milliseconds. A call to this method overrides the
time out set by the container. If the time out is not specified via the
call to _setTimeout_ , 30000 is used as the default. A value of 0 or
less indicates that the asynchronous operation will never time out. The
time out applies to the _AsyncContext_ once the container-initiated
dispatch during which one of the _ServletRequest.startAsync_ methods was
called has returned to the container. It is illegal to set the time out
if this method is called after the container-initiated dispatch on which
the asynchronous cycle was started has returned to the container and
will result in an _IllegalStateException_ .

[#50626601_pgfId-1004289]## _public long getTimeout()_ - Gets the time
out, in milliseconds, associated with the _AsyncContext_ . This method
returns the container’s default time out, or the time out value set via
the most recent invocation of _setTimeout_ method.

[#50626601_pgfId-1006197]## _public void addListener(AsyncListener
listener, ServletRequest req, ServletResponse res)_ - Registers the
given listener for notifications of _onTimeout, onError, onComplete or
onStartAsync. The first three are a_ ssociated with the most recent
asynchronous cycle started by calling one of the
_ServletRequest.startAsync_ methods. _The onStartAsync is associated to
a new asynchronous cycle via one of the ServletRequest.startAsync_
methods. Async listeners will be notified in the order in which they
were added to the request. The request and response objects passed in to
the method are the exact same ones that are available from the
_AsyncEvent.getSuppliedRequest()_ and _AsyncEvent.getSuppliedResponse()_
when the _AsyncListener_ is notified. These objects should not be read
from or written to, because additional wrapping may have occurred since
the given _AsyncListener_ was registered, but may be used in order to
release any resources associated with them. It is illegal to call this
method after the container-initiated dispatch on which the asynchronous
cycle was started has returned to the container and before a new
asynchronous cycle was started and will result in an
_IllegalStateException_ .

[#50626601_pgfId-1004959]## _public <T extends AsyncListener>
createListener(Class<T> clazz)_ -Instantiates the given _AsyncListener_
class. The returned _AsyncListener_ instance may be further customized
before it is registered with the _AsyncContext_ via a call to one of the
_addListener_ methods specified below. The given _AsyncListener_ class
MUST define a zero argument constructor, which is used to instantiate
it. This method supports any annotations applicable to the
_AsyncListener_ .

[#50626601_pgfId-1004451]## _public void addListener(AsyncListener)_ -
Registers the given listener for notifications of _onTimeout, onError,
onComplete or onStartAsync._ The first three are associated with the
most recent asynchronous cycle started by calling one of the
_ServletRequest.startAsync_ methods. _The onStartAsync is associated to
a new asynchronous cycle via one of the ServletRequest.startAsync_
methods. If _startAsync(req, res)_ or _startAsync()_ is called on the
request, the exact same request and response objects are available from
the _AsyncEvent_ when the _AsyncListener_ is notified. The request and
response may or may not be wrapped. Async listeners will be notified in
the order in which they were added to the request. It is illegal to call
this method after the container-initiated dispatch on which the
asynchronous cycle was started has returned to the container and before
a new asynchronous cycle was started and will result in an
_IllegalStateException_ .

[#50626601_pgfId-1004266]## _public void dispatch(String path)_ -
Dispatches the re quest and response that were used to initialize the
_AsyncContext_ to the resource with the given path. The given path is
interpreted as relative to the _ServletContext_ that initialized the
_AsyncContext_ . All path related query methods of the request MUST
reflect the dispatch target, while the original request URI, context
path, path info and query string may be obtained from the request
attributes as defined in link:servlet.htm#50626608_87221[See Dispatched
Request Parameters]. These attributes MUST always reflect the original
path elements, even after multiple dispatches.

[#50626601_pgfId-1003718]## _public void dispatch()_ - Provided as a
convenience to dispatch the request and response used to initialize the
_AsyncContext_ as follows. If the _AsyncContext_ was initialized via the
_startAsync(ServletRequest, ServletResponse)_ and the request passed is
an instance of _HttpServletRequest_ , then the dispatch is to the URI
returned by _HttpServletRequest.getRequestURI()_ . Otherwise the
dispatch is to the URI of the request when it was last dispatched by the
container. The examples link:servlet.htm#50626601_56216[See] ,
link:servlet.htm#50626601_50311[See] and
link:servlet.htm#50626601_82887[See] shown below demonstrate what the
target URI of dispatch would be in the different cases.

[#50626601_pgfId-1003657]##[#50626601_56216]## 

[width="100%",cols="100%",]
|===
|[#50626601_pgfId-1003650]##// REQUEST to /url/A
|[#50626601_pgfId-1003652]##AsyncContext ac = request.startAsync();
|[#50626601_pgfId-1003654]##...
|[#50626601_pgfId-1003656]##ac.dispatch(); // ASYNC dispatch to /url/A
|===

[#50626601_pgfId-1003359]##[#50626601_50311]## 

[width="100%",cols="100%",]
|===
|[#50626601_pgfId-1005425]##// REQUEST to /url/A

|[#50626601_pgfId-1005427]##// FORWARD to /url/B

|[#50626601_pgfId-1005429]##request.getRequestDispatcher(“/url/B”).forward(request,
response);

|[#50626601_pgfId-1005435]##// Start async operation from within the
target of the FORWARD

|[#50626601_pgfId-1005431]##AsyncContext ac = request.startAsync();

|[#50626601_pgfId-1005433]##ac.dispatch(); // ASYNC dispatch to /url/A
|===

[#50626601_pgfId-1003399]##[#50626601_82887]## 

[width="100%",cols="100%",]
|===
|[#50626601_pgfId-1003390]##// REQUEST to /url/A

|[#50626601_pgfId-1003392]##// FORWARD to /url/B

|[#50626601_pgfId-1003394]##request.getRequestDispatcher(“/url/B”).forward(request,
response);

|[#50626601_pgfId-1005526]##// Start async operation from within the
target of the FORWARD

|[#50626601_pgfId-1003396]##AsyncContext ac =
request.startAsync(request, response);

|[#50626601_pgfId-1003398]##ac.dispatch(); // ASYNC dispatch to /url/B
|===

[#50626601_pgfId-1001842]## _public void dispatch(ServletContext
context, String path)_ - dispatches the request and response used to
initialize the _AsyncContext_ to the resource with the given path in the
given _ServletContext_ .

[#50626601_pgfId-1010237]##For all the 3 variations of the _dispatch_
methods defined above, calls to the methods returns immediately after
passing the request and response objects to a container managed thread,
on which the dispatch operation will be performed. The dispatcher type
of the request is set to _ASYNC_ . Unlike
_RequestDispatcher.forward(ServletRequest, ServletResponse)_ dispatches,
the response buffer and headers will not be reset, and it is legal to
dispatch even if the response has already been committed. Control over
the request and response is delegated to the dispatch target, and the
response will be closed when the dispatch target has completed
execution, unless _ServletRequest.startAsync()_ or
_ServletRequest.startAsync(ServletRequest, ServletResponse)_ is called.
If any of the dispatch methods are called before the container-initiated
dispatch that called _startAsync_ has returned to the container, the
following conditions must hold during that time between the invocation
of _dispatch_ and the return of control to the container:

[#50626601_pgfId-1010229]##any _dispatch_ invocations invoked during
that time will not take effect until after the container-initiated
dispatch has returned to the container.

[#50626601_pgfId-1010296]##any _AsyncListener.onComplete(AsyncEvent),
AsyncListener.onTimeout(AsyncEvent)_ and
_AsyncListener.onError(AsyncEvent)_ invocations will also be delayed
until after the container-initiated dispatch has returned to the
container.

[#50626601_pgfId-1010335]##any calls to _request.isAsyncStarted()_ must
return _true_ until after the container-initiated dispatch has returned
to the container.

[#50626601_pgfId-1010468]##There can be at most one asynchronous
dispatch operation per asynchronous cycle, which is started by a call to
one of the _ServletRequest.startAsync_ methods. Any attempt to perform
additional asynchronous dispatch operation within the same asynchronous
cycle is illegal and will result in an _IllegalStateException_ . If
_startAsync_ is subsequently called on the dispatched request, then any
of the _dispatch_ methods may be called with the same restriction as
above.

[#50626601_pgfId-1004866]##[#50626601_25183]##Any errors or exceptions
that may occur during the execution of the _dispatch_ methods MUST be
caught and handled by the container as follows:

[#50626601_pgfId-1004843]##invoke the
_AsyncListener.onError(AsyncEvent)_ method for all instances of the
_AsyncListener_ registered with the _ServletRequest_ for which the
_AsyncContext_ was created and make the _Throwable_ available via the
_AsyncEvent.getThrowable()_ .

[#50626601_pgfId-1004884]##If none of the listeners called
_AsyncContext.complete_ or any of the _AsyncContext.dispatch_ methods,
then perform an error dispatch with a status code equal to
_HttpServletResponse.SC_INTERNAL_SERVER_ERROR_ and make the _Throwable_
available as the value of the _RequestDispatcher.ERROR_EXCEPTION_
request attribute.

[#50626601_pgfId-1004887]##If no matching error page is found, or the
error page does not call _AsyncContext.complete()_ or any of the
_AsyncContext.dispatch_ methods, then the container MUST call
_AsyncContext.complete_ .

[#50626601_pgfId-1004388]## _public boolean
hasOriginalRequestAndResponse()_ - This method checks if the
_AsyncContext_ was initialized with the original request and response
objects by calling _ServletRequest.startAsync()_ or if it was
initialized by calling _ServletRequest.startAsync(ServletRequest,
ServletResponse)_ and neither the _ServletRequest_ nor the
_ServletResponse_ argument carried any application provided wrappers, in
which case it returns _true_ . If the _AsyncContext_ was initialized
with wrapped request and/or response objects using
_ServletRequest.startAsync(ServletRequest, ServletResponse)_ , it
returns _false_ . This information may be used by filters invoked in the
outbound direction, after a request was put into asynchronous mode, to
determine whether any request and/or response wrappers that they added
during their inbound invocation need to be preserved for the duration of
the asynchronous operation or may be released.

[#50626601_pgfId-1005275]## _public void start(Runnable r)_ - This
method causes the container to dispatch a thread, possibly from a
managed thread pool, to run the specified _Runnable_ . The container may
propagate appropriate contextual information to the _Runnable_ .

[#50626601_pgfId-1001531]## _public void complete()_ - If
_request.startAsync_ is called then this method MUST be called to
complete the async processing and commit and close the response. The
_complete_ method can be invoked by the container if the request is
dispatched to a servlet that does not support async processing, or the
target servlet called by _AsyncContext.dispatch_ does not do a
subsequent call to _startAsync_ . In this case, it is the container's
responsibility to call _complete()_ as soon as that servlet's _service_
method is exited. An _IllegalStateException_ MUST be thrown if
_startAsync_ was not called. It is legal to call this method anytime
after a call to _ServletRequest.startAsync()_ or
_ServletRequest.startAsync(ServletRequest, ServletResponse)_ and before
a call to one of the dispatch methods. If this method is called before
the container-initiated dispatch that called _startAsync_ has returned
to the container, the following conditions must hold during that time
between the invocation of _complete_ and the return of control to the
container:

[#50626601_pgfId-1009821]##the behavior specified for _complete_ will
not take effect until after the container-initiated dispatch has
returned to the container.

[#50626601_pgfId-1010079]##any _AsyncListener.onComplete(AsyncEvent)_
invocations will also be delayed until after the container-initiated
dispatch has returned to the container.

[#50626601_pgfId-1010080]##any calls to _request.isAsyncStarted()_ must
return _true_ until after the container-initiated dispatch has returned
to the container.

======= [#50626601_pgfId-1010012]## _ServletRequestWrapper_

[#50626601_pgfId-1002015]## _public boolean isWrapperFor(ServletRequest
req)_ - Checks recursively if this wrapper wraps the given
_ServletRequest_ and returns _true_ if it does, else it returns _false_

======= [#50626601_pgfId-1002033]## _ServletResponseWrapper_

[#50626601_pgfId-1002034]## _public boolean isWrapperFor(ServletResponse
res)_ - Checks recursively if this wrapper wraps the given
_ServletResponse_ and returns _true_ if it does, else it returns _false_
.

======= [#50626601_pgfId-1003150]## _AsyncListener_

[#50626601_pgfId-1003171]## _public void onComplete(AsyncEvent event)_ -
Is used to notify the listener of completion of the asynchronous
operation started on the _ServletRequest_ .

[#50626601_pgfId-1003184]## _public void onTimeout(AsyncEvent event)_ -
Is used to notify the listener of a time out of the asynchronous
operation started on the _ServletRequest_ .

[#50626601_pgfId-1003461]## _public void onError(AsyncEvent event)_ - Is
used to notify the listener that the asynchronous operation has failed
to complete.

[#50626601_pgfId-1004824]## _public void onStartAsync(AsyncEvent event)_
- Is used to notify the listener that a new asynchronous cycle is being
initiated via a call to one of the _ServletRequest.startAsync_ methods.
The _AsyncContext_ corresponding to the asynchronous operation that is
being reinitialized may be obtained by calling
_AsyncEvent.getAsyncContext_ on the given event.

[#50626601_pgfId-1003185]##[#50626601_20745]##In the event that an
asynchronous operation times out, the container must run through the
following steps:

[#50626601_pgfId-1004173]##Invoke the _AsyncListener.onTimeout_ method
on all the _AsyncListener_ instances registered with the
_ServletRequest_ on which the asynchronous operation was initiated.

[#50626601_pgfId-1004177]##If none of the listeners called
_AsyncContext.complete()_ or any of the _AsyncContext.dispatch_ methods,
perform an error dispatch with a status code equal to
_HttpServletResponse.SC_INTERNAL_SERVER_ERROR_ .

[#50626601_pgfId-1004178]##If no matching error page was found, or the
error page did not call _AsyncContext.complete()_ or any of the
_AsyncContext.dispatch_ methods, the container MUST call
_AsyncContext.complete()_ .

[#50626601_pgfId-1002047]##If an exception is thrown while invoking
methods in an _AsyncListener_ , it is logged and will not affect the
invocation of any other _AsyncListeners_ .

[#50626601_pgfId-1008136]##Async processing in JSP would not be
supported by default as it is used for content generation and async
processing would have to be done before the content generation. It is up
to the container how to handle this case. Once all the async activities
are done, a dispatch to the JSP page using the _AsyncContext.dispatch_
can be used for generating content.

[#50626601_pgfId-1004609]##Figure 2-1 shown below is a diagram depicting
the state transitions for various asynchronous operations.

[#50626601_pgfId-1004582]## 

======= [#50626601_pgfId-1004046]##State transition diagram for asynchronous operations

image:servlet-12.gif[image]

[#50626601_pgfId-1004054]## 

====== [#50626601_pgfId-1004048]##Thread Safety

[#50626601_pgfId-1002050]##Other than the _startAsync_ and _complete_
methods, implementations of the request and response objects are not
guaranteed to be thread safe. This means that they should either only be
used within the scope of the request handling thread or the application
must ensure that access to the request and response objects are thread
safe.

[#50626601_pgfId-1008450]##If a thread created by the application uses
the container-managed objects, such as the request or response object,
those objects must be accessed only within the object’s life cycle as
defined in sections link:servlet.htm#50626597_82071[See Lifetime of the
Request Object] and link:servlet.htm#50626600_68517[See Lifetime of the
Response Object] respectively. Be aware that other than the _startAsync_
, and _complete_ methods, the request and response objects are not
thread safe. If those objects were accessed in the multiple threads, the
access should be synchronized or be done through a wrapper to add the
thread safety, for instance, synchronizing the call of the methods to
access the request attribute, or using a local output stream for the
response object within a thread.

====== [#50626601_pgfId-1006826]##[#50626601_49366]##Upgrade Processing

[#50626601_pgfId-1006861]##In HTTP/1.1, the Upgrade general-header
allows the client to specify the additional communication protocols that
it supports and would like to use. If the server finds it appropriate to
switch protocols, then new protocols will be used in subsequent
communication.

[#50626601_pgfId-1006863]##The servlet container provides an HTTP
upgrade mechanism. However the servlet container itself does not have
knowledge about the upgraded protocol. The protocol processing is
encapsulated in the _HttpUpgradeHandler_ . Data reading or writing
between the servlet container and the _HttpUpgradeHandler_ is in byte
streams.

[#50626601_pgfId-1006865]##When an upgrade request is received, the
servlet can invoke the _HttpServletRequest.upgrade_ method, which starts
the upgrade process. This method instantiates the given
_HttpUpgradeHandler_ class. The returned _HttpUpgradeHandler_ instance
may be further customized. The application prepares and sends an
appropriate response to the client. After exiting the _service_ method
of the servlet, the servlet container completes the processing of all
filters and marks the connection to be handled by the
_HttpUpgradeHandler_ . It then calls the _HttpUpgradeHandler_ 's _init_
method, passing a _WebConnection_ to allow the protocol handler access
to the data streams.

[#50626601_pgfId-1006867]##The servlet filters only process the initial
HTTP request and response. They are not involved in subsequent
communications. In other words, they are not invoked once the request
has been upgraded.

[#50626601_pgfId-1008718]##The _HttpUpgradeHandler_ may use non blocking
IO to consume and produce messages.

[#50626601_pgfId-1008719]##The Developer has the responsibility for
thread safe access to the _ServletInputStream_ and _ServletOutputStream_
while processing HTTP upgrade.

[#50626601_pgfId-1007776]##When the upgrade processing is done,
_HttpUpgradeHandler.destroy_ will be invoked.

===== [#50626601_pgfId-1007759]##End of Service

[#50626601_pgfId-999534]##The servlet container is not required to keep
a servlet loaded for any particular period of time. A servlet instance
may be kept active in a servlet container for a period of milliseconds,
for the lifetime of the servlet container (which could be a number of
days, months, or years), or any amount of time in between.

[#50626601_pgfId-999535]##When the servlet container determines that a
servlet should be removed from service, it calls the _destroy_ method of
the _Servlet_ interface to allow the servlet to release any resources it
is using and save any persistent state. For example, the container may
do this when it wants to conserve memory resources, or when it is being
shut down.

[#50626601_pgfId-999536]##Before the servlet container calls the
_destroy_ method, it must allow any threads that are currently running
in the _service_ method of the servlet to complete execution, or exceed
a server-defined time limit.

[#50626601_pgfId-999537]##Once the _destroy_ method is called on a
servlet instance, the container may not route other requests to that
instance of the servlet. If the container needs to enable the servlet
again, it must do so with a new instance of the servlet’s class.

[#50626601_pgfId-999538]##After the _destroy_ method completes, the
servlet container must release the servlet instance so that it is
eligible for garbage collection.

[#50626601_pgfId-999460]## 

== [#50626597_pgfId-1010230]## 

=== [#50626597_pgfId-1010231]##

image:servlet-13.gif[image]

The Request

image:servlet-14.gif[image]

[#50626597_pgfId-999463]##The request object encapsulates all
information from the client request. In the HTTP protocol, this
information is transmitted from the client to the server in the HTTP
headers and the message body of the request.

==== [#50626597_pgfId-999464]##

image:servlet-15.gif[image]

HTTP Protocol Parameters

[#50626597_pgfId-999465]##Request parameters for the servlet are the
strings sent by the client to a servlet container as part of its
request. When the request is an _HttpServletRequest_ object, and
conditions set out in link:servlet.htm#50626597_18477[See When
Parameters Are Available] are met, the container populates the
parameters from the URI query string and POST-ed data.

[#50626597_pgfId-999469]##The parameters are stored as a set of
name-value pairs. Multiple parameter values can exist for any given
parameter name. The following methods of the _ServletRequest_ interface
are available to access parameters:

[#50626597_pgfId-999470]## _getParameter_

[#50626597_pgfId-999471]## _getParameterNames_

[#50626597_pgfId-999472]## _getParameterValues_

[#50626597_pgfId-999473]## _getParameterMap_

[#50626597_pgfId-999474]##The _getParameterValues_ method returns an
array of _String_ objects containing all the parameter values associated
with a parameter name. The value returned from the _getParameter_ method
must be the first value in the array of _String_ objects returned by
_getParameterValues_ . The _getParameterMap_ method returns a
_java.util.Map_ of the parameter of the request, which contains names as
keys and parameter values as map values.

[#50626597_pgfId-999475]##Data from the query string and the post body
are aggregated into the request parameter set. Query string data is
presented before post body data. For example, if a request is made with
a query string of _a=hello_ and a post body of _a=goodbye&a=world_ , the
resulting parameter set would be ordered _a=(hello, goodbye, world)_ .

[#50626597_pgfId-999476]##Path parameters that are part of a GET request
(as defined by HTTP 1.1) are not exposed by these APIs. They must be
parsed from the _String_ values returned by the _getRequestURI_ method
or the _getPathInfo_ method.

===== [#50626597_pgfId-999478]##[#50626597_18477]##When Parameters Are Available

[#50626597_pgfId-999479]##The following are the conditions that must be
met before post form data will be populated to the parameter set:

[#50626597_pgfId-999480]##The request is an HTTP or HTTPS request.

[#50626597_pgfId-999481]##The HTTP method is POST.

[#50626597_pgfId-999482]##The content type is
_application/x-www-form-urlencoded_ .

[#50626597_pgfId-999483]##The servlet has made an initial call of any of
the _getParameter_ family of methods on the request object.

[#50626597_pgfId-999484]##If the conditions are not met and the post
form data is not included in the parameter set, the post data must still
be available to the servlet via the request object’s input stream. If
the conditions are met, post form data will no longer be available for
reading directly from the request object’s input stream.

==== [#50626597_pgfId-999485]##

image:servlet-15.gif[image]

[#50626597_23510]##File upload

[#50626597_pgfId-1003552]##Servlet container allows files to be uploaded
when data is sent as _multipart/form-data_ .

[#50626597_pgfId-1003669]##The servlet container provides
_multipart/form-data_ processing if any one of the following conditions
is met.

[#50626597_pgfId-1003553]##The servlet handling the request is annotated
with the _@MultipartConfig_ as defined in
link:servlet.htm#50626585_71574[See @MultipartConfig].

[#50626597_pgfId-1003557]##Deployment descriptors contain a
_multipart-config_ element for the servlet handling the request.

[#50626597_pgfId-1002736]##How data in a request of type
_multipart/form-data_ is made available depends on whether the servlet
container provides _multipart/form-data_ processing:

[#50626597_pgfId-1002737]##If the servlet container provides
_multipart/form-data_ processing, the data is made available through the
following methods in _HttpServletRequest_ :

[#50626597_pgfId-1002869]## _public Collection<Part> getParts()_

[#50626597_pgfId-1002870]## _public Part getPart(String name)_

[#50626597_pgfId-1002882]##Each part provides access to the headers,
content type related with it and the content via the
_Part.getInputStream_ method.

[#50626597_pgfId-1002883]##For parts with _form-data_ as the
_Content-Disposition_ , but without a filename, the string value of the
part will also be available through the _getParameter_ and
_getParameterValues_ methods on _HttpServletRequest_ , using the name of
the part.

[#50626597_pgfId-1003319]##If the servlet container does not provide the
_multi-part/form-data_ processing, the data will be available through
the _HttpServletReuqest.getInputStream_ .

==== [#50626597_pgfId-1000957]##

image:servlet-15.gif[image]

Attributes

[#50626597_pgfId-999486]##Attributes are objects associated with a
request. Attributes may be set by the container to express information
that otherwise could not be expressed via the API, or may be set by a
servlet to communicate information to another servlet (via the
_RequestDispatcher_ ). Attributes are accessed with the following
methods of the _ServletRequest_ interface:

[#50626597_pgfId-999487]## _getAttribute_

[#50626597_pgfId-999488]## _getAttributeNames_

[#50626597_pgfId-999489]## _setAttribute_

[#50626597_pgfId-999490]##Only one attribute value may be associated
with an attribute name.

[#50626597_pgfId-999491]##Attribute names beginning with the prefixes of
_java._ and _javax._ are reserved for definition by this specification.
Similarly, attribute names beginning with the prefixes of _sun._ ,
_com.sun., oracle and com.oracle_ are reserved for definition by Oracle
Corporation. It is suggested that all attributes placed in the attribute
set be named in accordance with the reverse domain name convention
suggested by the Java Programming Language
Specificationlink:#pgfId-999494[4] for package naming.

==== [#50626597_pgfId-999495]##

image:servlet-15.gif[image]

Headers

[#50626597_pgfId-999496]##A servlet can access the headers of an HTTP
request through the following methods of the _HttpServletRequest_
interface:

[#50626597_pgfId-999497]## _getHeader_

[#50626597_pgfId-999498]## _getHeaders_

[#50626597_pgfId-999499]## _getHeaderNames_

[#50626597_pgfId-999500]##The _getHeader_ method returns a header given
the name of the header. There can be multiple headers with the same
name, e.g. _Cache-Control_ headers, in an HTTP request. If there are
multiple headers with the same name, the _getHeader_ method returns the
first header in the request. The _getHeaders_ method allows access to
all the header values associated with a particular header name,
returning an _Enumeration_ of _String_ objects.

[#50626597_pgfId-999501]##Headers may contain _String_ representations
of _int_ or _Date_ data. The following convenience methods of the
_HttpServletRequest_ interface provide access to header data in a one of
these formats:

[#50626597_pgfId-999502]## _getIntHeader_

[#50626597_pgfId-999503]## _getDateHeader_

[#50626597_pgfId-999504]##If the _getIntHeader_ method cannot translate
the header value to an _int_ , a _NumberFormatException_ is thrown. If
the _getDateHeader_ method cannot translate the header to a _Date_
object, an _IllegalArgumentException_ is thrown.

==== [#50626597_pgfId-999505]##

image:servlet-15.gif[image]

Request Path Elements

[#50626597_pgfId-999506]##The request path that leads to a servlet
servicing a request is composed of many important sections. The
following elements are obtained from the request URI path and exposed
via the request object:

[#50626597_pgfId-999507]## _Context Path:_ The path prefix associated
with the _ServletContext_ that this servlet is a part of. If this
context is the “default” context rooted at the base of the Web server’s
URL name space, this path will be an empty string. Otherwise, if the
context is not rooted at the root of the server’s name space, the path
starts with a _/_ character but does not end with a _/_ character.

[#50626597_pgfId-999508]## _Servlet Path:_ The path section that
directly corresponds to the mapping which activated this request. This
path starts with a ’ _/_ ’ character except in the case where the
request is matched with the ‘ _/*_ ’ or ““ pattern, in which case it is
an empty string.

[#50626597_pgfId-999509]## _PathInfo:_ The part of the request path that
is not part of the Context Path or the Servlet Path. It is either null
if there is no extra path, or is a string with a leading ‘/’.

[#50626597_pgfId-999510]##The following methods exist in the
_HttpServletRequest_ interface to access this information:

[#50626597_pgfId-999511]## _getContextPath_

[#50626597_pgfId-999512]## _getServletPath_

[#50626597_pgfId-999513]## _getPathInfo_

[#50626597_pgfId-999514]##It is important to note that, except for URL
encoding differences between the request URI and the path parts, the
following equation is always true:

[#50626597_pgfId-999515]##requestURI = contextPath + servletPath +
pathInfo

[#50626597_pgfId-999540]##To give a few examples to clarify the above
points, consider the following:

======= [#50626597_pgfId-999764]##Example Context Set Up

[#50626597_pgfId-999791]##Context Path

[#50626597_pgfId-999793]##/catalog

[#50626597_pgfId-999795]##Servlet Mapping

[#50626597_pgfId-999797]##Pattern: /lawn/*

[#50626597_pgfId-999798]##Servlet: LawnServlet

[#50626597_pgfId-999800]##Servlet Mapping

[#50626597_pgfId-999802]##Pattern: /garden/*

[#50626597_pgfId-999803]##Servlet: GardenServlet

[#50626597_pgfId-999805]##Servlet Mapping

[#50626597_pgfId-999807]##Pattern: *.jsp

[#50626597_pgfId-999808]##Servlet: JSPServlet

[#50626597_pgfId-999568]##The following behavior is observed:

== [#50626597_pgfId-999816]##Observed Path Element Behavior

[#50626597_pgfId-999843]##Request Path

[#50626597_pgfId-999845]##Path Elements

[#50626597_pgfId-999847]## _/catalog/lawn/index.html_

[#50626597_pgfId-999849]## _ContextPath: /catalog_

[#50626597_pgfId-999850]## _ServletPath: /lawn_

[#50626597_pgfId-999851]## _PathInfo: /index.html_

[#50626597_pgfId-999853]## _/catalog/garden/implements/_

[#50626597_pgfId-999855]## _ContextPath: /catalog_

[#50626597_pgfId-999856]## _ServletPath: /garden_

[#50626597_pgfId-999857]## _PathInfo: /implements/_

[#50626597_pgfId-999859]## _/catalog/help/feedback.jsp_

[#50626597_pgfId-999861]## _ContextPath: /catalog_

[#50626597_pgfId-999862]## _ServletPath: /help/feedback.jsp_

[#50626597_pgfId-999863]## _PathInfo: null_

==== [#50626597_pgfId-999569]##

image:servlet-15.gif[image]

Path Translation Methods

[#50626597_pgfId-999570]##There are two convenience methods in the API
which allow the Developer to obtain the file system path equivalent to a
particular path. These methods are:

[#50626597_pgfId-999571]## _ServletContext.getRealPath_

[#50626597_pgfId-999572]## _HttpServletRequest.getPathTranslated_

[#50626597_pgfId-999573]##The _getRealPath_ method takes a _String_
argument and returns a _String_ representation of a file on the local
file system to which a path corresponds. The _getPathTranslated_ method
computes the real path of the _pathInfo_ of the request.

[#50626597_pgfId-1001694]##In situations where the servlet container
cannot determine a valid file path for these methods, such as when the
Web application is executed from an archive, on a remote file system not
accessible locally, or in a database, these methods must return null.
Resources inside the _META-INF/resources_ directory of JAR file must be
considered only if the container has unpacked them from their containing
JAR file when a call to _getRealPath()_ is made, and in this case MUST
return the unpacked location.

==== [#50626597_pgfId-1001696]##

image:servlet-15.gif[image]

[#50626597_non-blocking-io-request]##Non Blocking IO

[#50626597_pgfId-1005044]##Non-blocking request processing in the Web
Container helps improve the ever increasing demand for improved Web
Container scalability, increase the number of connections that can
simultaneously be handled by the Web Container. Non-blocking IO in the
Servlet container allows developers to read data as it becomes available
or write data when possible to do so. Non-blocking IO only works with
async request processing in Servlets and Filters (as defined in
link:servlet.htm#50626601_53655[See Asynchronous processing]), and
upgrade processing (as defined in link:servlet.htm#50626601_49366[See
Upgrade Processing]). Otherwise, an _IllegalStateException_ must be
thrown when _ServletInputStream.setReadListener_ or
_ServletOutputStream.setWriteListener_ is invoked.

[#50626597_pgfId-1005045]##The _ReadListener_ provides the following
callback methods for non blocking IO -

[#50626597_pgfId-1001631]## _ReadListener_

[#50626597_pgfId-1004677]## _onDataAvailable()_ . The _onDataAvailable_
method is invoked on the _ReadListener_ when data is available to read
from the incoming request stream. The container will invoke the method
the first time when data is available to read. The container will
subsequently invoke the _onDataAvailable_ method if and only if the
_isReady_ method on _ServletInputStream_ , described below, has been
called and returned a value of _false_ and data has subsequently become
available to read.

[#50626597_pgfId-1004678]## _onAllDataRead()_ . The _onAllDataRead_
method is invoked when you have finished reading all the data for the
_ServletRequest_ for which the listener was registered.

[#50626597_pgfId-1005900]## _onError(Throwable t)_ . The _onError_
method is invoked if there is any error or exception that occurs while
processing the request.

[#50626597_pgfId-1005901]##The Servlet container must access methods in
_ReadListener_ in a thread safe manner.

[#50626597_pgfId-1005902]##In addition to the _ReadListener_ defined
above, the following methods have been added to _ServletInputStream_
class -

[#50626597_pgfId-1002038]## _ServletInputStream_

[#50626597_pgfId-1001638]## _boolean isFinished()._ The _isFinished_
method returns _true_ when all the data for the request associated with
the _ServletInputStream_ has been read. Otherwise it returns _false_ .

[#50626597_pgfId-1001639]## _boolean isReady()._ The _isReady_ method
returns _true_ if data can be read without blocking. If no data can be
read without blocking it returns _false_ . If isReady returns false it
is illegal to call the read method and an _IllegalStateException_ MUST
be thrown.

[#50626597_pgfId-1004094]## _void setReadListener(ReadListener_
_listener)_ . Sets the _ReadListener_ defined above to get invoked to
read data in a non-blocking fashion. Once the listener is associated for
the given _ServletInputStream_ , the container invokes the methods on
the _ReadListener_ when data is available to read, all the data has been
read or if there was an error processing the request. Registering a
_ReadListener_ will start non-blocking IO. It is illegal to switch to
the traditional blocking IO at that point and an _IllegalStateException_
MUST be thrown. A subsequent call to _setReadListener_ in the scope of
the current request is illegal and an _IllegalStateException_ MUST be
thrown.

==== [#50626597_pgfId-1006199]##

image:servlet-15.gif[image]

[#50626597_76986]##HTTP/2 Server Push

[#50626597_pgfId-1006222]##Server push is the most visible of the
improvements in HTTP/2 to appear in the servlet API. All of the new
features in HTTP/2, including server push, are aimed at improving the
perceived performance of the web browsing experience. Server push
derives its contribution to improved perceived browser performance from
the simple fact that servers are in a much better position than clients
to know what additional assets (such as images, stylesheets and scripts)
go along with initial requests. For example, it is possible for servers
to know that whenever a browser requests _index.html_ , it will shortly
thereafter request _header.gif_ , _footer.gif_ and _style.css_ . Since
servers know this, they can preemptively start sending the bytes of
these assets along side the bytes of the _index.html_ .

[#50626597_pgfId-1007273]##To use server push, obtain a reference to a
_PushBuilder_ from an _HttpServletRequest_ , mutate the builder as
desired, then call _push()_ . Please see the javadoc for method
_javax.servlet.http.HttpServletRequest.newPushBuilder()_ and class
_javax.servlet.http.PushBuilder_ for the normative specification. The
remainder of this section calls out implementation requirements with
respect to the section titled “Server Push” in the HTTP/2 specification
version referenced in link:servlet.htm#50626604_33785[See Other
Important References].

[#50626597_pgfId-1007912]##Unless explicitly excluded, Servlet 4.0
containers must support server push as specified in the HTTP/2
specification section “Server Push”. Containers must enable server push
if the client is capable of speaking HTTP/2, unless the client has
explicitly disabled server push by sending a SETTINGS_ENABLE_PUSH
setting value of 0 (zero) for the current connection. In that case, for
that connection only, server push must not be enabled.

[#50626597_pgfId-1008292]##In addition to allowing clients to disable
server push with the _SETTINGS_ENABLE_PUSH_ setting, servlet containers
must honor a client’s request to not receive a pushed response on a
finer grained basis by heeding the _CANCEL_ or _REFUSED_STREAM_ code
that references the pushed stream’s stream identifier. One common use of
this interaction is when a browser already has the resource in its
cache.

==== [#50626597_pgfId-1001616]##

image:servlet-15.gif[image]

Cookies

[#50626597_pgfId-999576]##The _HttpServletRequest_ interface provides
the _getCookies_ method to obtain an array of cookies that are present
in the request. These cookies are data sent from the client to the
server on every request that the client makes. Typically, the only
information that the client sends back as part of a cookie is the cookie
name and the cookie value. Other cookie attributes that can be set when
the cookie is sent to the browser, such as comments, are not typically
returned. The specification also allows for the cookies to be _HttpOnly_
cookies. _HttpOnly_ cookies indicate to the client that they should not
be exposed to client-side scripting code (It’s not filtered out unless
the client knows to look for this attribute). The use of _HttpOnly_
cookies helps mitigate certain kinds of cross-site scripting attacks.

==== [#50626597_pgfId-999577]##

image:servlet-15.gif[image]

SSL Attributes

[#50626597_pgfId-999578]##If a request has been transmitted over a
secure protocol, such as HTTPS, this information must be exposed via the
_isSecure_ method of the _ServletRequest_ interface. The Web container
must expose the following attributes to the servlet programmer:

======= [#50626597_pgfId-999876]##Protocol Attributes

[#50626597_pgfId-999907]##Attribute

[#50626597_pgfId-999909]##Attribute Name

[#50626597_pgfId-999911]##Java Type

[#50626597_pgfId-999913]##cipher suite

[#50626597_pgfId-999915]## _javax.servlet.request.cipher_suite_

[#50626597_pgfId-999917]## _String_

[#50626597_pgfId-999919]##bit size of the algorithm

[#50626597_pgfId-999921]## _javax.servlet.request.key_size_

[#50626597_pgfId-999923]## _Integer_

[#50626597_pgfId-1000714]##SSL session id

[#50626597_pgfId-1000716]##javax.servlet.request.ssl_session_id

[#50626597_pgfId-1000718]##String

[#50626597_pgfId-999604]##If there is an SSL certificate associated with
the request, it must be exposed by the servlet container to the servlet
programmer as an array of objects of type
_java.security.cert.X509Certificate_ and accessible via a
_ServletRequest_ attribute of _javax.servlet.request.X509Certificate_ .

[#50626597_pgfId-999605]##The order of this array is defined as being in
ascending order of trust. The first certificate in the chain is the one
set by the client, the next is the one used to authenticate the first,
and so on.

==== [#50626597_pgfId-999606]##

image:servlet-15.gif[image]

Internationalization

[#50626597_pgfId-999607]##Clients may optionally indicate to a Web
server what language they would prefer the response be given in. This
information can be communicated from the client using the
_Accept-Language_ header along with other mechanisms described in the
HTTP/1.1 specification. The following methods are provided in the
_ServletRequest_ interface to determine the preferred locale of the
sender:

[#50626597_pgfId-999608]## _getLocale_

[#50626597_pgfId-999609]## _getLocales_

[#50626597_pgfId-999610]##The _getLocale_ method will return the
preferred locale for which the client wants to accept content. See
section 14.4 of RFC 7231 (HTTP/1.1) for more information about how the
_Accept-Language_ header must be interpreted to determine the preferred
language of the client.

[#50626597_pgfId-999611]##The _getLocales_ method will return an
_Enumeration_ of _Locale_ objects indicating, in decreasing order
starting with the preferred locale, the locales that are acceptable to
the client.

[#50626597_pgfId-999612]##If no preferred locale is specified by the
client, the locale returned by the _getLocale_ method must be the
default locale for the servlet container and the _getLocales_ method
must contain an enumeration of a single _Locale_ element of the default
locale.

==== [#50626597_pgfId-999613]##

image:servlet-15.gif[image]

[#50626597_21428]##Request data encoding

[#50626597_pgfId-1009406]##Currently, many browsers do not send a char
encoding qualifier with the Content-Type header, leaving open the
determination of the character encoding for reading HTTP requests. In
the absence of a char encoding qualifier, if the _Content-Type_ is
_application/x-www-form-urlencoded_ , the default encoding the container
uses to create the request reader and parse POST data must be _US-ASCII_
. Any _%nn_ encoded values must be decoded to ISO-8859-1. For any other
_Content-Type_ , if none has been specified by the client request, web
application or container vendor specific configuration (for all web
applications in the container), the default encoding of a request the
container uses to create the request reader and parse POST data must be
ISO-8859-1. However, in order to indicate to the developer the absence
of a char encoding qualifier, the container must return _null_ from the
_getCharacterEncoding()_ method."

[#50626597_pgfId-999615]##If the client hasn’t set character encoding
and the request data is encoded with a different encoding than the
default as described above, breakage can occur. To remedy this
situation, _setRequestCharacterEncoding(String enc)_ is available on
_ServletContext_ , the _<request-character-encoding>_ element is
available in the _web.xml_ and _setCharacterEncoding(String enc)_ is
available on the _ServletRequest_ interface. Developers can override the
character encoding supplied by the container by calling this method. It
must be called prior to parsing any post data or reading any input from
the request. Calling this method once data has been read will not affect
the encoding.

==== [#50626597_pgfId-999617]##

image:servlet-15.gif[image]

[#50626597_82071]##Lifetime of the Request Object

[#50626597_pgfId-1001592]##Each request object is valid only within the
scope of a servlet’s _service_ method, or within the scope of a filter’s
_doFilter_ method, unless the asynchronous processing is enabled for the
component and the startAsync method is invoked on the request object. In
the case where asynchronous processing occurs, the request object
remains valid until _complete_ is invoked on the _AsyncContext_ .
Containers commonly recycle request objects in order to avoid the
performance overhead of request object creation. The developer must be
aware that maintaining references to request objects for which
_startAsync_ has not been called outside the scope described above is
not recommended as it may have indeterminate results.

[#50626597_pgfId-1005697]##In case of upgrade, the above is still true.

== [#50626599_pgfId-874]## 

[#50626599_pgfId-998874]## 

=== [#50626599_pgfId-1000838]##

image:servlet-16.gif[image]

[#50626599_56343]##Servlet Context

image:servlet-17.gif[image]

==== [#50626599_pgfId-1000839]##

image:servlet-18.gif[image]

Introduction to the ServletContext Interface

[#50626599_pgfId-999465]##The _ServletContext_ interface defines a
servlet’s view of the Web application within which the servlet is
running. The Container Provider is responsible for providing an
implementation of the _ServletContext_ interface in the servlet
container. Using the _ServletContext_ object, a servlet can log events,
obtain URL references to resources, and set and store attributes that
other servlets in the context can access.

[#50626599_pgfId-999466]##A _ServletContext_ is rooted at a known path
within a Web server. For example, a servlet context could be located at
_http://example.com/catalog_ . All requests that begin with the
_/catalog_ request path, known as the context path, are routed to the
Web application associated with the _ServletContext_ .

==== [#50626599_pgfId-999467]##

image:servlet-18.gif[image]

Scope of a ServletContext Interface

[#50626599_pgfId-999468]##There is one instance object of the
_ServletContext_ interface associated with each Web application deployed
into a container. In cases where the container is distributed over many
virtual machines, a Web application will have an instance of the
_ServletContext_ for each JVM.

[#50626599_pgfId-999469]##Servlets in a container that were not deployed
as part of a Web application are implicitly part of a “default” Web
application and have a default _ServletContext_ . In a distributed
container, the default _ServletContext_ is non-distributable and must
only exist in one JVM.

==== [#50626599_pgfId-999470]##

image:servlet-18.gif[image]

Initialization Parameters

[#50626599_pgfId-999471]##The following methods of the _ServletContext_
interface allow the servlet access to context initialization parameters
associated with a Web application as specified by the Application
Developer in the deployment descriptor:

[#50626599_pgfId-999472]## _getInitParameter_

[#50626599_pgfId-999473]## _getInitParameterNames_

[#50626599_pgfId-999474]##Initialization parameters are used by an
Application Developer to convey setup information. Typical examples are
a Webmaster’s e-mail address, or the name of a system that holds
critical data.

==== [#50626599_pgfId-999475]##

image:servlet-18.gif[image]

[#50626599_22463]##Configuration methods

[#50626599_pgfId-1000143]##The following methods are added to
_ServletContext_ since Servlet 3.0 to enable programmatic definition of
servlets, filters and the url pattern that they map to. These methods
can only be called during the initialization of the application either
from the _contexInitialized_ method of a _ServletContextListener_
implementation or from the _onStartup_ method of a
_ServletContainerInitializer_ implementation. In addition to adding
Servlets and Filters, one can also look up an instance of a
_Registration_ object corresponding to a Servlet or Filter or a map of
all the Registration objects for the Servlets or Filters. If the
_ServletContext_ passed to the ServletContextListener’s
_contextInitialized_ method where the _ServletContextListener_ was
neither declared in _web.xml_ or _web-fragment.xml_ nor annotated with
_@WebListener_ then an _UnsupportedOperationException_ MUST be thrown
for all the methods defined in _ServletContext_ for programmatic
configuration of servlets, filters and listeners.

===== [#50626599_pgfId-1000144]##[#50626599_43038]##Programmatically adding and configuring Servlets

[#50626599_pgfId-1000402]##The ability to programmatically add a servlet
to a context is useful for framework developers. For example a framework
could declare a controller servlet using this method. The return value
of this method is a _ServletRegistration_ or a
_ServletRegistration.Dynamic_ object which further allows you to setup
the other parameters of the servlet like _init-params_ , _url-mappings_
etc. There are three overloaded versions of the method as described
below.

====== [#50626599_pgfId-1000403]##addServlet(String servletName, String className)

[#50626599_pgfId-1000202]##This method allows the application to declare
a servlet programmatically. It adds the servlet with the given name, and
class name to the servlet context.

====== [#50626599_pgfId-1000203]##addServlet(String servletName, Servlet servlet)

[#50626599_pgfId-1000185]##This method allows the application to declare
a servlet programmatically. It adds the servlet with the given name, and
servlet instance to the servlet context.

====== [#50626599_pgfId-1000220]##addServlet(String servletName, Class <? extends Servlet> servletClass)

[#50626599_pgfId-1000218]##This method allows the application to declare
a servlet programmatically. It adds the servlet with the given name, and
an instance of the servlet class to the servlet context.

====== [#50626599_pgfId-1002421]##[#50626599_71088]##addJspFile(String servletName, String jspfile)

[#50626599_pgfId-1002475]##This method allows the application to declare
a jsp programmatically. It adds the jsp with the given name, and an
instance of the servlet class corresponding to the jsp file to the
servlet context.

====== [#50626599_pgfId-1000344]##<T extends Servlet> T createServlet(Class<T> clazz)

[#50626599_pgfId-1000348]##This method instantiates the given _Servlet_
class. The method must support all the annotations applicable to
Servlets except _@WebServlet_ . The returned _Servlet_ instance may be
further customized before it is registered with the _ServletContext_ via
a call to _addServlet(String, Servlet)_ as defined above.

====== [#50626599_pgfId-1000425]##ServletRegistration getServletRegistration(String servletName)

[#50626599_pgfId-1000429]##This method returns the _ServletRegistration_
corresponding to the servlet with the given _name_ , or _null_ if no
_ServletRegistration_ exists under that _name_ . An
_UnsupportedOperationException_ is thrown if the _ServletContext_ was
passed to the _contextInitialized_ method of a _ServletContextListener_
that was neither declared in the _web.xml_ or _web-fragment.xml_ , nor
annotated with _javax.servlet.annotation.WebListener._

====== [#50626599_pgfId-1000468]##[#50626599_75024]##Map<String, ? extends ServletRegistration> getServletRegistrations()

[#50626599_pgfId-1000479]##This method returns a map of
ServletRegistration objects, keyed by name corresponding to all servlets
registered with the ServletContext. If there are no servlets registered
with the ServletContext an empty map is returned. The returned Map
includes the ServletRegistration objects corresponding to all declared
and annotated servlets, as well as the ServletRegistration objects
corresponding to all servlets that have been added via one of the
_addServlet_ and _addJspFile_ methods. Any changes to the returned Map
MUST not affect the _ServletContext_ . An
_UnsupportedOperationException_ is thrown if the _ServletContext_ was
passed to the _contextInitialized_ method of a _ServletContextListener_
that was neither declared in the _web.xml_ or _web-fragment.xml_ , nor
annotated with _javax.servlet.annotation.WebListener._

===== [#50626599_pgfId-999924]##Programmatically adding and configuring Filters

====== [#50626599_pgfId-1000285]##addFilter(String filterName, String className)

[#50626599_pgfId-1000286]##This method allows the application to declare
a filter programmatically. It adds the filter with the given name, and
class name to the web application.

====== [#50626599_pgfId-1000287]##addFilter(String filterName, Filter filter)

[#50626599_pgfId-1000288]##This method allows the application to declare
a filter programmatically. It adds the filter with the given name, and
filter instance to the web application.

====== [#50626599_pgfId-1000289]##addFilter(String filterName, Class <? extends Filter> filterClass)

[#50626599_pgfId-1000290]##This method allows the application to declare
a filter programmatically. It adds the filter with the given name, and
an instance of the filter class to the web application.

====== [#50626599_pgfId-1000363]##<T extends Filter> T createFilter(Class<T> clazz)

[#50626599_pgfId-1000361]##This method instantiates the given _Filter_
class. The method must support all the annotations applicable to
Filters. The returned _Filter_ instance may be further customized before
it is registered with the _ServletContext_ via a call to
_addFilter(String, Filter)_ as defined above. The given _Filter_ class
must define a zero argument constructor, which is used to instantiate
it.

====== [#50626599_pgfId-1000496]##FilterRegistration getFilterRegistration(String filterName)

[#50626599_pgfId-1000497]##This method returns the _FilterRegistration_
corresponding to the filter with the given _name_ , or _null_ if no
_FilterRegistration_ exists under that _name_ . An
_UnsupportedOperationException_ is thrown if the _ServletContext_ was
passed to the _contextInitialized_ method of a _ServletContextListener_
that was neither declared in the _web.xml_ or _web-fragment.xml_ , nor
annotated with _javax.servlet.annotation.WebListener._

====== [#50626599_pgfId-1000498]##Map<String, ? extends FilterRegistration> getFilterRegistrations()

[#50626599_pgfId-1000982]##This method returns a map of
_FilterRegistration_ objects, keyed by name corresponding to all filters
registered with the _ServletContext_ . If there are no filters
registered with the _ServletContext_ an empty _Map_ is returned. The
returned _Map_ includes the _FilterRegistration_ objects corresponding
to all declared and annotated filters, as well as the
_FilterRegistration_ objects corresponding to all filters that have been
added via one of the _addFilter_ methods. Any changes to the returned
_Map_ MUST not affect the _ServletContext_ . An
_UnsupportedOperationException_ is thrown if the _ServletContext_ was
passed to the _contextInitialized_ method of a _ServletContextListener_
that was neither declared in the _web.xml_ or _web-fragment.xml_ , nor
annotated with _javax.servlet.annotation.WebListener._

===== [#50626599_pgfId-1000520]##Programmatically adding and configuring Listeners

====== [#50626599_pgfId-1000532]##[#50626599_49795]##void addListener(String className)

[#50626599_pgfId-1000541]##Add the listener with the given class name to
the _ServletContext_ . The class with the given name will be loaded
using the classloader associated with the application represented by the
_ServletContext_ , and MUST implement one or more of the following
interfaces:

[#50626599_pgfId-1000542]##
_javax.servlet.ServletContextAttributeListener_

[#50626599_pgfId-1000561]## _javax.servlet.ServletRequestListener_

[#50626599_pgfId-1000564]##
_javax.servlet.ServletRequestAttributeListener_

[#50626599_pgfId-1000571]## _javax.servlet.http.HttpSessionListener_

[#50626599_pgfId-1000578]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626599_pgfId-1001200]## _javax.servlet.http.HttpSessionIdListener_

[#50626599_pgfId-1000659]##If the _ServletContext_ was passed to the
_ServletContainerInitializer’s_ _onStartup_ method, then the class with
the given name MAY also implement _javax.servlet.ServletContextListener_
in addition to the interfaces listed above. As part of this method call,
the container MUST load the class with the specified class name to
ensure that it implements one of the required interfaces. If the class
with the given name implements a listener interface whose invocation
order corresponds to the declaration order, that is, if it implements
_javax.servlet.ServletRequestListener,
javax.servlet.ServletContextListener_ or
_javax.servlet.http.HttpSessionListener,_ then the new listener will be
added to the end of the ordered list of listeners of that interface.

====== [#50626599_pgfId-1000666]##[#50626599_73584]##<T extends EventListener> void addListener(T t)

[#50626599_pgfId-1000689]##Add the given listener to the
_ServletContext_ . The given listener MUST be an instance of one or more
of the following interfaces:

[#50626599_pgfId-1000668]##
_javax.servlet.ServletContextAttributeListener_

[#50626599_pgfId-1000669]## _javax.servlet.ServletRequestListener_

[#50626599_pgfId-1000670]##
_javax.servlet.ServletRequestAttributeListener_

[#50626599_pgfId-1000671]## _javax.servlet.http.HttpSessionListener_

[#50626599_pgfId-1000672]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626599_pgfId-1001239]## _javax.servlet.http.HttpSessionIdListener_

[#50626599_pgfId-1001526]##If the _ServletContext_ was passed to the
_ServletContainerInitializer’s_ _onStartup_ method, then the given
listener MAY also be an instance of
_javax.servlet.ServletContextListener_ in addition to the interfaces
listed above. If the given listener is an instance of a listener
interface whose invocation order corresponds to the declaration order,
that is, if it implements _javax.servlet.ServletRequestListener,
javax.servlet.ServletContextListener_ or
_javax.servlet.http.HttpSessionListener,_ then the new listener will be
added to the end of the ordered list of listeners of that interface.

====== [#50626599_pgfId-1000705]##[#50626599_73210]##void addListener(Class <? extends EventListener> listenerClass)

[#50626599_pgfId-1000706]##Add the listener of the given class type to
the _ServletContext_ . The given listener class MUST implement one or
more of the following interfaces:

[#50626599_pgfId-1000707]##
_javax.servlet.ServletContextAttributeListener_

[#50626599_pgfId-1000708]## _javax.servlet.ServletRequestListener_

[#50626599_pgfId-1000709]##
_javax.servlet.ServletRequestAttributeListener_

[#50626599_pgfId-1000710]## _javax.servlet.http.HttpSessionListener_

[#50626599_pgfId-1000711]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626599_pgfId-1001318]## _javax.servlet.http.HttpSessionIdListener_

[#50626599_pgfId-1000703]##If the _ServletContext_ was passed to the
_ServletContainerInitializer’s_ _onStartup_ method, then the given
listener class MAY also implement _javax.servlet.ServletContextListener_
in addition to the interfaces listed above. If the given listener class
implements a listener interface whose invocation order corresponds to
the declaration order, that is, if it implements
_javax.servlet.ServletRequestListener,
javax.servlet.ServletContextListener_ or
_javax.servlet.http.HttpSessionListener,_ then the new listener will be
added to the end of the ordered list of listeners of that interface.

====== [#50626599_pgfId-1000748]##[#50626599_81110]##<T extends EventListener> void createListener(Class<T> clazz)

[#50626599_pgfId-1000768]##This method instantiates the given
EventListener class. The specified EventListener class MUST implement at
least one of the following interfaces:

[#50626599_pgfId-1000771]##
_javax.servlet.ServletContextAttributeListener_

[#50626599_pgfId-1000772]## _javax.servlet.ServletRequestListener_

[#50626599_pgfId-1000773]##
_javax.servlet.ServletRequestAttributeListener_

[#50626599_pgfId-1000774]## _javax.servlet.http.HttpSessionListener_

[#50626599_pgfId-1000784]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626599_pgfId-1001335]## _javax.servlet.http.HttpSessionIdListener_

[#50626599_pgfId-1000792]##This method MUST support all annotations
applicable to the above listener interfaces as defined by this
specification. The returned EventListener instance may be further
customized before it is registered with the ServletContext via a call to
addListener(T t). The given EventListener class MUST define a zero
argument constructor, which is used to instantiate it.

====== [#50626599_pgfId-1000887]##[#50626599_11622]##Annotation processing requirements for programmatically added Servlets, Filters and Listeners

[#50626599_pgfId-1000888]##When using the programmatic API to add a
servlet or create a servlet, apart from the addServlet that takes an
instance, the following annotations must be introspected in the class in
question and the metadata defined in it MUST be used unless it is
overridden by calls to the API in the _ServletRegistration.Dynamic_ /
_ServletRegistration_ .

[#50626599_pgfId-1000889]## _@ServletSecurity, @RunAs, @DeclareRoles,
@MultipartConfig_ .

[#50626599_pgfId-1000890]##For Filters and Listeners no annotations need
to be introspected.

[#50626599_pgfId-1002778]##Resource injection on all components
(Servlets, Filters and Listeners) added programmatically or created
programmatically, other than the ones added via the methods that takes
an instance, will only be supported when the component is a CDI Managed
Bean. For details please refer to link:servlet.htm#50626607_29754[See
Contexts and Dependency Injection for Java EE requirements].

===== [#50626599_pgfId-1002859]##[#50626599_46668]##Programmatically configuring session time out

[#50626599_pgfId-1002860]##The following methods of the _ServletContext_
interface allow the web application to access and configure the default
session timeout interval for all sessions created in the given web
application. The specified timeout in _setSessionTimeout_ is in minutes.
If the timeout is 0 or less the container ensures the default behavior
of sessions is never to time out.

[#50626599_pgfId-1003209]## _getSessionTimeout()_

[#50626599_pgfId-1003223]## _setSessionTimeout(int timeout)_

===== [#50626599_pgfId-1003331]##[#50626599_33517]##Programmatically configuring character encoding

[#50626599_pgfId-1003368]##The following methods of the _ServletContext_
interface allow the web application to access and configure request and
response character encoding.

[#50626599_pgfId-1003540]## _getRequestCharacterEncoding()_

[#50626599_pgfId-1003541]## _setRequestCharacterEncoding(String
encoding)_

[#50626599_pgfId-1003634]## _getResponseCharacterEncoding()_

[#50626599_pgfId-1003689]## _setResponseCharacterEncoding(String
encoding)_

[#50626599_pgfId-1003690]##If no request character encoding is specified
in deployment descriptor or container specific configuration (for all
web applications in the container), _getRequestCharacterEncoding()_
returns null. If no response character encoding is specified in
deployment descriptor or container specific configuration (for all web
applications in the container), _getResponseCharacterEncoding()_ returns
null.

==== [#50626599_pgfId-1003691]##

image:servlet-18.gif[image]

Context Attributes

[#50626599_pgfId-999476]##A servlet can bind an object attribute into
the context by name. Any attribute bound into a context is available to
any other servlet that is part of the same Web application. The
following methods of _ServletContext_ interface allow access to this
functionality:

[#50626599_pgfId-999477]## _setAttribute_

[#50626599_pgfId-999478]## _getAttribute_

[#50626599_pgfId-999479]## _getAttributeNames_

[#50626599_pgfId-999480]## _removeAttribute_

===== [#50626599_pgfId-999481]##Context Attributes in a Distributed Container

[#50626599_pgfId-999482]##Context attributes are local to the JVM in
which they were created. This prevents _ServletContext_ attributes from
being a shared memory store in a distributed container. When information
needs to be shared between servlets running in a distributed
environment, the information should be placed into a session (See
link:servlet.htm#50626609_40048[See Sessions]”), stored in a database,
or set in an Enterprise JavaBeans™ component.

==== [#50626599_pgfId-999486]##

image:servlet-18.gif[image]

Resources

[#50626599_pgfId-999487]##The _ServletContext_ interface provides direct
access only to the hierarchy of static content documents that are part
of the Web application, including HTML, GIF, and JPEG files, via the
following methods of the _ServletContext_ interface:

[#50626599_pgfId-999488]## _getResource_

[#50626599_pgfId-999489]## _getResourceAsStream_

[#50626599_pgfId-999490]##The _getResource_ and _getResourceAsStream_
methods take a _String_ with a leading “/” as an argument that gives the
path of the resource relative to the root of the context or relative to
the _META-INF/resources_ directory of a JAR file inside the web
application’s _WEB-INF/lib_ directory. If there is a _WEB-INF_ entry
inside the _META-INF/resources_ entry of a JAR file in _WEB-INF/lib_ ,
then it and all child entries are available only as static resources. No
classes or jars will be placed on the context classpath from such a
_WEB-INF_ entry, and no Servlet specific descriptors will be processed.
These methods will first search the root of the web application context
for the requested resource before looking at any of the JAR files in the
_WEB-INF/lib_ directory. The order in which the JAR files in the
_WEB-INF/lib_ directory are scanned is undefined. This hierarchy of
documents may exist in the server’s file system, in a Web application
archive file, on a remote server, or at some other location.

[#50626599_pgfId-999491]##These methods are not used to obtain dynamic
content. For example, in a container supporting the JavaServer Pages™
specificationlink:#pgfId-999494[5], a method call of the form
_getResource("/index.jsp")_ would return the JSP source code and not the
processed output. See link:servlet.htm#50626608_85442[See Dispatching
Requests]” for more information about accessing dynamic content.

[#50626599_pgfId-999498]##The full listing of the resources in the Web
application can be accessed using the _getResourcePaths(String path)_
method. The full details on the semantics of this method may be found in
the API documentation in this specification.

==== [#50626599_pgfId-999499]##

image:servlet-18.gif[image]

[#50626599_95664]##Multiple Hosts and Servlet Contexts

[#50626599_pgfId-999500]##Web servers may support multiple logical hosts
sharing one IP address on a server. This capability is sometimes
referred to as "virtual hosting". In this case, each logical host must
have its own servlet context or set of servlet contexts. Servlet
contexts can not be shared across virtual hosts.

[#50626599_pgfId-1001739]##The _getVirtualServerName_ method of
_ServletContext_ interface allows access to the configuration name of
the logical host on which the _ServletContext_ is deployed. Servlet
containers may support multiple logical hosts. This method must return
the same name for all the servlet contexts deployed on a logical host,
and the name returned by this method must be distinct, stable per
logical host, and suitable for use in associating server configuration
information with the logical host.

==== [#50626599_pgfId-999501]##

image:servlet-18.gif[image]

Reloading Considerations

[#50626599_pgfId-999502]##Although a Container Provider implementation
of a class reloading scheme for ease of development is not required, any
such implementation must ensure that all servlets, and classes that they
may uselink:#pgfId-999505[6], are loaded in the scope of a single class
loader. This requirement is needed to guarantee that the application
will behave as expected by the Developer. As a development aid, the full
semantics of notification to session binding listeners should be
supported by containers for use in the monitoring of session termination
upon class reloading.

[#50626599_pgfId-999506]##Previous generations of containers created new
class loaders to load a servlet, distinct from class loaders used to
load other servlets or classes used in the servlet context. This could
cause object references within a servlet context to point at unexpected
classes or objects, and cause unexpected behavior. The requirement is
needed to prevent problems caused by demand generation of new class
loaders.

===== [#50626599_pgfId-999507]##Temporary Working Directories

[#50626599_pgfId-999508]##A temporary storage directory is required for
each servlet context. Servlet containers must provide a private
temporary directory for each servlet context, and make it available via
the _javax.servlet.context.tempdir_ context attribute. The objects
associated with the attribute must be of type _java.io.File_ .

[#50626599_pgfId-999509]##The requirement recognizes a common
convenience provided in many servlet engine implementations. The
container is not required to maintain the contents of the temporary
directory when the servlet container restarts, but is required to ensure
that the contents of the temporary directory of one servlet context is
not visible to the servlet contexts of other Web applications running on
the servlet container.

[#50626599_pgfId-999460]## 

== [#50626600_pgfId-874]## 

=== [#50626600_pgfId-999462]##

image:servlet-19.gif[image]

The Response

image:servlet-20.gif[image]

[#50626600_pgfId-999463]##The response object encapsulates all
information to be returned from the server to the client. In the HTTP
protocol, this information is transmitted from the server to the client
either by HTTP headers or the message body of the request.

==== [#50626600_pgfId-999464]##

image:servlet-21.gif[image]

[#50626600_76361]##Buffering

[#50626600_pgfId-999465]##A servlet container is allowed, but not
required, to buffer output going to the client for efficiency purposes.
Typically servers that do buffering make it the default, but allow
servlets to specify buffering parameters.

[#50626600_pgfId-999466]##The following methods in the _ServletResponse_
interface allow a servlet to access and set buffering information:

[#50626600_pgfId-999467]## _getBufferSize_

[#50626600_pgfId-999468]## _setBufferSize_

[#50626600_pgfId-999469]## _isCommitted_

[#50626600_pgfId-999470]## _reset_

[#50626600_pgfId-999471]## _resetBuffer_

[#50626600_pgfId-999472]## _flushBuffer_

[#50626600_pgfId-999473]##These methods are provided on the
_ServletResponse_ interface to allow buffering operations to be
performed whether the servlet is using a _ServletOutputStream_ or a
_Writer_ .

[#50626600_pgfId-999474]##The _getBufferSize_ method returns the size of
the underlying buffer being used. If no buffering is being used, this
method must return the _int_ value of _0_ (zero).

[#50626600_pgfId-999475]##The servlet can request a preferred buffer
size by using the _setBufferSize_ method. The buffer assigned is not
required to be the size requested by the servlet, but must be at least
as large as the size requested. This allows the container to reuse a set
of fixed size buffers, providing a larger buffer than requested if
appropriate. The method must be called before any content is written
using a _ServletOutputStream_ or _Writer_ . If any content has been
written or the response object has been committed, this method must
throw an _IllegalStateException_ .

[#50626600_pgfId-999476]##The _isCommitted_ method returns a boolean
value indicating whether any response bytes have been returned to the
client. The _flushBuffer_ method forces content in the buffer to be
written to the client.

[#50626600_pgfId-1000344]##The _reset_ method clears data in the buffer
when the response is not committed. Headers, status codes and the state
of calling getWriter or getOutputStream set by the servlet prior to the
reset call must be cleared as well. The _resetBuffer_ method clears
content in the buffer if the response is not committed without clearing
the headers and status code.

[#50626600_pgfId-999478]##If the response is committed and the _reset_
or _resetBuffer_ method is called, an _IllegalStateException_ must be
thrown. The response and its associated buffer will be unchanged.

[#50626600_pgfId-999479]##When using a buffer, the container must
immediately flush the contents of a filled buffer to the client. If this
is the first data that is sent to the client, the response is considered
to be committed.

==== [#50626600_pgfId-999480]##

image:servlet-21.gif[image]

[#50626600_40116]##Headers

[#50626600_pgfId-999481]##A servlet can set headers of an HTTP response
via the following methods of the _HttpServletResponse_ interface:

[#50626600_pgfId-999482]## _setHeader_

[#50626600_pgfId-999483]## _addHeader_

[#50626600_pgfId-999484]##The _setHeader_ method sets a header with a
given name and value. A previous header is replaced by the new header.
Where a set of header values exist for the name, the values are cleared
and replaced with the new value.

[#50626600_pgfId-999485]##The _addHeader_ method adds a header value to
the set with a given name. If there are no headers already associated
with the name, a new set is created.

[#50626600_pgfId-999486]##Headers may contain data that represents an
_int_ or a _Date_ object. The following convenience methods of the
_HttpServletResponse_ interface allow a servlet to set a header using
the correct formatting for the appropriate data type:

[#50626600_pgfId-999487]## _setIntHeader_

[#50626600_pgfId-999488]## _setDateHeader_

[#50626600_pgfId-999489]## _addIntHeader_

[#50626600_pgfId-999490]## _addDateHeader_

[#50626600_pgfId-999491]##To be successfully transmitted back to the
client, headers (not trailer) must be set before the response is
committed. Headers (not trailer) set after the response is committed
will be ignored by the servlet container. If HTTP trailer, as specified
in RFC 7230, are to be sent in the response, they must be provided using
the _setTrailerFields()_ method on _HttpServletResponse_ . This method
must have been called before the last chunk in the chunked response has
been written.

[#50626600_pgfId-999492]##Servlet programmers are responsible for
ensuring that the _Content-Type_ header is appropriately set in the
response object for the content the servlet is generating. The HTTP 1.1
specification does not require that this header be set in an HTTP
response. Servlet containers must not set a default content type when
the servlet programmer does not set the type.

[#50626600_pgfId-1003773]##It is recommended that containers use the
_X-Powered-By_ HTTP header to publish its implementation information.
The field value should consist of one or more implementation types, such
as " _Servlet/4.0_ ". Optionally, the supplementary information of the
container and the underlying Java platform can be added after the
implementation type within parentheses. The container should be
configurable to suppress this header.

[#50626600_pgfId-1003690]##Here’s the examples of this header.

[#50626600_pgfId-1003691]##X-Powered-By: Servlet/4.0

[#50626600_pgfId-1003692]##X-Powered-By: Servlet/4.0 JSP/2.3 (GlassFish
Server Open Source Edition 5.0 Java/Oracle Corporation/1.8)

==== [#50626600_pgfId-1005248]##

image:servlet-21.gif[image]

[#50626600_49483]##HTTP Trailer

[#50626600_pgfId-1005273]##HTTP trailer is a collection of special kind
of HTTP headers that comes after the response body. Trailer is specified
in RFC 7230. They are useful in the context of chunked transfer encoding
and also in the implementation of additional communication protocols.
Servlet containers provide support for trailers.

[#50626600_pgfId-1005933]##If trailer headers are ready for reading,
_isTrailerFieldsReady()_ will return true. Then a servlet can read
trailer headers of the HTTP request via the _getTrailerFields()_ method
of the _HttpServletRequest_ interface.

[#50626600_pgfId-1005278]##A servlet can write trailer headers to the
response by providing a _Supplier_ to the _setTrailerFields_ method of
the _HttpServletResponse_ interface. The _Supplier_ of the trailer
headers can be obtained by accessing the _getTrailerFields()_ method of
the _HttpServletResponse_ interface.

[#50626600_pgfId-1005692]##Please see the javadoc for these two methods
for the normative specification.

==== [#50626600_pgfId-1003693]##

image:servlet-21.gif[image]

Non Blocking IO

[#50626600_pgfId-1003694]##Non-blocking IO only works with async request
processing in Servlets and Filters (as defined in
link:servlet.htm#50626601_53655[See Asynchronous processing]), and
upgrade processing (as defined in link:servlet.htm#50626601_49366[See
Upgrade Processing]). Otherwise, an _IllegalStateException_ must be
thrown when _ServletInputStream.setReadListener_ or
_ServletOutputStream.setWriteListener_ is invoked. To support
non-blocking writes in the Web container, in addition to the changes
made in the _ServletRequest_ as described in
link:servlet.htm#50626597_non-blocking-io-request[See Non Blocking IO],
the following changes have been made to handle response related classes
/ interfaces.

[#50626600_pgfId-1002739]##The _WriteListener_ provides the following
callback methods which the container invokes appropriately.

[#50626600_pgfId-1000515]## _WriteListener_

[#50626600_pgfId-1002478]## _void onWritePossible()._ When a
_WriteListener_ is registered with the _ServletOutputStream_ , this
method will be invoked by the container the first time when it is
possible to write data. The container will subsequently invoke the
_onWritePossible_ method if and only if the _isReady_ method on
_ServletOutputStream_ , described below, returns a value of _false_ and
a write operation has subsequently become possible.

[#50626600_pgfId-1000535]## _onError(Throwable t)_ . Invoked when an
error occurs processing the response.

[#50626600_pgfId-1000747]##Along with the _WriteListener_ , the
following methods have been added to _ServletOutputStream_ class to
allow the developer to check with the runtime whether or not it is
possible to write the data to be sent to the client.

[#50626600_pgfId-1000552]## _ServletOutputStream_

[#50626600_pgfId-1000566]## _boolean isReady()._ This method returns
_true_ if a write to the _ServletOutputStream_ will succeed, otherwise
it will return _false_ . If this method returns _true_ , a write
operation can be performed on the _ServletOutputStream_ . If no further
data can be written to the _ServletOutputStream_ . then this method will
return _false_ till the underlying data is flushed at which point the
container will invoke the _onWritePossible_ method of the
_WriteListener._ A subsequent call to this method will return _true_ .

[#50626600_pgfId-1001325]## _void setWriteListener(WriteListener
listener)_ . Associates the _WriteListener_ with this
_ServletOutputStream_ . for the container to invoke the callback methods
on the _WriteListener_ when it is possible to write data. Registering a
_WriteListener_ will start non-blocking IO. It is illegal to switch to
the traditional blocking IO at that point. The use of IO related method
calls after this illegal switch to traditional blocking IO produces
unspecified behavior.

[#50626600_pgfId-1000493]##The Servlet container must access methods in
_WriteListener_ in a thread safe manner.

==== [#50626600_pgfId-1000474]##

image:servlet-21.gif[image]

Convenience Methods

[#50626600_pgfId-999498]##The following convenience methods exist in the
_HttpServletResponse_ interface:

[#50626600_pgfId-1000486]## _sendRedirect_

[#50626600_pgfId-1000487]## _sendError_

[#50626600_pgfId-1000488]##The _sendRedirect_ method will set the
appropriate headers and content body to redirect the client to a
different URL. It is legal to call this method with a relative URL path,
however the underlying container must translate the relative path to a
fully qualified URL for transmission back to the client. If a partial
URL is given and, for whatever reason, cannot be converted into a valid
URL, then this method must throw an _IllegalArgumentException_ .

[#50626600_pgfId-999502]##The _sendError_ method will set the
appropriate headers and content body for an error message to return to
the client. An optional _String_ argument can be provided to the
_sendError_ method which can be used in the content body of the error.

[#50626600_pgfId-999503]##These methods will have the side effect of
committing the response, if it has not already been committed, and
terminating it. No further output to the client should be made by the
servlet after these methods are called. If data is written to the
response after these methods are called, the data is ignored.

[#50626600_pgfId-999504]##If data has been written to the response
buffer, but not returned to the client (i.e. the response is not
committed), the data in the response buffer must be cleared and replaced
with the data set by these methods. If the response is committed, these
methods must throw an _IllegalStateException_ .

==== [#50626600_pgfId-999505]##

image:servlet-21.gif[image]

[#50626600_10199]##Internationalization

[#50626600_pgfId-999506]##Servlets should set the locale and the
character encoding of a response. The locale is set using the
_ServletResponse.setLocale_ method. The method can be called repeatedly;
but calls made after the response is committed have no effect. If the
servlet does not set the locale before the page is committed, the
container’s default locale is used to determine the response’s locale,
but no specification is made for the communication with a client, such
as _Content-Language_ header in the case of HTTP.

[width="100%",cols="100%",]
|===
a|
[#50626600_pgfId-999724]##<locale-encoding-mapping-list>

[#50626600_pgfId-999725]## <locale-encoding-mapping>

[#50626600_pgfId-999726]## <locale>ja</locale>

[#50626600_pgfId-999727]## <encoding>Shift_JIS</encoding>

[#50626600_pgfId-999728]## </locale-encoding-mapping>

[#50626600_pgfId-999722]##</locale-encoding-mapping-list>

|===

[#50626600_pgfId-999515]##The <response-character-encoding> element can
be used to explicitly set the default encoding for all responses in a
given web application.

[width="100%",cols="100%",]
|===
|[#50626600_pgfId-1004333]##<response-character-encoding>UTF-8</response-character-encoding>
|===

[#50626600_pgfId-1004155]##If neither element exists or does not provide
a mapping, _setLocale_ uses a container dependent mapping. The
_setCharacterEncoding_ , _setContentType_ , and _setLocale_ methods can
be called repeatedly to change the character encoding. Calls made after
the servlet response’s _getWriter_ method has been called or after the
response is committed have no effect on the character encoding. Calls to
_setContentType_ set the character encoding only if the given content
type string provides a value for the _charset_ attribute. Calls to
_setLocale_ set the character encoding only if neither
_setCharacterEncoding_ nor _setContentType_ has set the character
encoding before.

[#50626600_pgfId-999516]##If the servlet does not specify a character
encoding before the _getWriter_ method of the _ServletResponse_
interface is called or the response is committed, the default
_ISO-8859-1_ is used.

[#50626600_pgfId-999517]##Containers must communicate the locale and the
character encoding used for the servlet response’s writer to the client
if the protocol in use provides a way for doing so. In the case of HTTP,
the locale is communicated via the _Content-Language_ header, the
character encoding as part of the _Content-Type_ header for text media
types. Note that the character encoding cannot be communicated via HTTP
headers if the servlet does not specify a content type; however, it is
still used to encode text written via the servlet response’s writer.

==== [#50626600_pgfId-999519]##

image:servlet-21.gif[image]

[#50626600_39611]##Closure of Response Object

[#50626600_pgfId-999520]##When a response is closed, the container must
immediately flush all remaining content in the response buffer to the
client. The following events indicate that the servlet has satisfied the
request and that the response object is to be closed:

[#50626600_pgfId-999521]##The termination of the _service_ method of the
servlet.

[#50626600_pgfId-999522]##The amount of content specified in the
_setContentLength_ or _setContentLengthLong_ method of the response has
been greater than zero and has been written to the response.

[#50626600_pgfId-999523]##The _sendError_ method is called.

[#50626600_pgfId-999524]##The _sendRedirect_ method is called.

[#50626600_pgfId-1000156]##The _complete_ method on _AsyncContext_ is
called.

==== [#50626600_pgfId-999526]##

image:servlet-21.gif[image]

[#50626600_68517]##Lifetime of the Response Object

[#50626600_pgfId-999527]##Each response object is valid only within the
scope of a servlet’s _service_ method, or within the scope of a filter’s
_doFilter_ method, unless the associated request object has asynchronous
processing enabled for the component. If asynchronous processing on the
associated request is started, then the response object remains valid
until _complete_ method on _AsyncContext_ is called. Containers commonly
recycle response objects in order to avoid the performance overhead of
response object creation. The developer must be aware that maintaining
references to response objects for which _startAsync_ on the
corresponding request has not been called, outside the scope described
above may lead to non-deterministic behavior.

[#50626600_pgfId-999460]## 

== [#50626598_pgfId-874]## 

=== [#50626598_pgfId-999461]##

image:servlet-22.gif[image]

Filtering

image:servlet-23.gif[image]

[#50626598_pgfId-1000542]##Filters are Java components that allow on the
fly transformations of payload and header information in both the
request into a resource and the response from a resource

[#50626598_pgfId-1000543]##The Java Servlet API classes and methods that
provide a lightweight framework for filtering active and static content.
It describes how filters are configured in a Web application, and
conventions and semantics for their implementation.

[#50626598_pgfId-999466]##API documentation for servlet filters is
provided online. The configuration syntax for filters is given by the
deployment descriptor schema in link:servlet.htm#50626592_84118[See
Deployment Descriptor]. The reader should use these sources as
references when reading this chapter.

==== [#50626598_pgfId-999471]##

image:servlet-24.gif[image]

What is a filter?

[#50626598_pgfId-999472]##A filter is a reusable piece of code that can
transform the content of HTTP requests, responses, and header
information. Filters do not generally create a response or respond to a
request as servlets do, rather they modify or adapt the requests for a
resource, and modify or adapt responses from a resource.

[#50626598_pgfId-999473]##Filters can act on dynamic or static content.
For the purposes of this chapter, dynamic and static content are
referred to as Web resources.

[#50626598_pgfId-999474]##Among the types of functionality available to
the developer needing to use filters are the following:

[#50626598_pgfId-999475]##The accessing of a resource before a request
to it is invoked.

[#50626598_pgfId-999476]##The processing of the request for a resource
before it is invoked.

[#50626598_pgfId-999477]##The modification of request headers and data
by wrapping the request in customized versions of the request object.

[#50626598_pgfId-999478]##The modification of response headers and
response data by providing customized versions of the response object.

[#50626598_pgfId-999479]##The interception of an invocation of a
resource after its call.

[#50626598_pgfId-999480]##Actions on a servlet, on groups of servlets,
or static content by zero, one, or more filters in a specifiable order.

===== [#50626598_pgfId-999481]##Examples of Filtering Components

[#50626598_pgfId-999482]##Authentication filters

[#50626598_pgfId-999483]##Logging and auditing filters

[#50626598_pgfId-999484]##Image conversion filters

[#50626598_pgfId-999485]##Data compression filters

[#50626598_pgfId-999486]##Encryption filters

[#50626598_pgfId-999487]##Tokenizing filters

[#50626598_pgfId-999488]## Filters that trigger resource access events

[#50626598_pgfId-999489]##XSL/T filters that transform XML content

[#50626598_pgfId-999490]##MIME-type chain filters

[#50626598_pgfId-999491]##Caching filters

==== [#50626598_pgfId-999492]##

image:servlet-24.gif[image]

Main Concepts

[#50626598_pgfId-999493]##The main concepts of this filtering model are
described in this section.

[#50626598_pgfId-999494]##The application developer creates a filter by
implementing the _javax.servlet.Filter_ interface and providing a public
constructor taking no arguments. The class is packaged in the Web
Archive along with the static content and servlets that make up the Web
application. A filter is declared using the _<filter>_ element in the
deployment descriptor. A filter or collection of filters can be
configured for invocation by defining _<filter-mapping>_ elements in the
deployment descriptor. This is done by mapping filters to a particular
servlet by the servlet’s logical name, or mapping to a group of servlets
and static content resources by mapping a filter to a URL pattern.

===== [#50626598_pgfId-999495]##[#50626598_92626]##Filter Lifecycle

[#50626598_pgfId-999496]##After deployment of the Web application, and
before a request causes the container to access a Web resource, the
container must locate the list of filters that must be applied to the
Web resource as described below. The container must ensure that it has
instantiated a filter of the appropriate class for each filter in the
list, and called its _init(FilterConfig config)_ method. The filter may
throw an exception to indicate that it cannot function properly. If the
exception is of type _UnavailableException_ , the container may examine
the isPermanent attribute of the exception and may choose to retry the
filter at some later time.

[#50626598_pgfId-999497]##Only one instance per _<filter>_ declaration
in the deployment descriptor is instantiated per JVM of the container.
The container provides the filter _config_ as declared in the filter’s
deployment descriptor, the reference to the _ServletContext_ for the Web
application, and the set of initialization parameters.

[#50626598_pgfId-999498]##When the container receives an incoming
request, it takes the first filter instance in the list and calls its
_doFilter_ method, passing in the _ServletRequest_ and _ServletResponse_
, and a reference to the _FilterChain_ object it will use.

[#50626598_pgfId-999499]##The _doFilter_ method of a filter will
typically be implemented following this or some subset of the following
pattern:

======= [#50626598_pgfId-999500]##The method examines the request’s headers.

[#50626598_pgfId-999501]##The method may wrap the request object with a
customized implementation of _ServletRequest_ or _HttpServletRequest_ in
order to modify request headers or data.

[#50626598_pgfId-999502]##The method may wrap the response object passed
in to its _doFilter_ method with a customized implementation of
_ServletResponse_ or _HttpServletResponse_ to modify response headers or
data.

[#50626598_pgfId-999503]##The filter may invoke the next entity in the
filter chain. The next entity may be another filter, or if the filter
making the invocation is the last filter configured in the deployment
descriptor for this chain, the next entity is the target Web resource.
The invocation of the next entity is effected by calling the _doFilter_
method on the _FilterChain_ object, and passing in the request and
response with which it was called or passing in wrapped versions it may
have created.

[#50626598_pgfId-999504]##The filter chain’s implementation of the
_doFilter_ method, provided by the container, must locate the next
entity in the filter chain and invoke its _doFilter_ method, passing in
the appropriate request and response objects.

[#50626598_pgfId-999505]##Alternatively, the filter chain can block the
request by not making the call to invoke the next entity, leaving the
filter responsible for filling out the response object.

[#50626598_pgfId-1001046]##The _service_ method is required to run in
the same thread as all filters that apply to the servlet.

[#50626598_pgfId-999506]##After invocation of the next filter in the
chain, the filter may examine response headers.

[#50626598_pgfId-999507]##Alternatively, the filter may have thrown an
exception to indicate an error in processing. If the filter throws an
_UnavailableException_ during its _doFilter_ processing, the container
must not attempt continued processing down the filter chain. It may
choose to retry the whole chain at a later time if the exception is not
marked permanent.

[#50626598_pgfId-999508]##When the last filter in the chain has been
invoked, the next entity accessed is the target servlet or resource at
the end of the chain.

[#50626598_pgfId-999509]##Before a filter instance can be removed from
service by the container, the container must first call the _destroy_
method on the filter to enable the filter to release any resources and
perform other cleanup operations.

===== [#50626598_pgfId-999511]##[#50626598_36710]##Wrapping Requests and Responses

[#50626598_pgfId-999512]##Central to the notion of filtering is the
concept of wrapping a request or response in order that it can override
behavior to perform a filtering task. In this model, the developer not
only has the ability to override existing methods on the request and
response objects, but to provide new API suited to a particular
filtering task to a filter or target web resource down the chain. For
example, the developer may wish to extend the response object with
higher level output objects that the output stream or the writer, such
as API that allows DOM objects to be written back to the client.

[#50626598_pgfId-999513]##In order to support this style of filter the
container must support the following requirement. When a filter invokes
the _doFilter_ method on the container’s filter chain implementation,
the container must ensure that the request and response object that it
passes to the next entity in the filter chain, or to the target web
resource if the filter was the last in the chain, is the same object
that was passed into the _doFilter_ method by the calling filter.

[#50626598_pgfId-999514]##The same requirement of wrapper object
identity applies to the calls from a servlet or a filter to
_RequestDispatcher.forward_ or _RequestDispatcher.include_ , when the
caller wraps the request or response objects. In this case, the request
and response objects seen by the called servlet must be the same wrapper
objects that were passed in by the calling servlet or filter.

===== [#50626598_pgfId-999516]##[#50626598_90980]##Filter Environment

[#50626598_pgfId-999517]##A set of initialization parameters can be
associated with a filter using the _<init-params>_ element in the
deployment descriptor. The names and values of these parameters are
available to the filter at runtime via the _getInitParameter_ and
_getInitParameterNames_ methods on the filter’s _FilterConfig_ object.
Additionally, the _FilterConfig_ affords access to the _ServletContext_
of the Web application for the loading of resources, for logging
functionality, and for storage of state in the _ServletContext_ ’s
attribute list. A Filter and the target servlet or resource at the end
of the filter chain must execute in the same invocation thread.

===== [#50626598_pgfId-999519]##[#50626598_62972]##Configuration of Filters in a Web Application

[#50626598_pgfId-999520]##A filter is defined either via the
_@WebFilter_ annotation as defined in
link:servlet.htm#50626585_85217[See @WebFilter] of the specification or
in the deployment descriptor using the _<filter>_ element. In this
element, the programmer declares the following:

[#50626598_pgfId-999521]## _filter-name_ : used to map the filter to a
servlet or URL

[#50626598_pgfId-1000600]## _filter-class_ : used by the container to
identify the filter type

[#50626598_pgfId-1000601]## _init-params_ : initialization parameters
for a filter

[#50626598_pgfId-1000602]##Optionally, the programmer can specify icons,
a textual description, and a display name for tool manipulation. The
container must instantiate exactly one instance of the Java class
defining the filter per filter declaration in the deployment descriptor.
Hence, two instances of the same filter class will be instantiated by
the container if the developer makes two filter declarations for the
same filter class.

[#50626598_pgfId-999525]##Here is an example of a filter declaration:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999871]##<filter>

[#50626598_pgfId-999872]## <filter-name>Image Filter</filter-name>

[#50626598_pgfId-999873]##
<filter-class>com.example.ImageServlet</filter-class>

[#50626598_pgfId-999869]##</filter>

|===

[#50626598_pgfId-999528]##Once a filter has been declared in the
deployment descriptor, the assembler uses the _<filter-mapping>_ element
to define servlets and static resources in the Web application to which
the filter is to be applied. Filters can be associated with a servlet
using the _<servlet-name>_ element. For example, the following code
example maps the Image Filter filter to the _ImageServlet_ servlet:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999883]##<filter-mapping>

[#50626598_pgfId-999884]## <filter-name>Image Filter</filter-name>

[#50626598_pgfId-999885]## <servlet-name>ImageServlet</servlet-name>

[#50626598_pgfId-999881]##</filter-mapping>

|===

[#50626598_pgfId-999530]##Filters can be associated with groups of
servlets and static content using the _<url-pattern>_ style of filter
mapping:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999895]##<filter-mapping>

[#50626598_pgfId-999896]## <filter-name>Logging Filter</filter-name>

[#50626598_pgfId-999897]## <url-pattern>/*</url-pattern>

[#50626598_pgfId-999893]##</filter-mapping>

|===

[#50626598_pgfId-999532]##Here the Logging Filter is applied to all the
servlets and static content pages in the Web application, because every
request URI matches the ‘ _/*_ ’ URL pattern.

[#50626598_pgfId-999533]##When processing a _<filter-mapping>_ element
using the _<url-pattern>_ style, the container must determine whether
the _<url-pattern>_ matches the request URI using the path mapping rules
defined in link:servlet.htm#50626594_64358[See Mapping Requests to
Servlets].

[#50626598_pgfId-999537]##The order the container uses in building the
chain of filters to be applied for a particular request URI is as
follows:

[#50626598_pgfId-999538]##First, the _<url-pattern>_ matching filter
mappings in the same order that these elements appear in the deployment
descriptor.

[#50626598_pgfId-999539]##Next, the _<servlet-name>_ matching filter
mappings in the same order that these elements appear in the deployment
descriptor.

[#50626598_pgfId-1000550]##If a filter mapping contains both
<servlet-name> and <url-pattern>, the container must expand the filter
mapping into multiple filter mappings (one for each <servlet-name> and
<url-pattern>), preserving the order of the <servlet-name> and
<url-pattern> elements. For example, the following filter mapping:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-1000553]##<filter-mapping>

[#50626598_pgfId-1000554]## <filter-name>Multiple Mappings
Filter</filter-name>

[#50626598_pgfId-1000555]## <url-pattern>/foo/*</url-pattern>

[#50626598_pgfId-1000556]## <servlet-name>Servlet1</servlet-name>

[#50626598_pgfId-1000557]## <servlet-name>Servlet2</servlet-name>

[#50626598_pgfId-1000558]## <url-pattern>/bar/*</url-pattern>

[#50626598_pgfId-1000559]##</filter-mapping>

|===

[#50626598_pgfId-1000581]##is equivalent to:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-1000562]##<filter-mapping>

[#50626598_pgfId-1000563]## <filter-name>Multipe Mappings
Filter</filter-name>

[#50626598_pgfId-1000564]## <url-pattern>/foo/*</url-pattern>

[#50626598_pgfId-1000565]##</filter-mapping>

[#50626598_pgfId-1000566]## 

[#50626598_pgfId-1000567]##<filter-mapping>

[#50626598_pgfId-1000568]## <filter-name>Multipe Mappings
Filter</filter-name>

[#50626598_pgfId-1000569]## <servlet-name>Servlet1</servlet-name>

[#50626598_pgfId-1000570]##</filter-mapping>

[#50626598_pgfId-1000571]## 

[#50626598_pgfId-1000572]##<filter-mapping>

[#50626598_pgfId-1000573]## <filter-name>Multipe Mappings
Filter</filter-name>

[#50626598_pgfId-1000574]## <servlet-name>Servlet2</servlet-name>

[#50626598_pgfId-1000575]##</filter-mapping>

[#50626598_pgfId-1000576]## 

[#50626598_pgfId-1000577]##<filter-mapping>

[#50626598_pgfId-1000578]## <filter-name>Multipe Mappings
Filter</filter-name>

[#50626598_pgfId-1000579]## <url-pattern>/bar/*</url-pattern>

[#50626598_pgfId-1000580]##</filter-mapping>

|===

[#50626598_pgfId-1000582]##The requirement about the order of the filter
chain means that the container, when receiving an incoming request,
processes the request as follows:

[#50626598_pgfId-999578]##Identifies the target Web resource according
to the rules of link:servlet.htm#50626594_44611[See Specification of
Mappings].

[#50626598_pgfId-999580]##If there are filters matched by servlet name
and the Web resource has a _<servlet-name>_ , the container builds the
chain of filters matching in the order declared in the deployment
descriptor. The last filter in this chain corresponds to the last
_<servlet-name>_ matching filter and is the filter that invokes the
target Web resource.

[#50626598_pgfId-999581]##If there are filters using _<url-pattern>_
matching and the _<url-pattern>_ matches the request URI according to
the rules of link:servlet.htm#50626594_44611[See Specification of
Mappings], the container builds the chain of _<url-pattern>_ matched
filters in the same order as declared in the deployment descriptor. The
last filter in this chain is the last _<url-pattern>_ matching filter in
the deployment descriptor for this request URI. The last filter in this
chain is the filter that invokes the first filter in the
_<servlet-name>_ matching chain, or invokes the target Web resource if
there are none.

[#50626598_pgfId-999585]##It is expected that high performance Web
containers will cache filter chains so that they do not need to compute
them on a per-request basis.

===== [#50626598_pgfId-999588]##[#50626598_marker-999586]##[#50626598_69819]##Filters and the RequestDispatcher

[#50626598_pgfId-999589]##New since version 2.4 of the Java Servlet
specification is the ability to configure filters to be invoked under
request dispatcher _forward()_ and _include()_ calls.

[#50626598_pgfId-999590]##By using the new _<dispatcher>_ element in the
deployment descriptor, the developer can indicate for a filter-mapping
whether he would like the filter to be applied to requests when:

[#50626598_pgfId-1000682]##The request comes directly from the client.

[#50626598_pgfId-1000683]##This is indicated by a _<dispatcher>_ element
with value _REQUEST_ , or by the absence of any _<dispatcher>_ elements.

[#50626598_pgfId-999594]##The request is being processed under a request
dispatcher representing the Web component matching the _<url-pattern>_
or _<servlet-name>_ using a _forward()_ call.

[#50626598_pgfId-999595]##This is indicated by a _<dispatcher>_ element
with value _FORWARD_ .

[#50626598_pgfId-999596]##The request is being processed under a request
dispatcher representing the Web component matching the _<url-pattern>_
or _<servlet-name>_ using an _include()_ call.

[#50626598_pgfId-999597]##This is indicated by a _<dispatcher>_ element
with value _INCLUDE_ .

[#50626598_pgfId-999600]##The request is being processed with the error
page mechanism specified in link:servlet.htm#50626596_53091[See Error
Handling] to an error resource matching the _<url-pattern>_ .

[#50626598_pgfId-999602]##This is indicated by a _<dispatcher>_ element
with the value _ERROR_ .

[#50626598_pgfId-1000631]##The request is being processed with the async
context dispatch mechanism specified in
link:servlet.htm#50626601_53655[See Asynchronous processing] to a web
component using a _dispatch_ call.

[#50626598_pgfId-1000633]##This is indicated by a _<dispatcher>_ element
with the value _ASYNC._

[#50626598_pgfId-999603]##Or any combination of 1, 2, 3, 4 or 5 above.

[#50626598_pgfId-999610]##For example:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999758]##<filter-mapping>

[#50626598_pgfId-999759]## <filter-name>Logging Filter</filter-name>

[#50626598_pgfId-999760]## <url-pattern>/products/*</url-pattern>

[#50626598_pgfId-999756]##</filter-mapping>

|===

[#50626598_pgfId-999613]##would result in the Logging Filter being
invoked by client requests starting _/products/..._ but not underneath a
request dispatcher call where the request dispatcher has path commencing
_/products/..._ . The _LoggingFilter_ would be invoked both on the
initial dispatch of the request and on resumed request. The following
code:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999773]##<filter-mapping>

[#50626598_pgfId-999774]## <filter-name>Logging Filter</filter-name>

[#50626598_pgfId-999775]## <servlet-name>ProductServlet</servlet-name>

[#50626598_pgfId-999776]## <dispatcher>INCLUDE</dispatcher>

[#50626598_pgfId-999771]##</filter-mapping>

|===

[#50626598_pgfId-999616]##would result in the Logging Filter not being
invoked by client requests to the _ProductServlet_ , nor underneath a
request dispatcher _forward()_ call to the _ProductServlet_ , but would
be invoked underneath a request dispatcher _include()_ call where the
request dispatcher has a name commencing _ProductServlet_ . The
following code:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999786]##<filter-mapping>

[#50626598_pgfId-999787]## <filter-name>Logging Filter</filter-name>

[#50626598_pgfId-999788]## <url-pattern>/products/*</url-pattern>

[#50626598_pgfId-999789]## <dispatcher>FORWARD</dispatcher>

[#50626598_pgfId-999790]## <dispatcher>REQUEST</dispatcher>

[#50626598_pgfId-999784]##</filter-mapping>

|===

[#50626598_pgfId-999619]##would result in the Logging Filter being
invoked by client requests starting _/products/..._ and underneath a
request dispatcher _forward()_ call where the request dispatcher has
path commencing _/products/..._ .

[#50626598_pgfId-999620]##Finally, the following code uses the special
servlet name ‘*’:

[width="100%",cols="100%",]
|===
a|
[#50626598_pgfId-999812]##<filter-mapping>

[#50626598_pgfId-999813]## <filter-name>All Dispatch
Filter</filter-name>

[#50626598_pgfId-999814]## <servlet-name>*</servlet-name>

[#50626598_pgfId-999815]## <dispatcher>FORWARD</dispatcher>

[#50626598_pgfId-999800]##</filter-mapping>

|===

[#50626598_pgfId-999808]##This code would result in the All Dispatch
Filter being invoked on request dispatcher forward() calls for all
request dispatchers obtained by name or by path.

[#50626598_pgfId-998874]## 

== [#50626609_pgfId-874]## 

=== [#50626609_pgfId-999462]##

image:servlet-25.gif[image]

[#50626609_40048]##Sessions

image:servlet-26.gif[image]

[#50626609_pgfId-999463]##The Hypertext Transfer Protocol (HTTP) is by
design a stateless protocol. To build effective Web applications, it is
imperative that requests from a particular client be associated with
each other. Many strategies for session tracking have evolved over time,
but all are difficult or troublesome for the programmer to use directly.

[#50626609_pgfId-999464]##This specification defines a simple
_HttpSession_ interface that allows a servlet container to use any of
several approaches to track a user’s session without involving the
Application Developer in the nuances of any one approach.

==== [#50626609_pgfId-999465]##

image:servlet-27.gif[image]

Session Tracking Mechanisms

[#50626609_pgfId-999466]##The following sections describe approaches to
tracking a user’s sessions

===== [#50626609_pgfId-999467]##Cookies

[#50626609_pgfId-999468]##Session tracking through HTTP cookies is the
most used session tracking mechanism and is required to be supported by
all servlet containers.

[#50626609_pgfId-999469]##The container sends a cookie to the client.
The client will then return the cookie on each subsequent request to the
server, unambiguously associating the request with a session. The
standard name of the session tracking cookie must be _JSESSIONID_ .
Containers may allow the name of the session tracking cookie to be
customized through container specific configuration.

[#50626609_pgfId-1000065]##All servlet containers MUST provide an
ability to configure whether or not the container marks the session
tracking cookie as _HttpOnly_ . The established configuration must apply
to all contexts for which a context specific configuration has not been
established (see _SessionCookieConfig_ javadoc for more details).

[#50626609_pgfId-1000112]##If a web application configures a custom name
for its session tracking cookies, the same custom name will also be used
as the name of the URI parameter if the session id is encoded in the URL
(provided that URL rewriting has been enabled).

===== [#50626609_pgfId-999470]##SSL Sessions

[#50626609_pgfId-999471]##Secure Sockets Layer, the encryption
technology used in the HTTPS protocol, has a built-in mechanism allowing
multiple requests from a client to be unambiguously identified as being
part of a session. A servlet container can easily use this data to
define a session.

===== [#50626609_pgfId-999472]##URL Rewriting

[#50626609_pgfId-999473]##URL rewriting is the lowest common denominator
of session tracking. When a client will not accept a cookie, URL
rewriting may be used by the server as the basis for session tracking.
URL rewriting involves adding data, a session ID, to the URL path that
is interpreted by the container to associate the request with a session.

[#50626609_pgfId-999474]##The session ID must be encoded as a path
parameter in the URL string. The name of the parameter must be
_jsessionid_ . Here is an example of a URL containing encoded path
information:

[#50626609_pgfId-999475]##http://www.example.com/catalog/index.html;jsessionid=1234

[#50626609_pgfId-1000072]##URL rewriting exposes session identifiers in
logs, bookmarks, referer headers, cached HTML, and the URL bar. URL
rewriting should not be used as a session tracking mechanism where
cookies or SSL sessions are supported and suitable.

===== [#50626609_pgfId-999476]##Session Integrity

[#50626609_pgfId-999477]##Web containers must be able to support the
HTTP session while servicing HTTP requests from clients that do not
support the use of cookies. To fulfill this requirement, Web containers
commonly support the URL rewriting mechanism.

==== [#50626609_pgfId-999478]##

image:servlet-27.gif[image]

[#50626609_90938]##Creating a Session

[#50626609_pgfId-999479]##A session is considered “new” when it is only
a prospective session and has not been established. Because HTTP is a
request-response based protocol, an HTTP session is considered to be new
until a client “joins” it. A client joins a session when session
tracking information has been returned to the server indicating that a
session has been established. Until the client joins a session, it
cannot be assumed that the next request from the client will be
recognized as part of a session.

[#50626609_pgfId-999480]##The session is considered to be “new” if
either of the following is true:

[#50626609_pgfId-999481]##The client does not yet know about the session

[#50626609_pgfId-999483]##The client chooses not to join a session.

[#50626609_pgfId-999484]##These conditions define the situation where
the servlet container has no mechanism by which to associate a request
with a previous request.

[#50626609_pgfId-999485]##A Servlet Developer must design his
application to handle a situation where a client has not, can not, or
will not join a session.

[#50626609_pgfId-1000265]##Associated with each session, there is a
string containing a unique identifier, which is referred to as the
session id. The value of the session id can be obtained by calling
_javax.servlet.http.HttpSession.getId()_ and can be changed after
creation by invoking
_javax.servlet.http.HttpServletRequest.changeSessionId()_ .

==== [#50626609_pgfId-999488]##

image:servlet-27.gif[image]

[#50626609_marker-999486]##[#50626609_38534]##Session Scope

[#50626609_pgfId-999489]## _HttpSession_ objects must be scoped at the
application (or servlet context) level. The underlying mechanism, such
as the cookie used to establish the session, can be the same for
different contexts, but the object referenced, including the attributes
in that object, must never be shared between contexts by the container.

[#50626609_pgfId-999490]##To illustrate this requirement with an
example: if a servlet uses the _RequestDispatcher_ to call a servlet in
another Web application, any sessions created for and visible to the
servlet being called must be different from those visible to the calling
servlet.

[#50626609_pgfId-999491]##Additionally, sessions of a context must be
resumable by requests into that context regardless of whether their
associated context was being accessed directly or as the target of a
request dispatch at the time the sessions were created.

==== [#50626609_pgfId-999492]##

image:servlet-27.gif[image]

Binding Attributes into a Session

[#50626609_pgfId-999493]##A servlet can bind an object attribute into an
_HttpSession_ implementation by name. Any object bound into a session is
available to any other servlet that belongs to the same _ServletContext_
and handles a request identified as being a part of the same session.

[#50626609_pgfId-999494]##Some objects may require notification when
they are placed into, or removed from, a session. This information can
be obtained by having the object implement the
_HttpSessionBindingListener_ interface. This interface defines the
following methods that will signal an object being bound into, or being
unbound from, a session.

[#50626609_pgfId-999495]## _valueBound_

[#50626609_pgfId-999496]## _valueUnbound_

[#50626609_pgfId-999497]##The _valueBound_ method must be called before
the object is made available via the _getAttribute_ method of the
_HttpSession_ interface. The _valueUnbound_ method must be called after
the object is no longer available via the _getAttribute_ method of the
_HttpSession_ interface.

==== [#50626609_pgfId-999498]##

image:servlet-27.gif[image]

[#50626609_33387]##Session Timeouts

[#50626609_pgfId-999499]##In the HTTP protocol, there is no explicit
termination signal when a client is no longer active. This means that
the only mechanism that can be used to indicate when a client is no
longer active is a time out period.

[#50626609_pgfId-999500]##The default time out period for sessions is
defined by the servlet container and can be obtained via the
_getSessionTimeout_ method of the _ServletContext_ interface or the
_getMaxInactiveInterval_ method of the _HttpSession_ interface. This
time out can be changed by the Developer using the _setSessionTimeout_
method of the _ServletContext_ interface or the _setMaxInactiveInterval_
method of the _HttpSession_ interface. The time out periods used by
session timeout methods are defined in minutes. The time out periods
used by max active interval methods are defined in seconds. See the
javadoc for _setSessionTimeout_ for additional normative requirements.
By definition, if the time out period for a session is set to _0 or
lesser value_ , the session will never expire. The session invalidation
will not take effect until all servlets using that session have exited
the service method. Once the session invalidation is initiated, a new
request must not be able to see that session.

==== [#50626609_pgfId-999501]##

image:servlet-27.gif[image]

Last Accessed Times

[#50626609_pgfId-999502]##The _getLastAccessedTime_ method of the
_HttpSession_ interface allows a servlet to determine the last time the
session was accessed before the current request. The session is
considered to be accessed when a request that is part of the session is
first handled by the servlet container.

==== [#50626609_pgfId-999504]##

image:servlet-27.gif[image]

[#50626609_54577]##Important Session Semantics

===== [#50626609_pgfId-999506]##[#50626609_]##Threading Issues

[#50626609_pgfId-999507]##Multiple servlets executing request threads
may have active access to the same session object at the same time. The
container must ensure that manipulation of internal data structures
representing the session attributes is performed in a thread safe
manner. The Developer has the responsibility for thread safe access to
the attribute objects themselves. This will protect the attribute
collection inside the _HttpSession_ object from concurrent access,
eliminating the opportunity for an application to cause that collection
to become corrupted. Unless explicitly stated elsewhere in the
specification (for example link:servlet.htm#50626609_[See Threading
Issues] for session objects), objects vended from the request or
response must be assumed to be non thread safe. This includes, but is
not limited to the _PrintWriter_ returned from
_ServletResponse.getWriter()_ and the _OutputStream_ returned from
_ServletResponse.getOutputStream()_ . __

===== [#50626609_pgfId-999508]##Distributed Environments

[#50626609_pgfId-999509]##Within an application marked as distributable,
all requests that are part of a session must be handled by one JVM at a
time. The container must be able to handle all objects placed into
instances of the _HttpSession_ class using the _setAttribute_ or
_putValue_ methods appropriately. The following restrictions are imposed
to meet these conditions:

[#50626609_pgfId-999510]##The container must accept objects that
implement the _Serializable_ interface.

[#50626609_pgfId-999511]##The container may choose to support storage of
other designated objects in the _HttpSession_ , such as references to
Enterprise JavaBeans components and transactions.

[#50626609_pgfId-999512]##Migration of sessions will be handled by
container-specific facilities.

[#50626609_pgfId-999513]##The distributed servlet container must throw
an _IllegalArgumentException_ for objects where the container cannot
support the mechanism necessary for migration of the session storing
them.

[#50626609_pgfId-999514]##The distributed servlet container must support
the mechanism necessary for migrating objects that implement
_Serializable_ .

[#50626609_pgfId-999515]##These restrictions mean that the Developer is
ensured that there are no additional concurrency issues beyond those
encountered in a non-distributed container.

[#50626609_pgfId-999516]##The Container Provider can ensure scalability
and quality of service features like load-balancing and failover by
having the ability to move a session object, and its contents, from any
active node of the distributed system to a different node of the system.

[#50626609_pgfId-999517]##If distributed containers persist or migrate
sessions to provide quality of service features, they are not restricted
to using the native JVM Serialization mechanism for serializing
_HttpSessions_ and their attributes. Developers are not guaranteed that
containers will call _readObject_ and _writeObject_ methods on session
attributes if they implement them, but are guaranteed that the
_Serializable_ closure of their attributes will be preserved.

[#50626609_pgfId-999518]##Containers must notify any session attributes
implementing the _HttpSessionActivationListener_ during migration of a
session. They must notify listeners of passivation prior to
serialization of a session, and of activation after deserialization of a
session.

[#50626609_pgfId-999519]##Application Developers writing distributed
applications should be aware that since the container may run in more
than one Java virtual machine, the developer cannot depend on static
variables for storing an application state. They should store such
states using an enterprise bean or a database.

===== [#50626609_pgfId-999520]##Client Semantics

[#50626609_pgfId-999521]##Due to the fact that cookies or SSL
certificates are typically controlled by the Web browser process and are
not associated with any particular window of the browser, requests from
all windows of a client application to a servlet container might be part
of the same session. For maximum portability, the Developer should
always assume that all windows of a client are participating in the same
session.

[#50626609_pgfId-998874]## 

== [#50626585_pgfId-1011337]## 

=== [#50626585_pgfId-1011339]##

image:servlet-28.gif[image]

[#50626585_94869]##Annotations and pluggability

image:servlet-29.gif[image]

[#50626585_pgfId-1001387]##This chapter describes the use of annotations
and other enhancements to enable pluggability of frameworks and
libraries for use within a web application.

==== [#50626585_pgfId-1001389]##

image:servlet-30.gif[image]

[#50626585_45908]##Annotations and pluggability

[#50626585_pgfId-1003125]##In a web application, classes using
annotations will have their annotations processed only if they are
located in the _WEB-INF/classes_ directory, or if they are packaged in a
jar file located in _WEB-INF/lib_ within the application.

[#50626585_pgfId-1012017]##The web application deployment descriptor
contains a “ _metadata-complete_ ” attribute on the _web-app_ element.
This attribute defines whether this deployment descriptor and any web
fragments, if any, are complete, or whether the class files available to
this module and packaged with this application should be examined for
annotations that specify deployment information. Deployment information,
in this sense, refers to any information that could have been specified
by the deployment descriptor or fragments, but instead is specified as
annotations on classes.

[#50626585_pgfId-1013250]##If the value of the “ _metadata-complete_ ”
attribute is specified as _true_ , the deployment tool must ignore any
annotations that specify such deployment information in the class files
packaged in the web application. Please see
link:servlet.htm#50626585_83472[See Assembling the descriptor from
web.xml, web-fragment.xml and annotations],
link:servlet.htm#50626585_72500[See Processing annotations and
fragments] and link:servlet.htm#50626607_43555[See Handling of
metadata-complete] for additional details on the handling of “
_metadata-complete_ ”.

[#50626585_pgfId-1012733]##If the “ _metadata-complete_ ” attribute is
not specified, or its value is _false_ , the deployment tool must
examine the class files of the application for such annotations. Note
that a _true_ value for “ _metadata-complete_ ” does _not_ preempt the
processing of _all_ annotations, only those listed below.

[#50626585_pgfId-1012025]##Annotations that do not have equivalents in
the deployment XSD include _javax.servlet.annotation.HandlesTypes_ and
all of the CDI-related annotations. These annotations must be processed
during annotation scanning, regardless of the value of “
_metadata-complete_ ”.

[#50626585_pgfId-1015147]##When EJBs are packaged in a _.war_ file, and
the _.war_ file contains an _ejb-jar.xml_ file, the _metadata-complete_
attribute of the _ejb-jar.xml_ file determines the processing of the
annotations for enterprise beans. If there is no _ejb-jar.xml_ file, and
the _web.xml_ specifies the _metadata-complete_ attribute as “ _true_ ”,
these annotations are processed as though there were an _ejb-jar.xml_
file whose _metadata-complete_ attribute was specified as “ _true_ ”.
See the Enterprise JavaBeans™ specification for requirements pertaining
to annotations for EJBs.

[#50626585_pgfId-1012130]##The following are the annotations in
javax.servlet. All of these have corresponding deployment descriptor
metadata covered by the Web xsd.

[#50626585_pgfId-1012144]##From _javax.servlet.annotation_ :

[#50626585_pgfId-1012145]## _HttpConstraint_

[#50626585_pgfId-1012146]## _HttpMethodConstraint_

[#50626585_pgfId-1012234]## _MultipartConfig_

[#50626585_pgfId-1012240]## _ServletSecurity_

[#50626585_pgfId-1012149]## _WebFilter_

[#50626585_pgfId-1012150]## _WebInitParam_

[#50626585_pgfId-1012151]## _WebListener_

[#50626585_pgfId-1012152]## _WebServlet_

[#50626585_pgfId-1012154]##The following annotations from related
packages are also covered by the _web.xml_ and associated fragments.

[#50626585_pgfId-1012157]##From _javax.annotation_ :

[#50626585_pgfId-1012275]## _PostConstruct_

[#50626585_pgfId-1012159]## _PreDestroy_

[#50626585_pgfId-1012160]## _Resource_

[#50626585_pgfId-1012161]## _Resources_

[#50626585_pgfId-1014067]##From _javax.annotation.security_ :

[#50626585_pgfId-1012162]## _DeclareRoles_

[#50626585_pgfId-1012163]## _RunAs_

[#50626585_pgfId-1014110]##From _javax.annotation.sql_ : __

[#50626585_pgfId-1012164]## _DataSourceDefinition_

[#50626585_pgfId-1012165]## _DataSourceDefinitions_

[#50626585_pgfId-1012174]##From _javax.ejb_ :

[#50626585_pgfId-1012175]## _EJB_

[#50626585_pgfId-1012176]## _EJBs_

[#50626585_pgfId-1012662]##From _javax.jms_ :

[#50626585_pgfId-1012663]## _JMSConnectionFactoryDefinition_

[#50626585_pgfId-1014298]## _JMSConnectionFactoryDefinitions_

[#50626585_pgfId-1012666]## _JMSDestinationDefinition_

[#50626585_pgfId-1014489]##JMSDestinationDefinitions

[#50626585_pgfId-1014490]##From _javax.mail_ :

[#50626585_pgfId-1014491]## _MailSessionDefinition_

[#50626585_pgfId-1014335]## _MailSessionDefinitions_

[#50626585_pgfId-1012189]##From _javax.persistence_ :

[#50626585_pgfId-1012190]## _PersistenceContext_

[#50626585_pgfId-1014476]## _PersistenceContexts_

[#50626585_pgfId-1012192]## _PersistenceUnit_

[#50626585_pgfId-1014360]##PersistenceUnits __

[#50626585_pgfId-1012195]##From _javax.resource_ :

[#50626585_pgfId-1012196]## _AdministeredObjectDefinition_

[#50626585_pgfId-1012197]## _AdministeredObjectDefinitions_

[#50626585_pgfId-1012198]## _ConnectionFactoryDefinition_

[#50626585_pgfId-1014455]## _ConnectionFactoryDefinitions_

[#50626585_pgfId-1014459]##All annotations in the following packages:

[#50626585_pgfId-1014421]## _javax.jws_

[#50626585_pgfId-1014422]## _javax.jws.soap_

[#50626585_pgfId-1014423]## _javax.xml.ws_

[#50626585_pgfId-1014424]## _javax.xml.ws.soap_

[#50626585_pgfId-1014425]## _javax.xml.ws.spi_

[#50626585_pgfId-1014416]##Following are the annotations that MUST be
supported by a Servlet compliant web container.

===== [#50626585_pgfId-1001326]##[#50626585_69390]##@WebServlet

[#50626585_pgfId-1003203]##This annotation is used to define a _Servlet_
component in a web application. This annotation is specified on a class
and contains metadata about the _Servlet_ being declared. The
_urlPattern_ s or the _value_ attribute on the annotation MUST be
present. All other attributes are optional with default settings (see
javadocs for more details). It is recommended to use _value_ when the
only attribute on the annotation is the url pattern and to use the
_urlPatterns_ attribute when the other attributes are also used. It is
illegal to have both _value_ and _urlPatterns_ attribute used together
on the same annotation. The default name of the _Servlet_ if not
specified is the fully qualified class name. The annotated servlet MUST
specify at least one url pattern to be deployed. If the same servlet
class is declared in the deployment descriptor under a different name, a
new instance of the servlet MUST be instantiated. If the same servlet
class is added with a different name to the _ServletContext_ via the
programmatic API defined in link:servlet.htm#50626599_43038[See
Programmatically adding and configuring Servlets], the attribute values
declared via the _@WebServlet_ annotation MUST be ignored and a new
instance of the servlet with the name specified MUST be created.

[#50626585_pgfId-1003226]##Classes annotated with _@WebServlet_ class
MUST extend the _javax.servlet.http.HttpServlet_ class.

[#50626585_pgfId-1001616]##Following is an example of how this
annotation would be used.

[#50626585_pgfId-1002262]##@WebServlet Annotation Example

[#50626585_pgfId-1002253]##@WebServlet(”/foo”)

[#50626585_pgfId-1002282]##public class CalculatorServlet extends
HttpServlet\{

[#50626585_pgfId-1001580]## //...

[#50626585_pgfId-1001630]##}

[#50626585_pgfId-1001551]##Following is an example of how this
annotation would be used with some more of the attributes specified.

[#50626585_pgfId-1001669]## 

[#50626585_pgfId-1001634]##@WebServlet annotation example using other
annotation attributes specified

[#50626585_pgfId-1001640]##@WebServlet(name=”MyServlet”,
urlPatterns=\{"/foo", "/bar"})

[#50626585_pgfId-1001641]##public class SampleUsingAnnotationAttributes
extends HttpServlet\{

[#50626585_pgfId-1001644]## public void doGet(HttpServletRequest req,
HttpServletResponse res) \{

[#50626585_pgfId-1001645]## 

[#50626585_pgfId-1001646]## }

[#50626585_pgfId-1001647]##}

[#50626585_pgfId-1001635]## 

===== [#50626585_pgfId-999590]##[#50626585_85217]##@WebFilter

[#50626585_pgfId-1001508]##This annotation is used to define a _Filter_
in a web application. This annotation is specified on a class and
contains metadata about the filter being declared. The default name of
the _Filter_ if not specified is the fully qualified class name. The
_urlPatterns_ attribute, _servletNames_ attribute or the _value_
attribute of the annotation MUST be specified. All other attributes are
optional with default settings (see javadocs for more details). It is
recommended to use _value_ when the only attribute on the annotation is
the url pattern and to use the _urlPatterns_ attribute when the other
attributes are also used. It is illegal to have both _value_ and
_urlPatterns_ attribute used together on the same annotation.

[#50626585_pgfId-1003227]##Classes annotated with _@WebFilter_ MUST
implement _javax.servlet.Filter_ .

[#50626585_pgfId-1001520]##Following is an example of how this
annotation would be used.

[#50626585_pgfId-1001506]## _@WebFilter_ annotation example

[#50626585_pgfId-1001689]##@WebFilter(“/foo”)

[#50626585_pgfId-1001694]##public class MyFilter implements Filter \{

[#50626585_pgfId-1001695]## public void doFilter(HttpServletRequest req,
HttpServletResponse res)

[#50626585_pgfId-1001699]## \{

[#50626585_pgfId-1001698]## ...

[#50626585_pgfId-1001697]## }

[#50626585_pgfId-1001696]##}

===== [#50626585_pgfId-999611]##@WebInitParam

[#50626585_pgfId-1001700]##This annotation is used to specify any init
parameters that must be passed to the _Servlet_ or the _Filter_ . It is
an attribute of the _WebServlet_ and _WebFilter_ annotation.

===== [#50626585_pgfId-999626]##[#50626585_48654]##@WebListener

[#50626585_pgfId-1004381]##The _WebListener_ annotation is used to
annotate a listener to get events for various operations on the
particular web application context. Classes annotated with
_@WebListener_ MUST implement one of the following interfaces:

[#50626585_pgfId-1004405]## _javax.servlet.ServletContextListener_

[#50626585_pgfId-1004413]##
_javax.servlet.ServletContextAttributeListener_

[#50626585_pgfId-1004418]## _javax.servlet.ServletRequestListener_

[#50626585_pgfId-1004425]##
_javax.servlet.ServletRequestAttributeListener_

[#50626585_pgfId-1004430]## _javax.servlet.http.HttpSessionListener_

[#50626585_pgfId-1004437]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626585_pgfId-1011311]## _javax.servlet.http.HttpSessionIdListener_

[#50626585_pgfId-1004407]##An example:

[#50626585_pgfId-1001706]##@WebListener

[#50626585_pgfId-1001707]##public class MyListener implements
ServletContextListener\{

[#50626585_pgfId-1001708]## public void
contextInitialized(ServletContextEvent sce) \{

[#50626585_pgfId-1001709]## ServletContext sc = sce.getServletContext();

[#50626585_pgfId-1001710]## sc.addServlet("myServlet", "Sample servlet",
"foo.bar.MyServlet", null, -1);

[#50626585_pgfId-1001711]## sc.addServletMapping("myServlet", new
String[] \{ "/urlpattern/*" });

[#50626585_pgfId-1001730]## }

[#50626585_pgfId-998874]##}

===== [#50626585_pgfId-1006577]##[#50626585_71574]##@MultipartConfig

[#50626585_pgfId-1006581]##This annotation, when specified on a
_Servlet_ , indicates that the request it expects is of type
_multipart/form-data_ . The _HttpServletRequest_ object of the
corresponding servlet MUST make available the mime attachments via the
_getParts_ and _getPart_ methods to iterate over the various mime
attachments. The _location_ attribute of the
_javax.servlet.annotation.MultipartConfig_ and the _<location>_ element
of the _<multipart-config>_ is interpreted as an absolute path and
defaults to the value of the _javax.servlet.context.tempdir_ . If a
relative path is specified, it will be relative to the _tempdir_
location. The test for absolute path vs relative path MUST be done via
_java.io.File.isAbsolute_ .

===== [#50626585_pgfId-1003416]##Other annotations / conventions

[#50626585_pgfId-1006582]##In addition to these annotations all the
annotations defined in link:servlet.htm#50626607_45908[See Annotations
and Resource Injection] will continue to work in the context of these
new annotations.

[#50626585_pgfId-1003420]##By default all applications will have
_index.htm(l)_ and _index.jsp_ in the list of _welcome-file-list_ . The
descriptor may to be used to override these default settings.

[#50626585_pgfId-1002294]##The order in which the Listeners, Servlets
are loaded from the various framework jars / classes in the
_WEB-INF/classes_ or _WEB-INF/lib_ is unspecified when using
annotations. If ordering is important then look at the section for
modularity of web.xml and ordering of _web.xml_ and _web-fragment.xml_
below. The order can be specified in the deployment descriptor only.

==== [#50626585_pgfId-1001739]##

image:servlet-30.gif[image]

[#50626585_57616]##Pluggability

===== [#50626585_pgfId-1001794]##[#50626585_77230]##Modularity of web.xml

[#50626585_pgfId-1001745]## Using the annotations defined above makes
the use of web.xml optional. However for overriding either the default
values or the values set via annotations, the deployment descriptor is
used. As before, if the _metadata-complete_ element is set to _true_ in
the _web.xml_ descriptor, annotations that specify deployment
information present in the class files and web-fragments bundled in jars
will not be processed. It implies that all the metadata for the
application is specified via the _web.xml_ descriptor.

[#50626585_pgfId-1007180]##For better pluggability and less
configuration for developers, we introduce the notion of web module
deployment descriptor fragments (web fragment). A web fragment is a part
or all of the _web.xml_ that can be specified and included in a library
or framework jar's _META-INF_ directory. A plain old jar file in the
WEB-INF/lib directory with no web-fragment.xml is also considered a
fragment. Any annotations specified in it will be processed according to
the rules defined in 8.2.3. The container will pick up and use the
configuration as per the rules defined below.

[#50626585_pgfId-1001746]##A web fragment is a logical partitioning of
the web application in such a way that the frameworks being used within
the web application can define all the artifacts without asking
developers to edit or add information in the web.xml. It can include
almost all the same elements that the web.xml descriptor uses. However
the top level element for the descriptor MUST be web-fragment and the
corresponding descriptor file MUST be called web-fragment.xml. The
ordering related elements also differ between the web-fragment.xml and
web.xml See the corresponding schema for web-fragments in the deployment
descriptor section in Chapter 14.

[#50626585_pgfId-1001749]##If a framework is packaged as a jar file and
has metadata information in the form of deployment descriptor then the
_web-fragment.xml_ descriptor must be in the _META-INF/_ directory of
the jar file.

[#50626585_pgfId-1003343]##If a framework wants its
_META-INF/web-fragment.xml_ honored in such a way that it augments a web
application's _web.xml_ , the framework must be bundled within the web
application's _WEB-INF/lib_ directory. In order for any other types of
resources (e.g., class files) of the framework to be made available to a
web application, it is sufficient for the framework to be present
anywhere in the classloader delegation chain of the web application. In
other words, only JAR files bundled in a web application's _WEB-INF/lib_
directory, but not those higher up in the class loading delegation
chain, need to be scanned for _web-fragment.xml_

[#50626585_pgfId-1003337]##During deployment the container is
responsible for scanning the location specified above and discovering
the web-fragment.xml and processing them. The requirements about name
uniqueness that exist currently for a single web.xml also apply to the
union of a web.xml and all applicable web-fragment.xml files.

[#50626585_pgfId-1002107]##An example of what a library or framework can
include is shown below

[#50626585_pgfId-1002108]## 

[#50626585_pgfId-1002111]##<web-fragment>

[#50626585_pgfId-1002112]## <servlet>

[#50626585_pgfId-1002113]## <servlet-name>welcome</servlet-name>

[#50626585_pgfId-1002114]## <servlet-class>

[#50626585_pgfId-1002115]## WelcomeServlet

[#50626585_pgfId-1002116]## </servlet-class>

[#50626585_pgfId-1002117]## </servlet>

[#50626585_pgfId-1002118]## <listener>

[#50626585_pgfId-1002119]## <listener-class>

[#50626585_pgfId-1002120]## RequestListener

[#50626585_pgfId-1002121]## </listener-class>

[#50626585_pgfId-1002122]## </listener>

[#50626585_pgfId-1002109]##</web-fragment>

[#50626585_pgfId-1002133]## 

[#50626585_pgfId-1003405]##The above web-fragment.xml would be included
in the META-INF/ directory of the framework’s jar file. The order in
which configuration from web-fragment.xml and annotations should be
applied is undefined. If ordering is an important aspect for a
particular application please see rules defined below on how to achieve
the order desired.

===== [#50626585_pgfId-1003406]##[#50626585_69625]##Ordering of web.xml and web-fragment.xml

[#50626585_pgfId-1004727]##Since the specification allows the
application configuration resources to be composed of multiple
configuration files ( _web.xml_ and _web-fragment.xml_ ), discovered and
loaded from several different places in the application, the question of
ordering must be addressed. This section specifies how configuration
resource authors may declare the ordering requirements of their
artifacts.

[#50626585_pgfId-1004729]##A _web-fragment.xml_ may have a top level
_<name>_ element of type _javaee:java-identifierType_ . There can only
be one _<name>_ element in a _web-fragment.xml_ . If a _<name>_ element
is present, it must be considered for the ordering of artifacts (unless
the duplicate name exception applies, as described below).

[#50626585_pgfId-1004731]##Two cases must be considered to allow
application configuration resources to express their ordering
preferences.

[#50626585_pgfId-1004733]##[#50626585_47263]##Absolute ordering: an
_<absolute-ordering>_ element in the _web.xml_ . There can only be one
_<absolute-ordering>_ element in a _web.xml_ .

[#50626585_pgfId-1004904]## In this case, ordering preferences that
would have been handled by case 2 below must be ignored.

[#50626585_pgfId-1006935]##The _web.xml_ and WEB-INF/classes MUST be
processed before any of the web-fragments listed in the
_absolute-ordering_ element.

[#50626585_pgfId-1004918]##Any _<name>_ element direct children of the
_<absolute-ordering>_ MUST be interpreted as indicating the absolute
ordering in which those named web-fragments, which may or may not be
present, must be processed.

[#50626585_pgfId-1007120]##[#50626585_94272]##The _<absolute-ordering>_
element may contain zero or one _<others/>_ element. The required action
for this element is described below. If the _<absolute-ordering>_
element does not contain an _<others/>_ element, any web-fragment not
specifically mentioned within _<name/>_ elements MUST be ignored.
Excluded jars are not scanned for annotated servlets, filters or
listeners. However, if a servlet, filter or listener from an excluded
jar is listed in _web.xml_ or a non-excluded _web-fragment.xml_ , then
it's annotations will apply unless otherwise excluded by
_metadata-complete_ . _ServletContextListeners_ discovered in TLD files
of excluded jars are not able to configure filters and servlets using
the programmatic APIs. Any attempt to do so will result in an
_IllegalStateException_ . If a discovered _ServletContainerInitializer_
is loaded from an excluded jar, it will be ignored. Irrespective of the
setting of _metadata-complete_ , jars excluded by _<absolute-ordering>_
elements are not scanned for classes to be handled by any
_ServletContainerInitializer_ .

[#50626585_pgfId-1004941]##Duplicate name exception: if, when traversing
the children of _<absolute-ordering>_ , multiple children with the same
_<name>_ element are encountered, only the first such occurrence must be
considered.

[#50626585_pgfId-1010377]##Relative ordering: an _<ordering>_ element
within the _web-fragment.xml_ . There can only be one _<ordering>_
element in a _web-fragment.xml_ .

[#50626585_pgfId-1010378]##A _web-fragment.xml_ may have an _<ordering>_
element. If so, this element must contain zero or one _<before>_ element
and zero or one _<after>_ element. The meaning of these elements is
explained below.

[#50626585_pgfId-1004989]##The _web.xml_ and WEB-INF/classes MUST be
processed before any of the web-fragments listed in the _ordering_
element.

[#50626585_pgfId-1010383]##Duplicate name exception: if, when traversing
the web-fragments, multiple members with the same _<name>_ element are
encountered, the application must log an informative error message
including information to help fix the problem, and must fail to deploy.
For example, one way to fix this problem is for the user to use absolute
ordering, in which case relative ordering is ignored.

[#50626585_pgfId-1005012]##Consider this abbreviated but illustrative
example. 3 web-fragments - _MyFragment1_ , _MyFragment2_ and
_MyFragment3_ are part of the application that also includes a _web.xml_
.

[#50626585_pgfId-1004745]##web-fragment.xml

[#50626585_pgfId-1004746]##<web-fragment>

[#50626585_pgfId-1004747]## <name>MyFragment1</name>

[#50626585_pgfId-1004748]##
<ordering><after><name>MyFragment2</name></after></ordering>

[#50626585_pgfId-1004749]## ...

[#50626585_pgfId-1004750]##</web-fragment>

[#50626585_pgfId-1004751]## 

[#50626585_pgfId-1004752]##web-fragment.xml

[#50626585_pgfId-1004753]##<web-fragment>

[#50626585_pgfId-1004754]## <name>MyFragment2</name>

[#50626585_pgfId-1004755]## ..

[#50626585_pgfId-1004756]##</web-fragment>

[#50626585_pgfId-1005017]## 

[#50626585_pgfId-1005018]##web-fragment.xml

[#50626585_pgfId-1004758]##<web-fragment>

[#50626585_pgfId-1004759]## <name>MyFragment3</name>

[#50626585_pgfId-1004760]##
<ordering><before><others/></before></ordering>

[#50626585_pgfId-1004761]## ..

[#50626585_pgfId-1004762]##</web-fragment>

[#50626585_pgfId-1004763]## 

[#50626585_pgfId-1004764]##web.xml

[#50626585_pgfId-1004765]##<web-app>

[#50626585_pgfId-1004767]## ...

[#50626585_pgfId-1004768]##</web-app>

[#50626585_pgfId-1004770]##In this example the processing order will be

[#50626585_pgfId-1006797]## _web.xml_

[#50626585_pgfId-1006798]## _MyFragment3_

[#50626585_pgfId-1006799]## _MyFragment2_

[#50626585_pgfId-1006800]## _MyFragment1_

[#50626585_pgfId-1004777]##The preceding example illustrates some, but
not all, of the following principles.

[#50626585_pgfId-1004779]## _<before>_ means the document must be
ordered before the document with the name matching what is specified
within the nested _<name>_ element.

[#50626585_pgfId-1005039]## _<after>_ means the document must be ordered
after the document with the name matching what is specified within the
nested _<name>_ element.

[#50626585_pgfId-1005045]##There is a special element _<others/>_ which
may be included zero or one time within the _<before>_ or _<after>_
element, or zero or one time directly within the _<absolute-ordering>_
element. The _<others/>_ element must be handled as follows.

[#50626585_pgfId-1005057]## If the _<before>_ element contains a nested
_<others/>_ , the document will be moved to the beginning of the list of
sorted documents. If there are multiple documents stating
_<before><others/>_ , they will all be at the beginning of the list of
sorted documents, but the ordering within the group of such documents is
unspecified.

[#50626585_pgfId-1005072]##If the _<after>_ element contains a nested
_<others/>_ , the document will be moved to the end of the list of
sorted documents. If there are multiple documents requiring
_<after><others/>_ , they will all be at the end of the list of sorted
documents, but the ordering within the group of such documents is
unspecified.

[#50626585_pgfId-1005084]##Within a _<before>_ or _<after>_ element, if
an _<others/>_ element is present, but is not the only _<name>_ element
within its parent element, the other elements within that parent must be
considered in the ordering process.

[#50626585_pgfId-1005096]##If the _<others/>_ element appears directly
within the _<absolute-ordering>_ element, the runtime must ensure that
any web-fragments not explicitly named in the _<absolute-ordering>_
section are included at that point in the processing order.

[#50626585_pgfId-1005103]##If a _web-fragment.xml_ file does not have an
_<ordering>_ or the _web.xml_ does not have an _<absolute-ordering>_
element the artifacts are assumed to not have any ordering dependency.

[#50626585_pgfId-1005112]##If the runtime discovers circular references,
an informative message must be logged, and the application must fail to
deploy. Again, one course of action the user may take is to use absolute
ordering in the _web.xml_ .

[#50626585_pgfId-1005118]##The previous example can be extended to
illustrate the case when the _web.xml_ contains an ordering section.

[#50626585_pgfId-1004790]##web.xml

[#50626585_pgfId-1004791]##<web-app>

[#50626585_pgfId-1004792]##<absolute-ordering>

[#50626585_pgfId-1004794]## <name>MyFragment3</name>

[#50626585_pgfId-1004795]## <name>MyFragment2</name>

[#50626585_pgfId-1004796]## </absolute-ordering>

[#50626585_pgfId-1004797]## ...

[#50626585_pgfId-1004798]##</web-app>

[#50626585_pgfId-1005339]## 

[#50626585_pgfId-1005125]##In this example, the ordering for the various
elements will be

[#50626585_pgfId-1004801]## _web.xml_

[#50626585_pgfId-1004802]## _MyFragment3_

[#50626585_pgfId-1004803]## _MyFragment2_

[#50626585_pgfId-1004805]##Some additional example scenarios are
included below. All of these apply to relative ordering and not absolute
ordering

[#50626585_pgfId-1004807]##Document A:

[#50626585_pgfId-1006219]## _<after>_

[#50626585_pgfId-1006650]## _<others/>_

[#50626585_pgfId-1006651]## _<name>_

[#50626585_pgfId-1006652]## _C_

[#50626585_pgfId-1006653]## _</name>_

[#50626585_pgfId-1006654]## _</after>_

[#50626585_pgfId-1004808]## 

[#50626585_pgfId-1006657]##Document B

[#50626585_pgfId-1006223]## _<before>_

[#50626585_pgfId-1006655]## _<others/>_

[#50626585_pgfId-1006656]## _</before>_

[#50626585_pgfId-1004809]##Document C:

[#50626585_pgfId-1006229]## _<after>_

[#50626585_pgfId-1006658]## _<others/>_

[#50626585_pgfId-1006659]## _</after>_

[#50626585_pgfId-1004810]##Document D: no ordering

[#50626585_pgfId-1004811]##Document E: no ordering

[#50626585_pgfId-1004812]##Document F:

[#50626585_pgfId-1006241]##< _before>_

[#50626585_pgfId-1006660]## _<others/>_

[#50626585_pgfId-1006661]## _<name>_

[#50626585_pgfId-1006662]## _B_

[#50626585_pgfId-1006663]## _</name>_

[#50626585_pgfId-1006664]## _</before>_

[#50626585_pgfId-1004814]##Resulting parse order:

[#50626585_pgfId-1006247]## _web.xml_ , F, B, D, E, C, A.

[#50626585_pgfId-1004816]##Document <no id>:

[#50626585_pgfId-1006250]##<after>

[#50626585_pgfId-1006665]## <others/>

[#50626585_pgfId-1006666]##</after> +
<before>

[#50626585_pgfId-1006667]## <name>

[#50626585_pgfId-1006668]## C

[#50626585_pgfId-1006669]## </name>

[#50626585_pgfId-1006670]##</before>

[#50626585_pgfId-1004818]##Document B:

[#50626585_pgfId-1006269]##<before>

[#50626585_pgfId-1006671]## <others/>

[#50626585_pgfId-1006672]##</before>

[#50626585_pgfId-1004819]## 

[#50626585_pgfId-1006673]##Document C: no ordering

[#50626585_pgfId-1004820]##Document D:

[#50626585_pgfId-1006277]##<after>

[#50626585_pgfId-1006674]## <others/>

[#50626585_pgfId-1006675]##</after>

[#50626585_pgfId-1004821]##Document E:

[#50626585_pgfId-1006278]##<before>

[#50626585_pgfId-1006676]## <others/>

[#50626585_pgfId-1006677]##</before>

[#50626585_pgfId-1004822]##Document F: no ordering

[#50626585_pgfId-1004824]##Resulting parse order can be one of the
following:

[#50626585_pgfId-1005518]##B, E, F, <no id>, C, D

[#50626585_pgfId-1005557]##B, E, F, <no id>, D, C

[#50626585_pgfId-1005563]##E, B, F, <no id>, C, D

[#50626585_pgfId-1005564]##E, B, F, <no id>, D, C

[#50626585_pgfId-1005558]##E, B, F, D, <no id>, C

[#50626585_pgfId-1005559]##E, B, F, D, <no id>, D

[#50626585_pgfId-1005550]##Document A:

[#50626585_pgfId-1006288]##<after>

[#50626585_pgfId-1006678]## <name>

[#50626585_pgfId-1006679]## B

[#50626585_pgfId-1006680]## </name>

[#50626585_pgfId-1006681]##</after>

[#50626585_pgfId-1005551]##Document B: no ordering

[#50626585_pgfId-1004829]##Document C:

[#50626585_pgfId-1006289]##<before>

[#50626585_pgfId-1006682]## <others/>

[#50626585_pgfId-1006683]##</before>

[#50626585_pgfId-1004830]##Document D: no ordering

[#50626585_pgfId-1004725]##Resulting parse order: C, B, D, A. The parse
order could also be: C, D, B, A or C, B, A, D

===== [#50626585_pgfId-1007270]##[#50626585_83472]##Assembling the descriptor from web.xml, web-fragment.xml and annotations

[#50626585_pgfId-1007271]##If the order in which the listeners,
servlets, filters are invoked is important to an application then a
deployment descriptor must be used. Also, if necessary, the ordering
element defined above can be used. As described above, when using
annotations to define the listeners, servlets and filters, the order in
which they are invoked is unspecified. Below are a set of rules that
apply for assembling the final deployment descriptor for the
application:

[#50626585_pgfId-1005364]##The order for listeners, servlets, filters if
relevant must be specified in either the _web-fragment.xml_ or the
_web.xml_ .

[#50626585_pgfId-1005366]##The ordering will be based on the order in
which they are defined in the descriptor and on the _absolute-ordering_
element in the _web.xml_ or an _ordering_ element in the
_web-fragment.xml_ , if present.

[#50626585_pgfId-1003570]##Filters that match a request are chained in
the order in which they are declared in the _web.xml_ .

[#50626585_pgfId-1003578]##Servlets are initialized either lazily at
request processing time or eagerly during deployment. In the latter
case, they are initialized in the order indicated by their
_load-on-startup_ elements.

[#50626585_pgfId-1003583]##[#50626585_89236]##The listeners are invoked
in the order in which they are declared in the _web.xml_ as specified
below:

[#50626585_pgfId-1006847]## Implementations of
_javax.servlet.ServletContextListener_ are invoked at their
_contextInitialized_ method in the order in which they have been
declared, and at their _contextDestroyed_ method in reverse order.

[#50626585_pgfId-1006878]##Implementations of
_javax.servlet.ServletRequestListener_ are invoked at their
_requestInitialized_ method in the order in which they have been
declared, and at their _requestDestroyed_ method in reverse order.

[#50626585_pgfId-1006887]##Implementations of
_javax.servlet.http.HttpSessionListener_ are invoked at their
_sessionCreated_ method in the order in which they have been declared,
and at their _sessionDestroyed_ method in reverse order.

[#50626585_pgfId-1010758]##The methods of implementation of
_javax.servlet.ServletContextAttributeListener_ ,
_javax.servlet.ServletRequestAttributeListener_ and
_javax.servlet.HttpSessionAttributeListener_ are invoked in the order in
which they are declared when corresponding events are fired.

[#50626585_pgfId-1010759]##If a servlet is disabled using the _enabled_
element introduced in the _web.xml_ then the servlet will not be
available at the _url-pattern_ specified for the servlet.

[#50626585_pgfId-1008394]##The _web.xml_ of the web application has the
highest precedence when resolving conflicts between the _web.xml_ ,
_web-fragment.xml_ and annotations.

[#50626585_pgfId-1007316]##If _metadata-complete_ is not specified in
the descriptors, or is set to _false_ in the deployment descriptor, then
the effective metadata for the application is derived by combining the
metadata present in the annotations and the descriptors. The rules for
merging are specified below -

[#50626585_pgfId-1007329]##Configuration settings in web fragments are
used to augment those specified in the main web.xml in such a way as if
they had been specified in the same web.xml.

{empty}[#50626585_pgfId-1007345]##The order in which configuration
settings of web fragments are added to those in the main web.xml is as
specified above in link:servlet.htm#50626585_69625[See Ordering of
web.xml and web-fragment.xml]

[#50626585_pgfId-1007325]##The _metadata-complete_ attribute when set to
_true_ in the main _web.xml_ , is considered complete and scanning of
annotations and fragments will not occur at deployment time. The
_absolute-ordering_ and _ordering_ elements will be ignored if present.
When set to _true_ on a fragment, the _metadata-complete_ attribute
applies only to scanning of annotations in that particular jar.

[#50626585_pgfId-1007377]##Web fragments are merged into the main
_web.xml_ unless the _metadata-complete_ is set to _true_ . The merging
takes place after annotation processing on the corresponding fragment.

[#50626585_pgfId-1007378]##The following are considered configuration
conflicts when augmenting a _web.xml_ with web fragments:

[#50626585_pgfId-1007360]##Multiple _<init-param>_ elements with the
same _<param-name>_ but different _<param-value>_

[#50626585_pgfId-1007362]##Multiple _<mime-mapping>_ elements with the
same _<extension>_ but different _<mime-type>_

[#50626585_pgfId-1006826]##The above configuration conflicts are
resolved as follows:

[#50626585_pgfId-1006827]##Configuration conflicts between the main
_web.xml_ and a web fragment are resolved such that the configuration in
the _web.xml_ takes precedence.

[#50626585_pgfId-1006707]##Configuration conflicts between two web
fragments, where the element at the center of the conflict is not
present in the main _web.xml_ , will result in an error. An informative
message must be logged, and the application must fail to deploy.

[#50626585_pgfId-1004193]##After the above conflicts have been resolved,
these additional rules are applied

[#50626585_pgfId-1010027]##Elements that may be declared any number of
times are additive across the _web-fragments_ in the resulting _web.xml_
. For example, _<context-param>_ elements with different _<param-name>_
are additive.

[#50626585_pgfId-1010028]##Elements that may be declared any number of
times, if specified in the _web.xml_ overrides the values specified in
the _web-fragments_ with the same name.

[#50626585_pgfId-1010029]##If an element with a minimum occurrence of
zero, and a maximum occurrence of one, is present in a web fragment, and
missing in the main _web.xml_ , the main _web.xml_ inherits the setting
from the web fragment. If the element is present in both the main
_web.xml_ and the web fragment, the configuration setting in the main
_web.xml_ takes precedence. For example, if both the main _web.xml_ and
a web fragment declare the same servlet, and the servlet declaration in
the web fragment specifies a _<load-on-startup>_ element, whereas the
one in the main _web.xml_ does not, then the _<load-on-startup>_ element
from the web fragment will be used in the merged _web.xml_ .

[#50626585_pgfId-1004258]##It is considered an error if an element with
a minimum occurrence of zero, and a maximum occurrence of one, is
specified differently in two web fragments, while absent from the main
_web.xml_ . For example, if two web fragments declare the same servlet,
but with different _<load-on-startup>_ elements, and the same servlet is
also declared in the main _web.xml_ , but without any
_<load-on-startup>_ , then an error must be reported.

[#50626585_pgfId-1004281]## _<welcome-file>_ declarations are additive.

[#50626585_pgfId-1004286]## _<servlet-mapping>_ elements with the same
_<servlet-name>_ are additive across _web-fragments_ .
_<servlet-mapping>_ specified in the _web.xml_ overrides values
specified in the _web-fragments_ with the same _<servlet-name>_ .

[#50626585_pgfId-1004291]## _<filter-mapping>_ elements with the same
_<filter-name>_ are additive across _web-fragments_ . _<filter-mapping>_
specified in the _web.xml_ overrides values specified in the
_web-fragments_ with the same _<filter-name>_ .

[#50626585_pgfId-1004297]##Multiple _<listener>_ elements with the same
_<listener-class>_ are treated as a single _<listener>_ declaration

[#50626585_pgfId-1007398]##The _web.xml_ resulting from the merge is
considered _<distributable>_ only if the _web.xml_ and all the web
fragments are marked as _<distributable>_ .

[#50626585_pgfId-1007399]##The top-level _<icon>_ and it’s children
elements, _<display-name>_ , and _<description>_ elements of a web
fragment are ignored.

[#50626585_pgfId-1007400]## _jsp-property-group_ is additive. It is
recommended that _jsp-config_ element use the _url-pattern_ as opposed
to extension mappings when bundling static resources in the
_META-INF/resources_ directory of a jar file. Further more JSP resources
for a fragment should be in a sub-directory same as the fragment name,
if there exists one. This helps prevent a web-fragment’s
_jsp-property-group_ from affecting the JSPs in the main docroot of the
application and the _jsp-property-group_ from affecting the JSPs in a
fragment’s _META-INF/resources_ directory.

[#50626585_pgfId-1009335]##For all the resource reference elements (
_env-entry, ejb-ref, ejb-local-ref, service-ref, resource-ref,
resource-env-ref, message-destination-ref, persistence-context-ref and
persistence-unit-ref_ ) the following rules apply:

[#50626585_pgfId-1010069]##If any resource reference element is present
in a web fragment, and is missing in the main _web.xml_ , the main
_web.xml_ inherits the value from the web fragment. If the element is
present in both the main _web.xml_ and the web fragment, with the same
name, the _web.xml_ takes precedence. None of the child elements from
the fragment are merged into the main _web.xml_ except for the
_injection-target_ as specified below. For example, if both the main
_web.xml_ and a web fragment declare a _<resource-ref>_ with the same
_<resource-ref-name>_ , the _<resource-ref>_ from the _web.xml_ will be
used without any child elements being merged from the fragment except
_<injection-target>_ as described below.

[#50626585_pgfId-1010110]##If a resource reference element is specified
in two fragments, while absent from the main _web.xml_ , and all the
attributes and child elements of the resource reference element are
identical, the resource reference will be merged into the main _web.xml_
. It is considered an error if a resource reference element has the same
name specified in two fragments, while absent from the main _web.xml_
and the attributes and child elements are not identical in the two
fragments. An error must be reported and the application MUST fail to
deploy. For example, if two web fragments declare a _<resource-ref>_
with the same _<resource-ref-name>_ element but the type in one is
specified as _javax.sql.DataSource_ while the type in the other is that
of a JavaMail resource, it is an error and the application will fail to
deploy

[#50626585_pgfId-1010111]##For resource reference __ element with the
same name _<injection-target>_ elements from the fragments will be
merged into the main _web.xml_ .

[#50626585_pgfId-1010112]##In addition to the merging rules for
_web-fragment.xml_ defined above, the following rules apply when using
the resource reference annotations ( _@Resource_ , _@Resources, @EJB_ ,
_@EJBs, @WebServiceRef, @WebServiceRefs, @PersistenceContext,
@PersistenceContexts,@PersistenceUnit, and @PersistenceUnits_ )

[#50626585_pgfId-1009195]##If a resource reference __ annotation is
applied on a class, it is equivalent to defining a resource, however it
is not equivalent to defining an _injection-target_ . The rules above
apply for _injection-target_ element in this case.

[#50626585_pgfId-1009196]##If a resource reference annotation is used on
a field it is equivalent to defining the _injection-target_ element in
the _web.xml_ . However if there is no _injection-target_ element in the
descriptor then the _injection-target_ from the fragments will still be
merged into the _web.xml_ as defined above.

[#50626585_pgfId-1009197]##If on the other hand there is an
_injection-target_ in the main _web.xml_ and there is a resource
reference _annotation_ with the same resource name, then it is
considered an override for the resource reference annotation. In this
case since there is an _injection-target_ specified in the descriptor,
the rules defined above would apply in addition to overriding the value
for the resource reference annotation.

[#50626585_pgfId-1009888]##If a _data-source_ element is specified in
two fragments, while absent from the main _web.xml_ , and all the
attributes and child elements of the _data-source_ element are
identical, the _data-source_ will be merged into the main _web.xml_ . It
is considered an error if a _data-source_ element has the same name
specified in two fragments, while absent from the main _web.xml_ and the
attributes and child elements are not identical in the two fragments. In
such a case an error must be reported and the application MUST fail to
deploy.

[#50626585_pgfId-1009096]##Below are some examples that show the outcome
in the different cases.

[#50626585_pgfId-1009097]## 

[#50626585_pgfId-1009098]##web.xml - no resource-ref definition

[#50626585_pgfId-1009088]##Fragment 1

[#50626585_pgfId-1008872]##web-fragment.xml

[#50626585_pgfId-1009015]##<resource-ref>

[#50626585_pgfId-1008873]## <resource-ref-name="foo">

[#50626585_pgfId-1008874]## ...

[#50626585_pgfId-1008875]## <injection-target>

[#50626585_pgfId-1008876]## <injection-target-class>

[#50626585_pgfId-1008877]## com.example.Bar.class

[#50626585_pgfId-1008878]## </injection-target-class>

[#50626585_pgfId-1008879]## <injection-target-name>

[#50626585_pgfId-1008880]## baz

[#50626585_pgfId-1008881]## </injection-target-name>

[#50626585_pgfId-1008882]## </injection-target>

[#50626585_pgfId-1008883]##</resource-ref>

[#50626585_pgfId-1008884]## 

[#50626585_pgfId-1008885]##The effective metadata would be

[#50626585_pgfId-1008886]## 

[#50626585_pgfId-1008887]##<resource-ref>

[#50626585_pgfId-1008888]## <resource-ref-name="foo">

[#50626585_pgfId-1008889]## ....

[#50626585_pgfId-1008890]## <injection-target>

[#50626585_pgfId-1008891]## <injection-target-class>

[#50626585_pgfId-1008892]## com.example.Bar.class

[#50626585_pgfId-1008893]## </injection-target-class>

[#50626585_pgfId-1008894]## <injection-target-name>

[#50626585_pgfId-1008895]## baz

[#50626585_pgfId-1008896]## </injection-target-name>

[#50626585_pgfId-1008897]## </injection-target>

[#50626585_pgfId-1008898]##</resource-ref>

[#50626585_pgfId-1009023]## 

[#50626585_pgfId-1009024]## 

[#50626585_pgfId-1008903]##web.xml

[#50626585_pgfId-1008905]##<resource-ref>

[#50626585_pgfId-1008906]## <resource-ref-name="foo">

[#50626585_pgfId-1008907]## ...

[#50626585_pgfId-1008908]##</resource-ref>

[#50626585_pgfId-1008909]## 

[#50626585_pgfId-1008910]##Fragment 1

[#50626585_pgfId-1008911]##web-fragment.xml

[#50626585_pgfId-1009114]##<resource-ref>

[#50626585_pgfId-1008912]## <resource-ref-name="foo">

[#50626585_pgfId-1008913]## ...

[#50626585_pgfId-1008914]## <injection-target>

[#50626585_pgfId-1008915]## <injection-target-class>

[#50626585_pgfId-1008916]## com.example.Bar.class

[#50626585_pgfId-1008917]## </injection-target-class>

[#50626585_pgfId-1008918]## <injection-target-name>

[#50626585_pgfId-1008919]## baz

[#50626585_pgfId-1008920]## </injection-target-name>

[#50626585_pgfId-1008921]## </injection-target>

[#50626585_pgfId-1008922]##</resource-ref>

[#50626585_pgfId-1008923]## 

[#50626585_pgfId-1008924]##Fragment 2

[#50626585_pgfId-1008925]##web-fragment.xml

[#50626585_pgfId-1009115]##<resource-ref>

[#50626585_pgfId-1008926]## <resource-ref-name="foo">

[#50626585_pgfId-1008927]## ...

[#50626585_pgfId-1008928]## <injection-target>

[#50626585_pgfId-1008929]## <injection-target-class>

[#50626585_pgfId-1008930]## com.example.Bar2.class

[#50626585_pgfId-1008931]## </injection-target-class>

[#50626585_pgfId-1008932]## <injection-target-name>

[#50626585_pgfId-1008933]## baz2

[#50626585_pgfId-1008934]## </injection-target-name>

[#50626585_pgfId-1008935]## </injection-target>

[#50626585_pgfId-1008936]##</resource-ref>

[#50626585_pgfId-1008938]##The effective metadata would be

[#50626585_pgfId-1008940]##<resource-ref>

[#50626585_pgfId-1008941]## <resource-ref-name="foo">

[#50626585_pgfId-1008942]## ....

[#50626585_pgfId-1009118]## <injection-target>

[#50626585_pgfId-1009119]## <injection-target-class>

[#50626585_pgfId-1009120]## com.example.Bar.class

[#50626585_pgfId-1009121]## </injection-target-class>

[#50626585_pgfId-1009122]## <injection-target-name>

[#50626585_pgfId-1009123]## baz

[#50626585_pgfId-1009124]## </injection-target-name>

[#50626585_pgfId-1009125]## </injection-target>

[#50626585_pgfId-1009116]## 

[#50626585_pgfId-1008943]## <injection-target>

[#50626585_pgfId-1008944]## <injection-target-class>

[#50626585_pgfId-1008945]## com.example.Bar2.class

[#50626585_pgfId-1008946]## </injection-target-class>

[#50626585_pgfId-1008947]## <injection-target-name>

[#50626585_pgfId-1008948]## baz2

[#50626585_pgfId-1008949]## </injection-target-name>

[#50626585_pgfId-1008950]## </injection-target>

[#50626585_pgfId-1008951]##</resource-ref>

[#50626585_pgfId-1008953]## 

[#50626585_pgfId-1009057]## 

[#50626585_pgfId-1008954]##web.xml

[#50626585_pgfId-1008955]## 

[#50626585_pgfId-1008956]##<resource-ref>

[#50626585_pgfId-1008957]## <resource-ref-name="foo">

[#50626585_pgfId-1008958]## <injection-target>

[#50626585_pgfId-1008959]## <injection-target-class>

[#50626585_pgfId-1008960]## com.example.Bar3.class

[#50626585_pgfId-1008961]## </injection-target-class>

[#50626585_pgfId-1008962]## <injection-target-name>

[#50626585_pgfId-1008963]## baz3

[#50626585_pgfId-1008964]## </injection-target-name>

[#50626585_pgfId-1008965]## 

[#50626585_pgfId-1008966]## ...

[#50626585_pgfId-1008967]##</resource-ref>

[#50626585_pgfId-1008968]## 

[#50626585_pgfId-1008969]##Fragment 1

[#50626585_pgfId-1008970]##web-fragment.xml<resource-ref>

[#50626585_pgfId-1008971]## <resource-ref-name="foo">

[#50626585_pgfId-1008972]## ...

[#50626585_pgfId-1008973]## <injection-target>

[#50626585_pgfId-1008974]## <injection-target-class>

[#50626585_pgfId-1008975]## com.example.Bar.class

[#50626585_pgfId-1008976]## </injection-target-class>

[#50626585_pgfId-1008977]## <injection-target-name>

[#50626585_pgfId-1008978]## baz

[#50626585_pgfId-1008979]## </injection-target-name>

[#50626585_pgfId-1008980]## </injection-target>

[#50626585_pgfId-1008981]##</resource-ref>

[#50626585_pgfId-1008982]## 

[#50626585_pgfId-1008983]##Fragment 2

[#50626585_pgfId-1008984]##web-fragment.xml<resource-ref>

[#50626585_pgfId-1008985]## <resource-ref-name="foo">

[#50626585_pgfId-1008986]## ...

[#50626585_pgfId-1008987]## <injection-target>

[#50626585_pgfId-1008988]## <injection-target-class>

[#50626585_pgfId-1008989]## com.example.Bar2.class

[#50626585_pgfId-1008990]## </injection-target-class>

[#50626585_pgfId-1008991]## <injection-target-name>

[#50626585_pgfId-1008992]## baz2

[#50626585_pgfId-1008993]## </injection-target-name>

[#50626585_pgfId-1008994]## </injection-target>

[#50626585_pgfId-1008995]##</resource-ref>

[#50626585_pgfId-1008996]## 

[#50626585_pgfId-1008997]##The effective metadata would be

[#50626585_pgfId-1008998]## 

[#50626585_pgfId-1008999]##<resource-ref>

[#50626585_pgfId-1009000]## <resource-ref-name="foo">

[#50626585_pgfId-1009001]## <injection-target>

[#50626585_pgfId-1009002]## <injection-target-class>

[#50626585_pgfId-1009003]## com.example.Bar3.class

[#50626585_pgfId-1009004]## </injection-target-class>

[#50626585_pgfId-1009005]## <injection-target-name>

[#50626585_pgfId-1009006]## baz3

[#50626585_pgfId-1009007]## </injection-target-name>

[#50626585_pgfId-1010155]##<injection-target-class>

[#50626585_pgfId-1010156]## com.example.Bar.class

[#50626585_pgfId-1010157]##</injection-target-class>

[#50626585_pgfId-1010158]##<injection-target-name>

[#50626585_pgfId-1010159]## baz

[#50626585_pgfId-1010153]##</injection-target-name>

[#50626585_pgfId-1010263]##<injection-target-class>

[#50626585_pgfId-1010264]## com.example.Bar2.class

[#50626585_pgfId-1010265]##</injection-target-class>

[#50626585_pgfId-1010225]##<injection-target-name>

[#50626585_pgfId-1010226]## baz2

[#50626585_pgfId-1010227]##</injection-target-name>

[#50626585_pgfId-1010220]##</injection-target>

[#50626585_pgfId-1009008]## 

[#50626585_pgfId-1009009]## ...

[#50626585_pgfId-1009010]##</resource-ref>

[#50626585_pgfId-1009011]## 

[#50626585_pgfId-1008867]##The _<injection-target>_ from fragment 1 and
2 will be merged into the main web.xml

[#50626585_pgfId-1009365]##If the main _web.xml_ does not have any
_<post-construct>_ element specified and web-fragments have specified
_<post-construct>_ then the _<post-construct>_ elements from the
fragments will be merged into the main _web.xml_ . However if in the
main _web.xml_ at least one _<post-construct>_ element is specified then
the _<post-construct>_ elements from the fragment will not be merged. It
is the responsibility of the author of the _web.xml_ to make sure that
the _<post-construct>_ list is complete.

[#50626585_pgfId-1008420]##If the main _web.xml_ does not have any
_<pre-destroy>_ element specified and web-fragments have specified
_<pre-destroy>_ then the _<pre-destroy>_ elements from the fragments
will be merged into the main _web.xml_ . However if in the main
_web.xml_ at least one _<pre-destroy>_ element is specified then the
_<pre-destroy>_ elements from the fragment will not be merged. It is the
responsibility of the author of the _web.xml_ to make sure that the
_<pre-destroy>_ list is complete.

[#50626585_pgfId-1009383]##After processing the _web-fragment.xml_ ,
annotations from the corresponding fragment are processed to complete
the effective metadata for the fragment before processing the next
fragment. The following rules are used for processing annotations:

[#50626585_pgfId-1007453]##Any metadata specified via an annotation that
isn’t already present in the descriptor will be used to augment the
effective descriptor.

[#50626585_pgfId-1007438]##Configuration specified in the main _web.xml_
or a web fragment takes precedence over the configuration specified via
annotations.

[#50626585_pgfId-1007439]##For a servlet defined via the _@WebServlet_
annotation, to override values via the descriptor, the name of the
servlet in the descriptor MUST match the name of the servlet specified
via the annotation (explicitly specified or the default name, if one is
not specified via the annotation).

[#50626585_pgfId-1007446]##Init params for servlets and filters defined
via annotations, will be overridden in the descriptor if the name of the
init param exactly matches the name specified via the annotation. Init
params are additive between the annotations and descriptors.

[#50626585_pgfId-1007451]## _url-patterns_ , when specified in a
descriptor for a given servlet name overrides the url patterns specified
via the annotation.

[#50626585_pgfId-1007452]##For a filter defined via the _@WebFilter_
annotation, to override values via the descriptor, the name of the
filter in the descriptor MUST match the name of the filter specified via
the annotation (explicitly specified or the default name, if one is not
specified via the annotation).

[#50626585_pgfId-1007470]## _url-patterns_ to which a filter is applied,
when specified in a descriptor for a given filter name overrides the url
patterns specified via the annotation.

[#50626585_pgfId-1007481]##DispatcherTypes to which a filter applies,
when specified in a descriptor for a given filter name overrides the
DispatcherTypes specified via the annotation.

[#50626585_pgfId-1007689]##The following examples demonstrates some of
the above rules -

[#50626585_pgfId-1007701]##A Servlet declared via an annotation and
packaged with the corresponding _web.xml_ in the descriptor

[#50626585_pgfId-1007691]## 

[#50626585_pgfId-1007693]##@WebServlet(urlPatterns=”/MyPattern”,
initParams=\{@WebInitParam(name="ccc", value="333")})

[#50626585_pgfId-1007650]##public class com.example.Foo extends
HttpServlet

[#50626585_pgfId-1007651]## \{

[#50626585_pgfId-1007652]## ...

[#50626585_pgfId-1007647]## }

[#50626585_pgfId-1007644]## 

[#50626585_pgfId-1007657]##web.xml

[#50626585_pgfId-1007643]##<servlet>

[#50626585_pgfId-1007583]##
<servlet-class>com.example.Foo</servlet-class>

[#50626585_pgfId-1007584]## <servlet-name>Foo</servlet-name>

[#50626585_pgfId-1007585]## <init-param>

[#50626585_pgfId-1007586]## <param-name>aaa</param-name>

[#50626585_pgfId-1007587]## <param-value>111</param-value>

[#50626585_pgfId-1007588]## </init-param>

[#50626585_pgfId-1007589]## </servlet>

[#50626585_pgfId-1007590]## 

[#50626585_pgfId-1007591]## <servlet>

[#50626585_pgfId-1007592]##
<servlet-class>com.example.Foo</servlet-class>

[#50626585_pgfId-1007593]## <servlet-name>Fum</servlet-name>

[#50626585_pgfId-1007594]## <init-param>

[#50626585_pgfId-1007595]## <param-name>bbb</param-name>

[#50626585_pgfId-1007596]## <param-value>222</param-value>

[#50626585_pgfId-1007597]## </init-param>

[#50626585_pgfId-1007598]## </servlet>

[#50626585_pgfId-1007599]## 

[#50626585_pgfId-1007600]## <servlet-mapping>

[#50626585_pgfId-1007601]## <servlet-name>Foo</servlet-name>

[#50626585_pgfId-1007602]## <url-pattern>/foo/*</url-pattern>

[#50626585_pgfId-1007603]## </servlet-mapping>

[#50626585_pgfId-1007605]## <servlet-mapping>

[#50626585_pgfId-1007606]## <servlet-name>Fum</servlet-name>

[#50626585_pgfId-1007607]## <url-pattern>/fum/*</url-pattern>

[#50626585_pgfId-1007608]## </servlet-mapping>

[#50626585_pgfId-1007609]## 

[#50626585_pgfId-1007628]##Since the name of the servlet declared via
the annotation does not match the name of the servlet declared in the
_web.xml_ , the annotation specifies a new servlet declaration in
addition to the other declarations in _web.xml_ and is equivalent to:

[#50626585_pgfId-1007631]## 

[#50626585_pgfId-1007632]## <servlet>

[#50626585_pgfId-1007633]##
<servlet-class>com.example.Foo</servlet-class>

[#50626585_pgfId-1007634]## <servlet-name>com.example.Foo</servlet-name>

[#50626585_pgfId-1007635]## <init-param>

[#50626585_pgfId-1007636]## <param-name>ccc</param-name>

[#50626585_pgfId-1007637]## <param-value>333</param-name>

[#50626585_pgfId-1007638]## </servlet>

[#50626585_pgfId-1007574]##If the above _web.xml_ were replaced with the
following

[#50626585_pgfId-1007743]##<servlet>

[#50626585_pgfId-1007744]##
<servlet-class>com.example.Foo</servlet-class>

[#50626585_pgfId-1007745]## <servlet-name>com.example.Foo</servlet-name>

[#50626585_pgfId-1007746]## <init-param>

[#50626585_pgfId-1007747]## <param-name>aaa</param-name>

[#50626585_pgfId-1007748]## <param-value>111</param-value>

[#50626585_pgfId-1007749]## </init-param>

[#50626585_pgfId-1007750]## </servlet>

[#50626585_pgfId-1007760]## 

[#50626585_pgfId-1007761]## <servlet-mapping>

[#50626585_pgfId-1007762]## <servlet-name>com.example.Foo</servlet-name>

[#50626585_pgfId-1007763]## <url-pattern>/foo/*</url-pattern>

[#50626585_pgfId-1007764]## </servlet-mapping>

[#50626585_pgfId-1007788]##Then the effective descriptor would be
equivalent to <servlet>

[#50626585_pgfId-1007789]##
<servlet-class>com.example.Foo</servlet-class>

[#50626585_pgfId-1007790]## <servlet-name>com.example.Foo</servlet-name>

[#50626585_pgfId-1007791]## <init-param>

[#50626585_pgfId-1007792]## <param-name>aaa</param-name>

[#50626585_pgfId-1007793]## <param-value>111</param-value>

[#50626585_pgfId-1007794]## </init-param>

[#50626585_pgfId-1007810]## <init-param>

[#50626585_pgfId-1007811]## <param-name>ccc</param-name>

[#50626585_pgfId-1007812]## <param-value>333</param-value>

[#50626585_pgfId-1007808]## </init-param>

[#50626585_pgfId-1007795]## </servlet>

[#50626585_pgfId-1007796]## 

[#50626585_pgfId-1007797]## <servlet-mapping>

[#50626585_pgfId-1007798]## <servlet-name>com.example.Foo</servlet-name>

[#50626585_pgfId-1007799]## <url-pattern>/foo/*</url-pattern>

[#50626585_pgfId-1007737]## </servlet-mapping>

===== [#50626585_pgfId-1007575]##[#50626585_49176]##Shared libraries / runtimes pluggability

[#50626585_pgfId-1007448]##In addition to supporting fragments and use
of annotations one of the requirements is that not only we be able to
plug-in things that are bundled in the _WEB-INF/lib_ but also plugin
shared copies of frameworks - including being able to plug-in to the web
container things like JAX-WS, JAX-RS and JSF that build on top of the
web container. The _ServletContainerInitializer_ allows handling such a
use case as described below.

[#50626585_pgfId-1007278]##The _ServletContainerInitializer_ class is
looked up via the jar services API. For each application, an instance of
the _ServletContainerInitializer_ is created by the container at
application startup time. The framework providing an implementation of
the _ServletContainerInitializer_ MUST bundle in the _META-INF/services_
directory of the jar file a file called
_javax.servlet.ServletContainerInitializer_ , as per the jar services
API, that points to the implementation class of the
_ServletContainerInitializer_ .

[#50626585_pgfId-1007200]##In addition to the
_ServletContainerInitializer_ we also have an annotation -
_HandlesTypes_ . The _HandlesTypes_ annotation on the implementation of
the _ServletContainerInitializer_ is used to express interest in classes
that may have annotations (type, method or field level annotations)
specified in the value of the _HandlesTypes_ or if it extends /
implements one those classes anywhere in the class’ super types. The
_HandlesTypes_ annotation is applied irrespective of the setting of
_metadata-complete_ .

[#50626585_pgfId-1011618]##When examining the classes of an application
to see if they match any of the criteria specified by the _HandlesTypes_
annotation of a _ServletContainerInitializer_ , the container may run
into class loading problems if one or more of the application's optional
JAR files are missing. Since the container is not in a position to
decide whether these types of class loading failures will prevent the
application from working correctly, it must ignore them, while at the
same time providing a configuration option that would log them.

[#50626585_pgfId-1004477]##If an implementation of
_ServletContainerInitializer_ does not have the _@HandlesTypes_
annotation, or if there are no matches to any of the _HandlesType_
specified, then it will get invoked once for every application with
_null_ as the value of the _Set_ . This will allow for the initializer
to determine based on the resources available in the application whether
it needs to initialize a servlet / filter or not.

[#50626585_pgfId-1004479]##The _onStartup_ method of the
_ServletContainerInitializer_ will be invoked when the application is
coming up before any of the servlet listener events are fired.

[#50626585_pgfId-1007240]##The _onStartup_ method of the
_ServletContainerInitializer_ is called with a _Set_ of Classes that
either extend / implement the classes that the initializer expressed
interest in or if it is annotated with any of the classes specified via
the _@HandlesTypes_ annotation.

[#50626585_pgfId-1007241]##A concrete example below showcases how this
would work.

[#50626585_pgfId-1004485]##Let's take the JAX-WS web services runtime.

[#50626585_pgfId-1004487]##The implementation of JAX-WS runtime isn't
typically bundled in each and every war file. The implementation would
bundle an implementation of the _ServletContainerInitializer_ (shown
below) and the container would look that up using the services API (the
jar file will bundle in it's _META-INF/services_ directory a file called
_javax.servlet.ServletContainerInitializer_ that will point to the
_JAXWSServletContainerInitializer_ shown below).

[#50626585_pgfId-1007827]##@HandlesTypes(WebService.class)

[#50626585_pgfId-1007828]##JAXWSServletContainerInitializer implements
ServletContainerInitializer

[#50626585_pgfId-1004652]##\{

[#50626585_pgfId-1004629]## public void onStartup(Set<Class<?>> c,
ServletContext ctx) throws ServletException \{

[#50626585_pgfId-1004630]## // JAX-WS specific code here to initialize
the runtime // and setup the mapping etc.

[#50626585_pgfId-1004658]## ServletRegistration reg =
ctx.addServlet("JAXWSServlet", "com.sun.webservice.JAXWSServlet");

[#50626585_pgfId-1004499]## reg.addServletMapping("/foo");

[#50626585_pgfId-1004500]## }

[#50626585_pgfId-1009138]##The framework jar file can also be bundled in
_WEB-INF/lib_ directory of the war file. If the
_ServletContainerInitializer_ is bundled in a JAR file inside the
_WEB-INF/lib_ directory of an application, it’s _onStartup_ method will
be invoked only once during the startup of the bundling application. If,
on the other hand, the _ServletContainerInitializer_ is bundled in a JAR
file outside of the _WEB-INF/lib_ directory, but still discoverable by
the runtime’s service provider lookup mechanism, it’s _onStartup_ method
will be invoked every time an application is started.

[#50626585_pgfId-1009159]##Implementations of the
_ServletContainerInitializer_ interface will be discovered by the
runtime's service lookup mechanism or a container specific mechanism
that is semantically equivalent to it. In either case,
_ServletContainerInitializer_ services from web fragment JAR files that
are excluded from an absolute ordering MUST be ignored, and the order in
which these services are discovered MUST follow the application’s class
loading delegation model.

==== [#50626585_pgfId-1002823]##

image:servlet-30.gif[image]

JSP container pluggability

[#50626585_pgfId-1007905]##The _ServletContainerInitializer_ and
programmatic registration features make it possible to provide a clear
separation of responsibilities between the Servlet and JSP containers,
by making the Servlet container responsible for parsing only _web.xml_
and _web-fragment.xml_ resources, and delegating the parsing of Tag
Library Descriptor (TLD) resources to the JSP container.

[#50626585_pgfId-1007912]##Previously, a web container had to scan TLD
resources for any listener declarations. With Servlet 3.0 and later
versions, this responsibility may be delegated to the JSP container. A
JSP container that is embedded in a Servlet container may provide its
own _ServletContainerInitializer_ implementation, search the
_ServletContext_ passed to its _onStartup_ method for any TLD resources,
scan those resources for listener declarations, and register the
corresponding listeners with the _ServletContext_ .

[#50626585_pgfId-1007921]##In addition, prior to Servlet 3.0, a JSP
container used to have to scan an application's deployment descriptor
for any _jsp-config_ related configuration. With Servlet 3.0 and later
versions, the Servlet container must make available, via the
_ServletContext.getJspConfigDescriptor_ method, any _jsp-config_ related
configuration from the application's _web.xml_ and _web-fragment.xml_
deployment descriptors.

[#50626585_pgfId-1007928]##Any _ServletContextListeners_ that were
discovered in a TLD and registered programmatically are limited in the
functionality they provide. Any attempt to call a _ServletContext_ API
methods on them that was added since Servlet 3.0 will result in an
_UnsupportedOperationException_ .

[#50626585_pgfId-1008023]##In addition, a Servlet container compliant
with Servlet 3.0 or later versions must provide a _ServletContext_
attribute with name _javax.servlet.context.orderedLibs_ , whose value
(of type _java.util.List<java.lang.String>_ ) contains the list of names
of JAR files in the _WEB-INF/lib_ directory of the application
represented by the _ServletContext_ , ordered by their web fragment
names (with possible exclusions if fragment JAR files have been excluded
from _absolute-ordering_ ), or _null_ if the application does not
specify any absolute or relative ordering.

==== [#50626585_pgfId-1007902]##

image:servlet-30.gif[image]

[#50626585_72500]##Processing annotations and fragments

[#50626585_pgfId-1006745]##Web applications can include both annotations
and the _web.xml_ / _web-fragment.xml_ deployment descriptors. If there
is no deployment descriptor, or there is one but does not have the
_metadata-complete_ set to true, _web.xml_ , _web-fragment.xml_ and
annotations if used in the application must be processed. The following
table describes whether or not to process annotations and _web.xml_
fragments.

======= [#50626585_pgfId-1006748]##Annotations and web fragment processing requirements

[#50626585_pgfId-1006754]##Deployment descriptor

[#50626585_pgfId-1006756]##metadata-complete

[#50626585_pgfId-1006758]##process annotations and web fragments

[#50626585_pgfId-1006760]##web.xml 2.5

[#50626585_pgfId-1006762]##yes

[#50626585_pgfId-1006764]##no

[#50626585_pgfId-1006766]##web.xml 2.5

[#50626585_pgfId-1006768]##no

[#50626585_pgfId-1006770]##yes

[#50626585_pgfId-1006772]##web.xml 3.0 or later

[#50626585_pgfId-1006774]##yes

[#50626585_pgfId-1006776]##no

[#50626585_pgfId-1006778]##web.xml 3.0 or later

[#50626585_pgfId-1006780]##no

[#50626585_pgfId-1006782]##yes

[#50626585_pgfId-1002765]## 

== [#50626608_pgfId-874]## 

=== [#50626608_pgfId-999462]##

image:servlet-31.gif[image]

[#50626608_85442]##Dispatching Requests

image:servlet-32.gif[image]

[#50626608_pgfId-999463]##When building a Web application, it is often
useful to forward processing of a request to another servlet, or to
include the output of another servlet in the response. The
_RequestDispatcher_ interface provides a mechanism to accomplish this.

[#50626608_pgfId-1000147]##When asynchronous processing is enabled on
the request, the _AsyncContext_ allows a user to dispatch the request
back to the servlet container.

==== [#50626608_pgfId-999464]##

image:servlet-33.gif[image]

Obtaining a RequestDispatcher

[#50626608_pgfId-999465]##An object implementing the _RequestDispatcher_
interface may be obtained from the _ServletContext_ via the following
methods:

[#50626608_pgfId-999466]## _getRequestDispatcher_

[#50626608_pgfId-999467]## _getNamedDispatcher_

[#50626608_pgfId-999468]##The _getRequestDispatcher_ method takes a
_String_ argument describing a path within the scope of the
_ServletContext_ . This path must be relative to the root of the
_ServletContext_ and begin with a ‘ _/_ ’, or be empty. The method uses
the path to look up a servlet, using the servlet path matching rules in
link:servlet.htm#50626594_64358[See Mapping Requests to Servlets], wraps
it with a _RequestDispatcher_ object, and returns the resulting object.
If no servlet can be resolved based on the given path, a
_RequestDispatcher_ is provided that returns the content for that path.

[#50626608_pgfId-999472]##The _getNamedDispatcher_ method takes a
_String_ argument indicating the name of a servlet known to the
_ServletContext_ . If a servlet is found, it is wrapped with a
_RequestDispatcher_ object and the object is returned. If no servlet is
associated with the given name, the method must return _null_ .

[#50626608_pgfId-999473]##To allow _RequestDispatcher_ objects to be
obtained using relative paths that are relative to the path of the
current request (not relative to the root of the _ServletContext_ ), the
_getRequestDispatcher_ method is provided in the _ServletRequest_
interface.

[#50626608_pgfId-999474]##The behavior of this method is similar to the
method of the same name in the _ServletContext_ . The servlet container
uses information in the request object to transform the given relative
path against the current servlet to a complete path. For example, in a
context rooted at _’_ _/_ _’_ and __ a request to __
_/garden/tools.html_ , a request dispatcher obtained via __
_ServletRequest.getRequestDispatcher("header.html")_ will behave exactly
like a call to __
_ServletContext.getRequestDispatcher("/garden/header.html")_ .

===== [#50626608_pgfId-999475]##Query Strings in Request Dispatcher Paths

[#50626608_pgfId-999476]##The _ServletContext_ and _ServletRequest_
methods that create _RequestDispatcher_ objects using path information
allow the optional attachment of query string information to the path.
For example, a Developer may obtain a _RequestDispatcher_ by using the
following code:

[width="100%",cols="100%",]
|===
a|
[#50626608_pgfId-999594]##String path = “/raisins.jsp?orderno=5”;

[#50626608_pgfId-999595]##RequestDispatcher rd =
context.getRequestDispatcher(path);

[#50626608_pgfId-999592]##rd.include(request, response);

|===

[#50626608_pgfId-999480]##Parameters specified in the query string used
to create the _RequestDispatcher_ take precedence over other parameters
of the same name passed to the included servlet. The parameters
associated with a _RequestDispatcher_ are scoped to apply only for the
duration of the _include_ or _forward_ call.

==== [#50626608_pgfId-999481]##

image:servlet-33.gif[image]

Using a Request Dispatcher

[#50626608_pgfId-999482]##To use a request dispatcher, a servlet calls
either the _include_ method or _forward_ method of the
_RequestDispatcher_ interface. The parameters to these methods can be
either the _request_ and _response_ arguments that were passed in via
the _service_ method of the _javax.servlet.Servlet_ interface, or
instances of subclasses of the request and response wrapper classes that
were introduced for version 2.3 of the specification. In the latter
case, the wrapper instances must wrap the request or response objects
that the container passed into the _service_ method.

[#50626608_pgfId-999483]##The Container Provider should ensure that the
dispatch of the request to a target servlet occurs in the same thread of
the same JVM as the original request.

==== [#50626608_pgfId-999485]##

image:servlet-33.gif[image]

[#50626608_61967]##The Include Method

[#50626608_pgfId-999486]##The _include_ method of the
_RequestDispatcher_ interface may be called at any time. The target
servlet of the _include_ method has access to all aspects of the request
object, but its use of the response object is more limited.

[#50626608_pgfId-999487]##It can only write information to the
_ServletOutputStream_ or _Writer_ of the response object and commit a
response by writing content past the end of the response buffer, or by
explicitly calling the _flushBuffer_ method of the _ServletResponse_
interface. It cannot set headers or call any method that affects the
headers of the response, with the exception of the
_HttpServletRequest.getSession()_ and
_HttpServletRequest.getSession(boolean)_ methods. Any attempt to set the
headers must be ignored, and any call to
_HttpServletRequest.getSession()_ or
_HttpServletRequest.getSession(boolean)_ that would require adding a
Cookie response header must throw an _IllegalStateException_ if the
response has been committed.

[#50626608_pgfId-1000802]##If the default servlet is the target of a
RequestDispatch.include() and the requested resource does not exist,
then the default servlet MUST throw _FileNotFoundException_ . If the
exception isn't caught and handled, and the response hasn’t been
committed, the status code MUST be set to 500.

===== [#50626608_pgfId-999488]##[#50626608_86448]##Included Request Parameters

[#50626608_pgfId-999489]##Except for servlets obtained by using the
_getNamedDispatcher_ method, a servlet that has been invoked by another
servlet using the _include_ method of _RequestDispatcher_ has access to
the path by which it was invoked.

[#50626608_pgfId-999490]##The following request attributes must be set:

[width="100%",cols="100%",]
|===
a|
[#50626608_pgfId-999621]##javax.servlet.include.request_uri

[#50626608_pgfId-999622]##javax.servlet.include.context_path

[#50626608_pgfId-999623]##javax.servlet.include.servlet_path

[#50626608_pgfId-1001401]##javax.servlet.include.mapping

[#50626608_pgfId-999624]##javax.servlet.include.path_info

[#50626608_pgfId-999619]##javax.servlet.include.query_string

|===

[#50626608_pgfId-999496]##These attributes are accessible from the
included servlet via the _getAttribute_ method on the request object and
their values must be equal to the request URI, context path, servlet
path, path info, and query string of the included servlet, respectively.
If the request is subsequently included, these attributes are replaced
for that include.

[#50626608_pgfId-999497]##If the included servlet was obtained by using
the _getNamedDispatcher_ method, these attributes must not be set.

==== [#50626608_pgfId-999498]##

image:servlet-33.gif[image]

[#50626608_48495]##The Forward Method

[#50626608_pgfId-999499]##The _forward_ method of the
_RequestDispatcher_ interface may be called by the calling servlet only
when no output has been committed to the client. If output data exists
in the response buffer that has not been committed, the content must be
cleared before the target servlet’s _service_ method is called. If the
response has been committed, an _IllegalStateException_ must be thrown.

[#50626608_pgfId-999500]##The path elements of the request object
exposed to the target servlet must reflect the path used to obtain the
_RequestDispatcher_ .

[#50626608_pgfId-999501]##The only exception to this is if the
_RequestDispatcher_ was obtained via the _getNamedDispatcher_ method. In
this case, the path elements of the request object must reflect those of
the original request.

[#50626608_pgfId-999502]##Before the _forward_ method of the
_RequestDispatcher_ interface returns without exception, the response
content must be sent and committed, and closed by the servlet container,
unless the request was put into the asynchronous mode. If an error
occurs in the target of the _RequestDispatcher.forward()_ the exception
may be propagated back through all the calling filters and servlets and
eventually back to the container

===== [#50626608_pgfId-999503]##Query String

[#50626608_pgfId-999504]##The request dispatching mechanism is
responsible for aggregating query string parameters when forwarding or
including requests.

===== [#50626608_pgfId-999505]##[#50626608_33186]##Forwarded Request Parameters

[#50626608_pgfId-999506]##Except for servlets obtained by using the
_getNamedDispatcher_ method, a servlet that has been invoked by another
servlet using the _forward_ method of _RequestDispatcher_ has access to
the path of the original request.

[#50626608_pgfId-999507]##The following request attributes must be set:

[width="100%",cols="100%",]
|===
a|
[#50626608_pgfId-999653]##javax.servlet.forward.mapping

[#50626608_pgfId-1001433]##javax.servlet.forward.request_uri

[#50626608_pgfId-999654]##javax.servlet.forward.context_path

[#50626608_pgfId-999655]##javax.servlet.forward.servlet_path

[#50626608_pgfId-999656]##javax.servlet.forward.path_info

[#50626608_pgfId-999651]##javax.servlet.forward.query_string

|===

[#50626608_pgfId-999513]##The values of these attributes must be equal
to the return values of the _HttpServletRequest_ methods _getRequestURI_
, _getContextPath_ , _getServletPath_ , _getPathInfo_ , _getQueryString_
respectively, invoked on the request object passed to the first servlet
object in the call chain that received the request from the client.

[#50626608_pgfId-999514]##These attributes are accessible from the
forwarded servlet via the _getAttribute_ method on the request object.
Note that these attributes must always reflect the information in the
original request even under the situation that multiple forwards and
subsequent includes are called.

[#50626608_pgfId-999515]##If the forwarded servlet was obtained by using
the _getNamedDispatcher_ method, these attributes must not be set.

==== [#50626608_pgfId-999516]##

image:servlet-33.gif[image]

Error Handling

[#50626608_pgfId-999517]##If the servlet that is the target of a request
dispatcher throws a runtime exception or a checked exception of type
_ServletException_ or _IOException_ , it should be propagated to the
calling servlet. All other exceptions should be wrapped as
_ServletExceptions_ and the root cause of the exception set to the
original exception, as it should not be propagated.

==== [#50626608_pgfId-1000148]##

image:servlet-33.gif[image]

Obtaining an AsyncContext

[#50626608_pgfId-1000543]##An object implementing the _AsyncContext_
interface may be obtained from the _ServletRequest_ via one of
_startAsync_ methods. Once you have an _AsyncContext_ , you can use it
to either complete the processing of the request via the _complete()_
method or use one of the _dispatch_ methods described below.

==== [#50626608_pgfId-1000560]##

image:servlet-33.gif[image]

The Dispatch Method

[#50626608_pgfId-1000567]##The following methods can be used to dispatch
requests from the _AsyncContext_ :

[#50626608_pgfId-1000568]## _dispatch(path)_

[#50626608_pgfId-1000710]##The _dispatch_ method takes a _String_
argument describing a path within the scope of the _ServletContext_ .
This path must be relative to the root of the _ServletContext_ and begin
with a ‘ _/_ ’.

[#50626608_pgfId-1000714]## _dispatch(servletContext, path)_

[#50626608_pgfId-1000574]##The _dispatch_ method takes a _String_
argument describing a path within the scope of the _ServletContext
specified_ . This path must be relative to the root of the
_ServletContext specified_ and begin with a ‘ _/_ ’.

[#50626608_pgfId-1000578]## _dispatch()_

[#50626608_pgfId-1000579]##The _dispatch_ method takes no argument. It
uses the original URI as the path. If the _AsyncContext_ was initialized
via the _startAsync(ServletRequest, ServletResponse)_ and the request
passed is an instance of _HttpServletRequest_ , then the dispatch is to
the URI returned by _HttpServletRequest.getRequestURI()_ . Otherwise the
dispatch is to the URI of the request when it was last dispatched by the
container

[#50626608_pgfId-1000535]##One of the _dispatch_ methods of the
_AsyncContext_ interface may be called by the application waiting for
the asynchronous event to happen. If _complete()_ has been called on the
_AsyncContext_ , an _IllegalStateException_ must be thrown. All the
variations of the dispatch methods returns immediately and do not commit
the response.

[#50626608_pgfId-1000353]##The path elements of the request object
exposed to the target servlet must reflect the path specified in the
_AsyncContext.dispatch_ .

===== [#50626608_pgfId-1000354]##Query String

[#50626608_pgfId-1000208]##The request dispatching mechanism is
responsible for aggregating query string parameters when dispatching
requests.

===== [#50626608_pgfId-1000209]##[#50626608_87221]##Dispatched Request Parameters

[#50626608_pgfId-1000210]##A servlet that has been invoked by using the
_dispatch_ method of _AsyncContext_ has access to the path of the
original request.

[#50626608_pgfId-1000218]##The following request attributes must be set:

[width="100%",cols="100%",]
|===
a|
[#50626608_pgfId-1000213]##javax.servlet.async.mapping

[#50626608_pgfId-1001465]##javax.servlet.async.request_uri

[#50626608_pgfId-1000214]##javax.servlet.async.context_path

[#50626608_pgfId-1000215]##javax.servlet.async.servlet_path

[#50626608_pgfId-1000216]##javax.servlet.async.path_info

[#50626608_pgfId-1000217]##javax.servlet.async.query_string

|===

[#50626608_pgfId-1000219]##The values of these attributes must be equal
to the return values of the _HttpServletRequest_ methods _getRequestURI_
, _getContextPath_ , _getServletPath_ , _getPathInfo_ , _getQueryString_
respectively, invoked on the request object passed to the first servlet
object in the call chain that received the request from the client.

[#50626608_pgfId-1000220]##These attributes are accessible from the
dispatched servlet via the _getAttribute_ method on the request object.
Note that these attributes must always reflect the information in the
original request even under the situation that multiple dispatches are
called.

== [#50626596_pgfId-874]## 

=== [#50626596_pgfId-999461]##

image:servlet-34.gif[image]

Web Applications

image:servlet-35.gif[image]

[#50626596_pgfId-999462]##A Web application is a collection of servlets,
HTML pages, classes, and other resources that make up a complete
application on a Web server. The Web application can be bundled and run
on multiple containers from multiple vendors.

==== [#50626596_pgfId-999463]##

image:servlet-36.gif[image]

Web Applications Within Web Servers

[#50626596_pgfId-999464]##A Web application is rooted at a specific path
within a Web server. For example, a catalog application could be located
at _http://www.example.com/catalog_ . All requests that start with this
prefix will be routed to the _ServletContext_ which represents the
catalog application.

[#50626596_pgfId-999465]##A servlet container can establish rules for
automatic generation of Web applications. For example a _~user/_ mapping
could be used to map to a Web application based at __
_/home/user/public_html/_ .

[#50626596_pgfId-999466]##By default, an instance of a Web application
must run on one VM at any one time. This behavior can be overridden if
the application is marked as “distributable” via its deployment
descriptor. An application marked as distributable must obey a more
restrictive set of rules than is required of a normal Web application.
These rules are set out throughout this specification.

==== [#50626596_pgfId-999467]##

image:servlet-36.gif[image]

Relationship to ServletContext

[#50626596_pgfId-999468]##The servlet container must enforce a one to
one correspondence between a Web application and a _ServletContext_ . A
_ServletContext_ object provides a servlet with its view of the
application.

==== [#50626596_pgfId-999469]##

image:servlet-36.gif[image]

Elements of a Web Application

[#50626596_pgfId-999470]##A Web application may consist of the following
items:

[#50626596_pgfId-999471]##Servlets

{empty}[#50626596_pgfId-999475]##JSP™ Pageslink:#pgfId-999474[7]

[#50626596_pgfId-999476]##Utility Classes

[#50626596_pgfId-999477]##Static documents (HTML, images, sounds, etc.)

[#50626596_pgfId-999478]##Client side Java applets, beans, and classes

[#50626596_pgfId-999479]##Descriptive meta information that ties all of
the above elements together

==== [#50626596_pgfId-999480]##

image:servlet-36.gif[image]

Deployment Hierarchies

[#50626596_pgfId-999481]##This specification defines a hierarchical
structure used for deployment and packaging purposes that can exist in
an open file system, in an archive file, or in some other form. It is
recommended, but not required, that servlet containers support this
structure as a runtime representation.

==== [#50626596_pgfId-999483]##

image:servlet-36.gif[image]

[#50626596_27624]##Directory Structure

[#50626596_pgfId-999484]##A Web application exists as a structured
hierarchy of directories. The root of this hierarchy serves as the
document root for files that are part of the application. For example,
for a Web application with the context path _/catalog_ in a Web
container, the _index.html_ file at the base of the Web application
hierarchy or in a JAR file inside WEB-INF/lib that includes the
_index.html_ under _META-INF/resources_ directory can be served to
satisfy a request from _/catalog/index.html_ . If an _index.html_ is
present both in the root context and in the _META-INF/resources_
directory of a JAR file in the _WEB-INF/lib_ directory of the
application, then the file that is available in the root context MUST be
used. The rules for matching URLs to context path are laid out in
link:servlet.htm#50626594_64358[See Mapping Requests to Servlets]. Since
the context path of an application determines the URL namespace of the
contents of the Web application, Web containers must reject Web
applications defining a context path that could cause potential
conflicts in this URL namespace. This may occur, for example, by
attempting to deploy a second Web application with the same context
path. Since requests are matched to resources in a case-sensitive
manner, this determination of potential conflict must be performed in a
case-sensitive manner as well.

[#50626596_pgfId-1000673]##A special directory exists within the
application hierarchy named “ _WEB-INF_ ”. This directory contains all
things related to the application that aren’t in the document root of
the application. Most of the _WEB-INF_ node is not part of the public
document tree of the application. Except for static resources and JSPs
packaged in the _META-INF/resources_ of a JAR file that resides in the
_WEB-INF/lib_ directory, no other files contained in the _WEB-INF_
directory may be served directly to a client by the container. However,
the contents of the _WEB-INF_ directory are visible to servlet code
using the _getResource_ and _getResourceAsStream_ method calls on the
_ServletContext_ , and may be exposed using the _RequestDispatcher_
calls. Hence, if the Application Developer needs access, from servlet
code, to application specific configuration information that he does not
wish to be exposed directly to the Web client, he may place it under
this directory. Since requests are matched to resource mappings in a
case-sensitive manner, client requests for ‘ _/WEB-INF/foo_ ’, ‘
_/WEb-iNf/foo_ ’, for example, should not result in contents of the Web
application located under _/WEB-INF_ being returned, nor any form of
directory listing thereof.

[#50626596_pgfId-999489]##The contents of the _WEB-INF_ directory are:

[#50626596_pgfId-999490]## _The_ _/WEB-INF/web.xml_ __ deployment
descriptor.

[#50626596_pgfId-999491]## _The_ _/WEB-INF/classes/_ directory for
servlet and utility classes. The classes in this directory must be
available to the application class loader.

[#50626596_pgfId-999492]## _The_ _/WEB-INF/lib/*.jar_ area for Java
ARchive files. These files contain servlets, beans, static resources and
JSPs packaged in a JAR file and other utility classes useful to the Web
application. The Web application class loader must be able to load
classes from any of these archive files.

[#50626596_pgfId-999493]##The Web application class loader must load
classes from the _WEB-INF/classes_ directory first, and then from
library JARs in the _WEB-INF/lib_ directory. Also, except for the case
where static resources are packaged in JAR files, any requests from the
client to access the resources in _WEB-INF/_ directory must be returned
with a _SC_NOT_FOUND_ (404) response.

===== [#50626596_pgfId-999494]##Example of Application Directory Structure

[#50626596_pgfId-999495]##The following is a listing of all the files in
a sample Web application:

[width="100%",cols="100%",]
|===
a|
[#50626596_pgfId-999952]##/index.html

[#50626596_pgfId-999953]##/howto.jsp

[#50626596_pgfId-999954]##/feedback.jsp

[#50626596_pgfId-999955]##/images/banner.gif

[#50626596_pgfId-999956]##/images/jumping.gif

[#50626596_pgfId-999957]##/WEB-INF/web.xml

[#50626596_pgfId-999958]##/WEB-INF/lib/jspbean.jar

[#50626596_pgfId-1000703]##
_/WEB-INF/lib/catalog.jar!/META-INF/resources/catalog/moreOffers/books.html_

[#50626596_pgfId-999959]##/WEB-INF/classes/com/mycorp/servlets/MyServlet.class

[#50626596_pgfId-999950]##/WEB-INF/classes/com/mycorp/util/MyUtils.class

|===

==== [#50626596_pgfId-999505]##

image:servlet-36.gif[image]

Web Application Archive File

[#50626596_pgfId-999506]##Web applications can be packaged and signed
into a Web ARchive format (WAR) file using the standard Java archive
tools. For example, an application for issue tracking might be
distributed in an archive file called _issuetrack.war_ .

[#50626596_pgfId-999507]##When packaged into such a form, a _META-INF_
directory will be present which contains information useful to Java
archive tools. This directory must not be directly served as content by
the container in response to a Web client’s request, though its contents
are visible to servlet code via the _getResource_ and
_getResourceAsStream_ calls on the _ServletContext_ . Also, any requests
to access the resources in _META-INF_ directory must be returned with a
_SC_NOT_FOUND_ (404) response.

==== [#50626596_pgfId-999508]##

image:servlet-36.gif[image]

Web Application Deployment Descriptor

[#50626596_pgfId-999511]##The Web application deployment descriptor (see
link:servlet.htm#50626592_84118[See Deployment Descriptor]”) includes
the following types of configuration and deployment information:

[#50626596_pgfId-999513]## _ServletContext_ Init Parameters

[#50626596_pgfId-999514]##Session Configuration

[#50626596_pgfId-999515]##Servlet/JSP Definitions

[#50626596_pgfId-999516]##Servlet/JSP Mappings

[#50626596_pgfId-999517]##MIME Type Mappings

[#50626596_pgfId-999518]##Welcome File list

[#50626596_pgfId-999519]##Error Pages

[#50626596_pgfId-999520]##Security

===== [#50626596_pgfId-999521]##Dependencies On Extensions

[#50626596_pgfId-999522]##When a number of applications make use of the
same code or resources, they will typically be installed as library
files in the container. These files are often common or standard APIs
that can be used without sacrificing portability. Files used only by one
or a few applications will be made available for access as part of the
Web application. The container must provide a directory for these
libraries. The files placed within this directory must be available
across all Web applications. The location of this directory is
container-specific. The class loader the servlet container uses for
loading these library files must be the same for all Web applications
within the same JVM. This class loader instance must be somewhere in the
chain of parent class loaders of the Web application class loader.

[#50626596_pgfId-999523]##Application developers need to know what
extensions are installed on a Web container, and containers need to know
what dependencies servlets in a WAR have on such libraries in order to
preserve portability.

[#50626596_pgfId-999524]##The application developer depending on such an
extension or extensions must provide a _META-INF/MANIFEST.MF_ entry in
the WAR file listing all extensions needed by the WAR. The format of the
manifest entry should follow standard JAR manifest format. During
deployment of the Web application, the Web container must make the
correct versions of the extensions available to the application
following the rules defined by the Optional Package Versioning mechanism
(
_http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/versioning.html_
).

[#50626596_pgfId-999525]##Web containers must also be able to recognize
declared dependencies expressed in the manifest entry of any of the
library JARs under the _WEB-INF/lib_ entry in a WAR.

[#50626596_pgfId-999526]##If a Web container is not able to satisfy the
dependencies declared in this manner, it should reject the application
with an informative error message.

===== [#50626596_pgfId-999527]##[#50626596_73809]##Web Application Class Loader

[#50626596_pgfId-999528]##The class loader that a container uses to load
a servlet in a WAR must allow the developer to load any resources
contained in library JARs within the WAR following normal Java SE
semantics using _getResource_ . As described in the Java EE license
agreement, servlet containers that are not part of a Java EE product
should not allow the application to override Java SE platform classes,
such as those in the java.* and javax.* namespaces, that Java SE does
not allow to be modified. The container should not allow applications to
override or access the container’s implementation classes. It is
recommended also that the application class loader be implemented so
that classes and resources packaged within the WAR are loaded in
preference to classes and resources residing in container-wide library
JARs. An implementation MUST also guarantee that for every web
application deployed in a container, a call to
_Thread.currentThread.getContextClassLoader()_ MUST return a
_ClassLoader_ instance that implements the contract specified in this
section. Furthermore, the _ClassLoader_ instance MUST be a separate
instance for each deployed web application. The container is required to
set the thread context _ClassLoader_ as described above before making
any callbacks (including listener callbacks) into the web application,
and set it back to the original _ClassLoader_ , once the callback
returns.

==== [#50626596_pgfId-999529]##

image:servlet-36.gif[image]

Replacing a Web Application

[#50626596_pgfId-999530]##A server should be able to replace an
application with a new version without restarting the container. When an
application is replaced, the container should provide a robust method
for preserving session data within that application.

==== [#50626596_pgfId-999532]##

image:servlet-36.gif[image]

[#50626596_53091]##Error Handling

===== [#50626596_pgfId-999534]##[#50626596_69376]##Request Attributes

[#50626596_pgfId-999535]##A Web application must be able to specify that
when errors occur, other resources in the application are used to
provide the content body of the error response. The specification of
these resources is done in the deployment descriptor.

[#50626596_pgfId-999536]##If the location of the error handler is a
servlet or a JSP page:

[#50626596_pgfId-999537]##The original unwrapped request and response
objects created by the container are passed to the servlet or JSP page.

[#50626596_pgfId-999538]##The request path and attributes are set as if
a _RequestDispatcher.forward_ to the error resource had been performed.

[#50626596_pgfId-999576]##The request attributes in
link:servlet.htm#50626596_38542[See Request Attributes and their types]
must be set.

======= [#50626596_pgfId-999804]##[#50626596_38542]##Request Attributes and their types

[#50626596_pgfId-999844]##Request Attributes

[#50626596_pgfId-999846]##Type

[#50626596_pgfId-999848]## _javax.servlet.error.status_code_

[#50626596_pgfId-999850]## _java.lang.Integer_

[#50626596_pgfId-999852]## _javax.servlet.error.exception_type_

[#50626596_pgfId-999854]## _java.lang.Class_

[#50626596_pgfId-999856]## _javax.servlet.error.message_

[#50626596_pgfId-999858]## _java.lang.String_

[#50626596_pgfId-999860]## _javax.servlet.error.exception_

[#50626596_pgfId-999862]## _java.lang.Throwable_

[#50626596_pgfId-999864]## _javax.servlet.error.request_uri_

[#50626596_pgfId-999866]## _java.lang.String_

[#50626596_pgfId-999868]## _javax.servlet.error.servlet_name_

[#50626596_pgfId-999870]## _java.lang.String_

[#50626596_pgfId-999577]##These attributes allow the servlet to generate
specialized content depending on the status code, the exception type,
the error message, the exception object propagated, and the URI of the
request processed by the servlet in which the error occurred (as
determined by the _getRequestURI_ call), and the logical name of the
servlet in which the error occurred.

[#50626596_pgfId-999578]##With the introduction of the exception object
to the attributes list for version 2.3 of this specification, the
exception type and error message attributes are redundant. They are
retained for backwards compatibility with earlier versions of the API.

===== [#50626596_pgfId-999579]##[#50626596_49990]##Error Pages

[#50626596_pgfId-999580]##To allow developers to customize the
appearance of content returned to a Web client when a servlet generates
an error, the deployment descriptor defines a list of error page
descriptions. The syntax allows the configuration of resources to be
returned by the container either when a servlet or filter calls
_sendError_ on the response for specific status codes, or if the servlet
generates an exception or error that propagates to the container.

[#50626596_pgfId-999581]##If the _sendError_ method is called on the
response, the container consults the list of error page declarations for
the Web application that use the status-code syntax and attempts a
match. If there is a match, the container returns the resource as
indicated by the location entry.

[#50626596_pgfId-999582]##A servlet or filter may throw the following
exceptions during processing of a request:

[#50626596_pgfId-999583]##runtime exceptions or errors

[#50626596_pgfId-999584]## _ServletExceptions_ or subclasses thereof

[#50626596_pgfId-999585]## _IOExceptions_ or subclasses thereof

[#50626596_pgfId-999586]##The Web application may have declared error
pages using the _exception-type_ element. In this case the container
matches the exception type by comparing the exception thrown with the
list of error-page definitions that use the _exception-type_ element. A
match results in the container returning the resource indicated in the
location entry. The closest match in the class hierarchy wins.

[#50626596_pgfId-999587]##If no _error-page_ declaration containing an
_exception-type_ fits using the class-hierarchy match, and the exception
thrown is a _ServletException_ or subclass thereof, the container
extracts the wrapped exception, as defined by the
_ServletException.getRootCause_ method. A second pass is made over the
error page declarations, again attempting the match against the error
page declarations, but using the wrapped exception instead.

[#50626596_pgfId-999588]##Error-page declarations using the
_exception-type_ element in the deployment descriptor must be unique up
to the class name of the exception-type. Similarly, error-page
declarations using the _status-code_ element must be unique in the
deployment descriptor up to the status code.

[#50626596_pgfId-1001161]##If an _error-page_ element in the deployment
descriptor does not contain an _exception-type_ or an _error-code_
element, the error page is a default error page.

[#50626596_pgfId-999589]##The error page mechanism described does not
intervene when errors occur when invoked using the _RequestDispatcher_
or _filter.doFilter_ method. In this way, a filter or servlet using the
_RequestDispatcher_ has the opportunity to handle errors generated.

[#50626596_pgfId-999590]##If a servlet generates an error that is not
handled by the error page mechanism as described above, the container
must ensure to send a response with status 500.

[#50626596_pgfId-999591]##The default servlet and container will use the
_sendError_ method to send 4xx and 5xx status responses, so that the
error mechanism may be invoked. The default servlet and container will
use the _setStatus_ method for 2xx and 3xx responses and will not invoke
the error page mechanism.

{empty}[#50626596_pgfId-1000848]##If the application is using
asynchronous operations as described in
link:servlet.htm#50626601_53655[See Asynchronous processing], it is the
application’s responsibility to handle all errors in application created
threads. The container MAY take care of the errors from the thread
issued via _AsyncContext.start_ . For handling errors that occur during
_AsyncContext.dispatch_ see link:servlet.htm#50626601_25183[See Any
errors or exceptions that may occur during the execution of the dispatch
methods MUST be caught and handled by the container as follows:]

===== [#50626596_pgfId-1000850]##Error Filters

[#50626596_pgfId-999593]##The error page mechanism operates on the
original unwrapped/unfiltered request and response objects created by
the container. The mechanism described in
link:servlet.htm#50626598_69819[See Filters and the RequestDispatcher]”
may be used to specify filters that are applied before an error response
is generated.

==== [#50626596_pgfId-999597]##

image:servlet-36.gif[image]

Welcome Files

[#50626596_pgfId-999598]##Web Application developers can define an
ordered list of partial URIs called welcome files in the Web application
deployment descriptor. The deployment descriptor syntax for the list is
described in the Web application deployment descriptor schema.

[#50626596_pgfId-999599]##The purpose of this mechanism is to allow the
deployer to specify an ordered list of partial URIs for the container to
use for appending to URIs when there is a request for a URI that
corresponds to a directory entry in the WAR not mapped to a Web
component. This kind of request is known as a valid partial request.

[#50626596_pgfId-999600]##The use for this facility is made clear by the
following common example: A welcome file of ‘ _index.html_ ’ can be
defined so that a request to a URL like _host:port/webapp/directory/_ ,
where ‘ _directory_ ’ is an entry in the WAR that is not mapped to a
servlet or JSP page, is returned to the client as ‘
_host:port/webapp/directory/index.html_ ’.

[#50626596_pgfId-999601]##If a Web container receives a valid partial
request, the Web container must examine the welcome file list defined in
the deployment descriptor. The welcome file list is an ordered list of
partial URLs with no trailing or leading /. The Web server must append
each welcome file in the order specified in the deployment descriptor to
the partial request and check whether a static resource in the WAR is
mapped to that request URI. If no match is found, the Web server MUST
again append each welcome file in the order specified in the deployment
descriptor to the partial request and check if a servlet is mapped to
that request URI. The Web container must send the request to the first
resource in the WAR that matches. The container may send the request to
the welcome resource with a forward, a redirect, or a container specific
mechanism that is indistinguishable from a direct request.

[#50626596_pgfId-999602]##If no matching welcome file is found in the
manner described, the container may handle the request in a manner it
finds suitable. For some configurations this may mean returning a
directory listing or for others returning a _404_ response.

[#50626596_pgfId-999603]##Consider a Web application where:

[#50626596_pgfId-999604]##The deployment descriptor lists the following
welcome files.

[width="100%",cols="100%",]
|===
a|
[#50626596_pgfId-999738]##<welcome-file-list>

[#50626596_pgfId-999739]## <welcome-file>index.html</welcome-file>

[#50626596_pgfId-999740]## <welcome-file>default.jsp</welcome-file>

[#50626596_pgfId-999736]##</welcome-file-list>

|===

[#50626596_pgfId-999609]##The static content in the WAR is as follows

[width="100%",cols="100%",]
|===
a|
[#50626596_pgfId-999750]##/foo/index.html

[#50626596_pgfId-999751]##/foo/default.jsp

[#50626596_pgfId-999752]##/foo/orderform.html

[#50626596_pgfId-999753]##/foo/home.gif

[#50626596_pgfId-999754]##/catalog/default.jsp

[#50626596_pgfId-999755]##/catalog/products/shop.jsp

[#50626596_pgfId-999748]##/catalog/products/register.jsp

|===

[#50626596_pgfId-999617]##A request URI of _/foo_ will be redirected to
a URI of _/foo/_ .

[#50626596_pgfId-999618]##A request URI of _/foo/_ will be returned as
_/foo/index.html_ .

[#50626596_pgfId-999619]##A request URI of _/catalog_ will be redirected
to a URI of _/catalog/_ .

[#50626596_pgfId-999620]##A request URI of _/catalog/_ will be returned
as _/catalog/default.jsp_ .

[#50626596_pgfId-999621]##A request URI of _/catalog/index.html_ will
cause a _404 not found_

[#50626596_pgfId-999622]##A request URI of _/catalog/products_ will be
redirected to a URI of _/catalog/products/_ .

[#50626596_pgfId-999623]##A request URI of _/catalog/products/_ will be
passed to the “default” servlet, if any. If no “default” servlet is
mapped, the request may cause a _404 not found_ , may cause a directory
listing including _shop.jsp_ and _register.jsp_ , or may cause other
behavior defined by the container. See
link:servlet.htm#50626594_44611[See Specification of Mappings]” for the
definition of “default” servlet.

[#50626596_pgfId-1000715]##All of the above static content can also be
packaged in a JAR file with the content listed above packaged in the
_META-INF/resources_ directory of the jar file. The JAR file can then be
included in the _WEB-INF/lib_ directory of the web application.

==== [#50626596_pgfId-999628]##

image:servlet-36.gif[image]

[#50626596_17795]##Web Application Environment

[#50626596_pgfId-999629]##Servlet containers that are not part of a Java
EE technology-compliant implementation are encouraged, but not required,
to implement the application environment functionality described in
link:servlet.htm#50626607_Web%20Application%20Environment[See Web
Application Environment] and the Java EE specification. If they do not
implement the facilities required to support this environment, upon
deploying an application that relies on them, the container should
provide a warning.

==== [#50626596_pgfId-999633]##

image:servlet-36.gif[image]

Web Application Deployment

[#50626596_pgfId-999634]##When a web application is deployed into a
container, the following steps must be performed, in this order, before
the web application begins processing client requests.

[#50626596_pgfId-999635]##Instantiate an instance of each event listener
identified by a _<listener>_ element in the deployment descriptor.

[#50626596_pgfId-999636]##For instantiated listener instances that
implement _ServletContextListener_ , call the _contextInitialized()_
method.

[#50626596_pgfId-999637]##Instantiate an instance of each filter
identified by a _<filter>_ element in the deployment descriptor and call
each filter instance’s _init()_ method.

[#50626596_pgfId-999638]##Instantiate an instance of each servlet
identified by a _<servlet>_ element that includes a _<load-on-startup>_
element in the order defined by the load-on-startup element values, and
call each servlet instance’s _init()_ method.

==== [#50626596_pgfId-999640]##

image:servlet-36.gif[image]

[#50626596_45251]##Inclusion of a web.xml Deployment Descriptor

[#50626596_pgfId-999641]##A web application is NOT required to contain a
web.xml if it does NOT contain any Servlet, Filter, or Listener
components or is using annotations to declare the same. In other words
an application containing only static files or JSP pages does not
require a web.xml to be present.

[#50626596_pgfId-998874]## 

== [#50626595_pgfId-874]## 

=== [#50626595_pgfId-999462]##

image:servlet-37.gif[image]

[#50626595_33976]##Application Lifecycle Events

image:servlet-38.gif[image]

==== [#50626595_pgfId-999463]##

image:servlet-39.gif[image]

Introduction

[#50626595_pgfId-999464]##The application events facility gives the Web
Application Developer greater control over the lifecycle of the
_ServletContext_ and _HttpSession_ and _ServletRequest_ , allows for
better code factorization, and increases efficiency in managing the
resources that the Web application uses.

==== [#50626595_pgfId-999466]##

image:servlet-39.gif[image]

[#50626595_97342]##Event Listeners

[#50626595_pgfId-999467]##Application event listeners are classes that
implement one or more of the servlet event listener interfaces. They are
instantiated and registered in the Web container at the time of the
deployment of the Web application. They are provided by the Developer in
the WAR.

[#50626595_pgfId-999468]##Servlet event listeners support event
notifications for state changes in the _ServletContext_ , _HttpSession_
and _ServletRequest_ objects. Servlet context listeners are used to
manage resources or state held at a JVM level for the application. HTTP
session listeners are used to manage state or resources associated with
a series of requests made into a Web application from the same client or
user. Servlet request listeners are used to manage state across the
lifecycle of servlet requests. Async listeners are used to manage async
events such as time outs and completion of async processing.

[#50626595_pgfId-999469]##There may be multiple listener classes
listening to each event type, and the Developer may specify the order in
which the container invokes the listener beans for each event type.

===== [#50626595_pgfId-999470]##Event Types and Listener Interfaces

[#50626595_pgfId-999473]##Events types and the listener interfaces used
to monitor them are shown in the following tables:

======= [#50626595_pgfId-999676]##Servlet Context Events

[#50626595_pgfId-999700]##Event Type

[#50626595_pgfId-999702]##Description

[#50626595_pgfId-999704]##Listener Interface

[#50626595_pgfId-999706]##Lifecycle

[#50626595_pgfId-999708]##The servlet context has just been created and
is available to service its first request, or the servlet context is
about to be shut down.

[#50626595_pgfId-999710]##javax.servlet.

[#50626595_pgfId-999711]##ServletContextListener

[#50626595_pgfId-999713]##Changes to attributes

[#50626595_pgfId-999715]##Attributes on the servlet context have been
added, removed, or replaced.

[#50626595_pgfId-999717]##javax.servlet.

[#50626595_pgfId-999718]##ServletContextAttributeListener

== [#50626595_pgfId-1000652]##[#50626595_71870]##HTTP Session Events

[#50626595_pgfId-1000658]##Event Type

[#50626595_pgfId-1000660]##Description

[#50626595_pgfId-1000662]##Listener Interface

[#50626595_pgfId-1000664]##Lifecycle

[#50626595_pgfId-1000666]##An _HttpSession_ has been created,
invalidated, or timed out.

[#50626595_pgfId-1000668]## _javax.servlet.http._

[#50626595_pgfId-1000669]## _HttpSessionListener_

[#50626595_pgfId-1000671]##Changes to attributes

[#50626595_pgfId-1000673]##Attributes have been added, removed, or
replaced on an _HttpSession_ .

[#50626595_pgfId-1000675]## _javax.servlet.http_

[#50626595_pgfId-1000676]## _HttpSessionAttributeListener_

[#50626595_pgfId-1000780]##Changes to id

[#50626595_pgfId-1000782]##The id of _HttpSession_ has been changed.

[#50626595_pgfId-1000784]##javax.servlet.http

[#50626595_pgfId-1000785]##HttpSessionIdListener

[#50626595_pgfId-1000678]##Session migration

[#50626595_pgfId-1000680]## _HttpSession_ has been activated or
passivated.

[#50626595_pgfId-1000682]##javax.servlet.http

[#50626595_pgfId-1000683]##HttpSessionActivationListener

[#50626595_pgfId-1000685]##Object binding

[#50626595_pgfId-1000687]##Object has been bound to or unbound from
_HttpSession_

[#50626595_pgfId-1000689]##javax.servlet.http

[#50626595_pgfId-1000690]##HttpSessionBindingListener

== [#50626595_pgfId-999814]##Servlet Request Events

[#50626595_pgfId-999838]##Event Type

[#50626595_pgfId-999840]##Description

[#50626595_pgfId-999842]##Listener Interface

[#50626595_pgfId-999844]##Lifecycle

[#50626595_pgfId-999846]##A servlet request has started being processed
by Web components.

[#50626595_pgfId-999848]## _javax.servlet._

[#50626595_pgfId-999849]## _ServletRequestListener_

[#50626595_pgfId-999851]##Changes to attributes

[#50626595_pgfId-999853]##Attributes have been added, removed, or
replaced on a _ServletRequest_ .

[#50626595_pgfId-999855]## _javax.servlet._

[#50626595_pgfId-999856]## _ServletRequestAttributeListener_

[#50626595_pgfId-1000192]##Async events

[#50626595_pgfId-1000194]##A timeout, connection termination or
completion of async processing

[#50626595_pgfId-1000196]##javax.servlet.AsyncListener

[#50626595_pgfId-999565]##For details of the API, refer to the API
reference.

===== [#50626595_pgfId-999570]##An Example of Listener Use

[#50626595_pgfId-999571]##To illustrate a use of the event scheme,
consider a simple Web application containing a number of servlets that
make use of a database. The Developer has provided a servlet context
listener class for management of the database connection.

[#50626595_pgfId-999572]##When the application starts up, the listener
class is notified. The application logs on to the database, and stores
the connection in the servlet context.

[#50626595_pgfId-999573]##Servlets in the application access the
connection as needed during activity in the Web application.

[#50626595_pgfId-999574]##When the Web server is shut down, or the
application is removed from the Web server, the listener class is
notified and the database connection is closed.

==== [#50626595_pgfId-999575]##

image:servlet-39.gif[image]

Listener Class Configuration

===== [#50626595_pgfId-999576]##Provision of Listener Classes

[#50626595_pgfId-999577]##The Developer of the Web application provides
listener classes implementing one or more of the listener interfaces in
the _javax.servlet_ API. Each listener class must have a public
constructor taking no arguments. The listener classes are packaged into
the WAR, either under the _WEB-INF/classes_ archive entry, or inside a
JAR in the _WEB-INF/lib_ directory.

===== [#50626595_pgfId-999578]##Deployment Declarations

[#50626595_pgfId-1000220]##Listener classes are declared in the Web
application deployment descriptor using the _listener_ element. They are
listed by class name in the order in which they are to be invoked.
Unlike other listeners, listeners of type _AsyncListener_ may only be
registered (with a _ServletRequest_ ) programmatically.

===== [#50626595_pgfId-999580]##[#50626595_58164]##Listener Registration

[#50626595_pgfId-1001164]##The Web container creates an instance of each
listener class and registers it for event notifications prior to the
processing of the first request by the application. The Web container
registers the listener instances according to the interfaces they
implement and the order in which they appear in the deployment
descriptor. During web application execution, listeners for the given
events are mostly invoked in their registration orders, but there are
some exceptions. For instance, _HttpSessionListener.destroy_ are invoked
in reverse order. See link:servlet.htm#50626585_83472[See Assembling the
descriptor from web.xml, web-fragment.xml and annotations]” for details.

===== [#50626595_pgfId-1001168]##Notifications At Shutdown

[#50626595_pgfId-999583]##On application shutdown, listeners are
notified in reverse order to their declarations with notifications to
session listeners preceding notifications to context listeners. Session
listeners must be notified of session invalidations prior to context
listeners being notified of application shutdown.

==== [#50626595_pgfId-999584]##

image:servlet-39.gif[image]

Deployment Descriptor Example

[#50626595_pgfId-999585]##The following example is the deployment
grammar for registering two servlet context lifecycle listeners and an
_HttpSession_ listener.

[#50626595_pgfId-999586]##Suppose that _com.example.MyConnectionManager_
and _com.example.MyLoggingModule_ both implement
_javax.servlet.ServletContextListener_ , and that
_com.example.MyLoggingModule_ additionally implements
_javax.servlet.http.HttpSessionListener_ . Also, the Developer wants
_com.example.MyConnectionManager_ to be notified of servlet context
lifecycle events before _com.example.MyLoggingModule_ . Here is the
deployment descriptor for this application:

[width="100%",cols="100%",]
|===
a|
[#50626595_pgfId-999947]##<web-app>

[#50626595_pgfId-999948]##
<display-name>MyListeningApplication</display-name>

[#50626595_pgfId-999949]## <listener>

[#50626595_pgfId-999950]##
<listener-class>com.example.MyConnectionManager</listener-class>

[#50626595_pgfId-999952]## </listener>

[#50626595_pgfId-999953]## <listener>

[#50626595_pgfId-999954]##
<listener-class>com.example.MyLoggingModule</listener-class>

[#50626595_pgfId-999955]## </listener>

[#50626595_pgfId-999956]## <servlet>

[#50626595_pgfId-999957]##
<display-name>RegistrationServlet</display-name>

[#50626595_pgfId-999958]## ...etc

[#50626595_pgfId-999959]## </servlet>

[#50626595_pgfId-999945]##</web-app>

|===

==== [#50626595_pgfId-999588]##

image:servlet-39.gif[image]

Listener Instances and Threading

[#50626595_pgfId-999589]##The container is required to complete
instantiation of the listener classes in a Web application prior to the
start of execution of the first request into the application. The
container must maintain a reference to each listener instance until the
last request is serviced for the Web application.

[#50626595_pgfId-999590]##Attribute changes to _ServletContext_ and
_HttpSession_ objects may occur concurrently. The container is not
required to synchronize the resulting notifications to attribute
listener classes. Listener classes that maintain state are responsible
for the integrity of the data and should handle this case explicitly.

==== [#50626595_pgfId-999591]##

image:servlet-39.gif[image]

Listener Exceptions

[#50626595_pgfId-999592]##Application code inside a listener may throw
an exception during operation. Some listener notifications occur under
the call tree of another component in the application. An example of
this is a servlet that sets a session attribute, where the session
listener throws an unhandled exception. The container must allow
unhandled exceptions to be handled by the error page mechanism described
in link:servlet.htm#50626596_53091[See Error Handling]”. If there is no
error page specified for those exceptions, the container must ensure to
send a response back with status 500. In this case no more listeners
under that event are called.

[#50626595_pgfId-999596]##Some exceptions do not occur under the call
stack of another component in the application. An example of this is a
_SessionListener_ that receives a notification that a session has timed
out and throws an unhandled exception, or of a _ServletContextListener_
that throws an unhandled exception during a notification of servlet
context initialization, or of a _ServletRequestListener_ that throws an
unhandled exception during a notification of the initialization or the
destruction of the request object. In this case, the Developer has no
opportunity to handle the exception. The container may respond to all
subsequent requests to the Web application with an HTTP status code 500
to indicate an application error.

[#50626595_pgfId-999597]##Developers wishing normal processing to occur
after a listener generates an exception must handle their own exceptions
within the notification methods.

==== [#50626595_pgfId-999598]##

image:servlet-39.gif[image]

Distributed Containers

[#50626595_pgfId-999599]##In distributed Web containers, _HttpSession_
instances are scoped to the particular JVM servicing session requests,
and the _ServletContext_ object is scoped to the Web container’s JVM.
Distributed containers are not required to propagate either servlet
context events or _HttpSession_ events to other JVMs. Listener class
instances are scoped to one per deployment descriptor declaration per
JVM.

==== [#50626595_pgfId-999600]##

image:servlet-39.gif[image]

Session Events

[#50626595_pgfId-999601]##Listener classes provide the Developer with a
way of tracking sessions within a Web application. It is often useful in
tracking sessions to know whether a session became invalid because the
container timed out the session, or because a Web component within the
application called the _invalidate_ method. The distinction may be
determined indirectly using listeners and the _HttpSession_ API methods.

[#50626595_pgfId-998874]## 

== [#50626594_pgfId-874]## 

=== [#50626594_pgfId-999461]##

image:servlet-40.gif[image]

[#50626594_64358]##Mapping Requests to Servlets

image:servlet-41.gif[image]

{empty}[#50626594_pgfId-999462]##The mapping techniques described in
this chapter are required for Web containers mapping client requests to
servlets.link:#pgfId-999465[8]

==== [#50626594_pgfId-999468]##

image:servlet-42.gif[image]

[#50626594_20146]##Use of URL Paths

[#50626594_pgfId-999469]##Upon receipt of a client request, the Web
container determines the Web application to which to forward it. The Web
application selected must have the longest context path that matches the
start of the request URL. The matched part of the URL is the context
path when mapping to servlets. The request URL is decoded as a UTF-8
encoded string. Implementations may provide container vendor specific
configuration to change this encoding or enable more fine-grained
encoding such as using a different encoding for the path and query
string portions of the URL. Note that the encoding used to process the
remainder of the request, after the URL, can be configured as specified
in link:servlet.htm#50626597_21428[See Request data encoding].

[#50626594_pgfId-999470]##The Web container next must locate the servlet
to process the request using the path mapping procedure described below.

[#50626594_pgfId-999471]##The path used for mapping to a servlet is the
request URL from the request object minus the context path and the path
parameters. The URL path mapping rules below are used in order. The
first successful match is used with no further matches attempted:

[#50626594_pgfId-999472]##The container will try to find an exact match
of the path of the request to the path of the servlet. A successful
match selects the servlet.

[#50626594_pgfId-999473]##The container will recursively try to match
the longest path-prefix. This is done by stepping down the path tree a
directory at a time, using the _’_ _/_ _’_ character as a path
separator. The longest match determines the servlet selected.

[#50626594_pgfId-999474]##If the last segment in the URL path contains
an extension (e.g. _.jsp_ ), the servlet container will try to match a
servlet that handles requests for the extension. An extension is defined
as the part of the last segment after the last _’_ _._ _’_ character.

[#50626594_pgfId-999475]##If neither of the previous three rules result
in a servlet match, the container will attempt to serve content
appropriate for the resource requested. If a "default" servlet is
defined for the application, it will be used. Many containers provide an
implicit default servlet for serving content.

[#50626594_pgfId-999476]##The container must use case-sensitive string
comparisons for matching.

==== [#50626594_pgfId-999478]##

image:servlet-42.gif[image]

[#50626594_44611]##Specification of Mappings

[#50626594_pgfId-999479]##In the Web application deployment descriptor,
the following syntax is used to define mappings:

[#50626594_pgfId-999480]##A string beginning with a _‘_ _/_ _’_
character and ending with a _‘_ _/*_ _’_ suffix is used for path
mapping.

[#50626594_pgfId-999481]##A string beginning with a _‘_ _*._ _’_ prefix
is used as an extension mapping.

[#50626594_pgfId-999865]##The empty string ("") is a special URL pattern
that exactly maps to the application's context root, i.e., requests of
the form http://host:port/<context-root>/. In this case the path info is
_’_ _/_ _’_ and the servlet path and context path is empty string (““).

[#50626594_pgfId-999482]##A string containing only the _’_ _/_ _’_
character indicates the "default" servlet of the application. In this
case the servlet path is the request URI minus the context path and the
path info is null.

[#50626594_pgfId-999483]##All other strings are used for exact matches
only.

[#50626594_pgfId-1000062]##If the effective _web.xml_ (after merging
information from fragments and annotations) contains any url-patterns
that are mapped to multiple servlets then the deployment must fail.

===== [#50626594_pgfId-999484]##Implicit Mappings

[#50626594_pgfId-999485]##If the container has an internal JSP
container, the _*.jsp_ extension is mapped to it, allowing JSP pages to
be executed on demand. This mapping is termed an _implicit_ mapping. If
a _*.jsp_ mapping is defined by the Web application, its mapping takes
precedence over the implicit mapping.

[#50626594_pgfId-999486]##A servlet container is allowed to make other
implicit mappings as long as explicit mappings take precedence. For
example, an implicit mapping of _*.shtml_ could be mapped to include
functionality on the server.

===== [#50626594_pgfId-999487]##Example Mapping Set

[#50626594_pgfId-999513]##Consider the following set of mappings:

======= [#50626594_pgfId-999490]##Example Set of Maps

[#50626594_pgfId-999494]##Path Pattern

[#50626594_pgfId-999496]##Servlet

[#50626594_pgfId-999498]## _/foo/bar/*_

[#50626594_pgfId-999500]## _servlet1_

[#50626594_pgfId-999502]## _/baz/*_

[#50626594_pgfId-999504]## _servlet2_

[#50626594_pgfId-999506]## _/catalog_

[#50626594_pgfId-999508]## _servlet3_

[#50626594_pgfId-999510]## _*.bop_

[#50626594_pgfId-999512]## _servlet4_

[#50626594_pgfId-999555]##The following behavior would result:

== [#50626594_pgfId-999516]##Incoming Paths Applied to Example Maps

[#50626594_pgfId-999520]##Incoming Path

[#50626594_pgfId-999522]##Servlet Handling Request

[#50626594_pgfId-999524]## _/foo/bar/index.html_

[#50626594_pgfId-999526]## _servlet1_

[#50626594_pgfId-999528]## _/foo/bar/index.bop_

[#50626594_pgfId-999530]## _servlet1_

[#50626594_pgfId-999532]## _/baz_

[#50626594_pgfId-999534]## _servlet2_

[#50626594_pgfId-999536]## _/baz/index.html_

[#50626594_pgfId-999538]## _servlet2_

[#50626594_pgfId-999540]## _/catalog_

[#50626594_pgfId-999542]## _servlet3_

[#50626594_pgfId-999544]## _/catalog/index.html_

[#50626594_pgfId-999546]##“default” servlet

[#50626594_pgfId-999548]## _/catalog/racecar.bop_

[#50626594_pgfId-999550]## _servlet4_

[#50626594_pgfId-999552]## _/index.bop_

[#50626594_pgfId-999554]## _servlet4_

[#50626594_pgfId-999556]##Note that in the case of _/catalog/index.html_
and _/catalog/racecar.bop_ , the servlet mapped to “ _/catalog_ ” is not
used because the match is not exact.

==== [#50626594_pgfId-998874]##

image:servlet-42.gif[image]

[#50626594_44995]##Runtime Discovery of Mappings

[#50626594_pgfId-1000453]##Every mapping that causes a Servlet to be
activated, regardless of whether or not Servlet Filters are involved, is
discoverable at runtime via the Servlet Mapping API.

===== [#50626594_pgfId-1000662]##Runtime Discovery of Servlet Mappings

[#50626594_pgfId-1000712]##The method _getHttpServletMapping()_ on
_HttpServletRequest_ returns an _HttpServletMapping_ implementation that
provides information for the mapping that caused the current _Servlet_
to be invoked. Please see the javadocs for the normative specification.
Please see sections link:servlet.htm#50626608_86448[See Included Request
Parameters]link:servlet.htm#50626608_33186[See Forwarded Request
Parameters] and link:servlet.htm#50626608_87221[See Dispatched Request
Parameters] for relevant request attributes. As with the included and
forwarded request parameters, the _HttpServletMapping_ is not available
for servlets that have been obtained with a call to
_ServletContext.getNamedDispatcher()_ . __

== [#50626593_pgfId-874]## 

=== [#50626593_pgfId-999461]##

image:servlet-43.gif[image]

Security

image:servlet-44.gif[image]

[#50626593_pgfId-1004522]##Web applications are created by Application
Developers who give, sell, or otherwise transfer the application to a
Deployer for installation into a runtime environment. Application
Developers communicate the security requirements to the Deployers and
the deployment system. This information may be conveyed declaratively
via the application’s deployment descriptor, by using annotations within
the application code, or programmatically via the _setServletSecurity_
method of the _ServletRegistration.Dynamic_ interface.

[#50626593_pgfId-1000615]##This chapter describes the Servlet container
security mechanisms and interfaces and the deployment descriptor,
annotation, and programmatic mechanisms for conveying the security
requirements of applications.

==== [#50626593_pgfId-999464]##

image:servlet-45.gif[image]

Introduction

[#50626593_pgfId-999465]##A web application contains resources that can
be accessed by many users. These resources often traverse unprotected,
open networks such as the Internet. In such an environment, a
substantial number of web applications will have security requirements.

[#50626593_pgfId-999466]##Although the quality assurances and
implementation details may vary, servlet containers have mechanisms and
infrastructure for meeting these requirements that share some of the
following characteristics:

[#50626593_pgfId-999467]## _Authentication_ : The means by which
communicating entities prove to one another that they are acting on
behalf of specific identities that are authorized for access.

[#50626593_pgfId-999468]## _Access control for resources:_ The means by
which interactions with resources are limited to collections of users or
programs for the purpose of enforcing integrity, confidentiality, or
availability constraints.

[#50626593_pgfId-999469]## _Data Integrity:_ The means used to prove
that information has not been modified by a third party while in
transit.

[#50626593_pgfId-999470]## _Confidentiality or Data Privacy:_ The means
used to ensure that information is made available only to users who are
authorized to access it.

==== [#50626593_pgfId-999471]##

image:servlet-45.gif[image]

Declarative Security

[#50626593_pgfId-999472]##Declarative security refers to the means of
expressing an application’s security model or requirements, including
roles, access control, and authentication requirements in a form
external to the application. The deployment descriptor is the primary
vehicle for declarative security in web applications.

[#50626593_pgfId-999473]##The Deployer maps the application’s logical
security requirements to a representation of the security policy that is
specific to the runtime environment. At runtime, the servlet container
uses the security policy representation to enforce authentication and
authorization.

[#50626593_pgfId-999474]##The security model applies to the static
content part of the web application and to servlets and filters within
the application that are requested by the client. The security model
does not apply when a servlet uses the _RequestDispatcher_ to invoke a
static resource or servlet using a _forward_ or an _include_ .

==== [#50626593_pgfId-999475]##

image:servlet-45.gif[image]

[#50626593_85024]##Programmatic Security

[#50626593_pgfId-999476]##Programmatic security is used by security
aware applications when declarative security alone is not sufficient to
express the security model of the application. Programmatic security
consists of the following methods of the _HttpServletRequest_ interface:

[#50626593_pgfId-999477]## _authenticate_

[#50626593_pgfId-1002132]## _login_

[#50626593_pgfId-1000637]##logout

[#50626593_pgfId-1000636]## _getRemoteUser_

[#50626593_pgfId-999478]## _isUserInRole_

[#50626593_pgfId-999479]## _getUserPrincipal_

[#50626593_pgfId-1002133]##The _login_ method allows an application to
perform username and password collection (as an alternative to
Form-Based Login).

[#50626593_pgfId-1004563]##The _authenticate_ methods allow an
application to instigate authentication of the request caller by the
container from within an unconstrained request context.

[#50626593_pgfId-1000649]##The _logout_ method is provided to allow an
application to reset the caller identity of a request.

[#50626593_pgfId-999480]##The _getRemoteUser_ method returns the name of
the remote user (that is, the caller) associated, by the container, with
the request.

[#50626593_pgfId-1000662]##The _isUserInRole_ method determines if the
remote user (that is, the caller) associated with the request is in a
specified security role.

[#50626593_pgfId-1000666]##The _getUserPrincipal_ method determines the
principal name of the remote user (that is, the caller) and returns a
_java.security.Principal_ object corresponding to the remote user.
Calling the _getName_ method on the _Principal_ returned by
_getUserPrincipal_ returns the name of the remote user. These APIs allow
servlets to make business logic decisions based on the information
obtained.

[#50626593_pgfId-999481]##If no user has been authenticated, the
_getRemoteUser_ method returns _null_ , the _isUserInRole_ method always
returns _false_ _,_ and the _getUserPrincipal_ method returns _null_ .

[#50626593_pgfId-1004600]##The _isUserInRole_ method takes a _String_
argument that references an application role. For each distinct role
reference used in a call to isUserInRole, A security-role-ref element
with role-name corresponding to the role reference should be declared in
the deployment descriptor. Each security-role-ref should contain a
role-link sub-element whose value is the name of the application
security role to which the application embedded role reference is
linked. The container uses the security-role-ref with role-name equal to
the role reference to determine which security-role to test the user for
membership in.

[#50626593_pgfId-999482]##For example, to map the security role
reference "FOO" to the security role with role-name "manager" the syntax
would be:

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1000268]##<security-role-ref>

[#50626593_pgfId-1000269]## <role-name>FOO</role-name>

[#50626593_pgfId-1000270]## <role-link>manager</role-link>

[#50626593_pgfId-1000248]##</security-role-ref>

|===

[#50626593_pgfId-999490]##In this case, if a servlet called by a user
belonging to the "manager" security role were to call i
_sUserInRole("FOO")_ the result would be _true_ .

[#50626593_pgfId-1004630]##If no _matching security-role-ref_ exists for
a role reference used in a call to _isUserInRole_ , the container must
default to testing the user for membership in the security-role with
_role-name_ equal to the role reference used in the call.

[#50626593_pgfId-1004631]##The role name “*” should never be used as an
argument in calling _isUserInRole_ . Any call to _isUserInRole_ with “*”
must return false. If the role-name of the security-role to be tested is
“**”, and the application has NOT declared an application security-role
with role-name “**”, _isUserInRole_ must only return true if the user
has been authenticated; that is, only when _getRemoteUser_ and
_getUserPrincipa_ l would both return a non-null value. Otherwise, the
container must check the user for membership in the application role.

[#50626593_pgfId-1004659]##The declaration of _security-role-ref_
elements informs the deployer of the role references used by the
application and for which mappings must be defined.

==== [#50626593_pgfId-1000691]##

image:servlet-45.gif[image]

Programmatic Security Policy Configuration

[#50626593_pgfId-1002973]##This section defines the annotations and apis
provided to configure the security constraints enforced by the Servlet
Container.

===== [#50626593_pgfId-1002986]##@ServletSecurity Annotation

[#50626593_pgfId-1002987]##The @ _ServletSecurity_ annotation provides
an alternative mechanism for defining access control constraints
equivalent to those that could otherwise have been expressed
declaratively via _security-constraint_ elements in the portable
deployment descriptor or programmatically via the _setServletSecurity_
method of the _ServletRegistration_ interface. Servlet containers MUST
support the use of the _@ServletSecurity_ annotation on classes (and
subclasses thereof) that implement the _javax.servlet.Servlet_
interface.

[#50626593_pgfId-1002988]##package javax.servlet.annotation;

[#50626593_pgfId-1002989]##@Inherited

[#50626593_pgfId-1002990]##@Documented

[#50626593_pgfId-1002991]##@Target(value=TYPE)

[#50626593_pgfId-1002992]##@Retention(value=RUNTIME)

[#50626593_pgfId-1002993]##public @interface ServletSecurity \{

[#50626593_pgfId-1003028]## HttpConstraint value();

[#50626593_pgfId-1003223]## HttpMethodConstraint[]
httpMethodConstraints();

[#50626593_pgfId-1003276]##}

======= [#50626593_pgfId-1003253]##The ServletSecurity Interface

[#50626593_pgfId-1003259]##Element

[#50626593_pgfId-1003261]##Description

[#50626593_pgfId-1003263]##Default

[#50626593_pgfId-1003265]## _value_

[#50626593_pgfId-1003267]##the HttpConstraint that defines the
protection to be applied to all HTTP methods that are NOT represented in
the array returned by httpMethodConstraints.

[#50626593_pgfId-1003269]##@HttpConstraint

[#50626593_pgfId-1003271]## _httpMethodConstraints_

[#50626593_pgfId-1003273]##the array of HTTP method specific
constraints.

[#50626593_pgfId-1003275]##\{}

======= [#50626593_pgfId-1003287]##@HttpConstraint

[#50626593_pgfId-1003288]##The _@HttpConstraint_ annotation is used
within the _@ServletSecurity_ annotation to represent the security
constraint to be applied to all HTTP protocol methods for which a
corresponding _@HttpMethodConstraint_ does NOT occur within the
_@ServletSecurity_ annotation.

[#50626593_pgfId-1004674]##For the special case where an
_@HttpConstraint_ that returns all default valueslink:#pgfId-1004673[9]
occurs in combination with at least one _@HttpMethodConstraint_ that
returns other than all default values, the _@HttpConstraint_ represents
that no security constraint is to be applied to any of the HTTP protocol
methods to which a security constraint would otherwise apply. This
exception is made to ensure that such potentially non-specific uses of
_@HttpConstraint_ do not yield constraints that will explicitly
establish unprotected access for such methods; given that they would not
otherwise be covered by a constraint.

[#50626593_pgfId-1003289]##package javax.servlet.annotation;

[#50626593_pgfId-1003290]##@Documented

[#50626593_pgfId-1003291]##@Retention(value=RUNTIME)

[#50626593_pgfId-1003292]##public @interface HttpConstraint \{

[#50626593_pgfId-1003293]## ServletSecurity.EmptyRoleSemantic value();

[#50626593_pgfId-1003294]## java.lang.String[] rolesAllowed();

[#50626593_pgfId-1003295]## ServletSecurity.TransportGuarantee
transportGuarantee();

[#50626593_pgfId-1003327]##}

======= [#50626593_pgfId-1003298]##The HttpConstraint Interface

[#50626593_pgfId-1003304]##Element

[#50626593_pgfId-1003306]##Description

[#50626593_pgfId-1003308]##Default

[#50626593_pgfId-1003310]## _value_

[#50626593_pgfId-1003312]##The default authorization semantic that
applies (only) when rolesAllowed returns an-empty array.

[#50626593_pgfId-1003314]##PERMIT

[#50626593_pgfId-1003316]## _rolesAllowed_

[#50626593_pgfId-1003318]##An array containing the names of the
authorized roles

[#50626593_pgfId-1003320]##\{}

[#50626593_pgfId-1003322]## _transportGuarantee_

[#50626593_pgfId-1003324]##The data protection requirements that must be
satisfied by the connections on which requests arrive.

[#50626593_pgfId-1003326]##NONE

======= [#50626593_pgfId-1003328]##@HttpMethodConstraint

[#50626593_pgfId-1003329]##The _@HttpMethodConstraint_ annotation is
used within the _@ServletSecurity_ annotation to represent security
constraints on specific HTTP protocol messages.

[#50626593_pgfId-1003330]##package javax.servlet.annotation;

[#50626593_pgfId-1003331]##@Documented

[#50626593_pgfId-1003332]##@Retention(value=RUNTIME)

[#50626593_pgfId-1003333]##public @interface HttpMethodConstraint \{

[#50626593_pgfId-1003334]## ServletSecurity.EmptyRoleSemantic value();

[#50626593_pgfId-1003335]## java.lang.String[] rolesAllowed();

[#50626593_pgfId-1003336]## ServletSecurity.TransportGuarantee
transportGuarantee();

[#50626593_pgfId-1003374]##}

======= [#50626593_pgfId-1003339]##The HttpMethodConstraint Interface

[#50626593_pgfId-1003345]##Element

[#50626593_pgfId-1003347]##Description

[#50626593_pgfId-1003349]##Default

[#50626593_pgfId-1003351]##value

[#50626593_pgfId-1003353]##The HTTP protocol method name

[#50626593_pgfId-1003355]## 

[#50626593_pgfId-1003357]## _emptyRoleSemantic_

[#50626593_pgfId-1003359]##The default authorization semantic that
applies (only) when rolesAllowed returns an empty array.

[#50626593_pgfId-1003361]##PERMIT

[#50626593_pgfId-1003363]## _rolesAllowed_

[#50626593_pgfId-1003365]##An array containing the names of the
authorized roles

[#50626593_pgfId-1003367]##\{}

[#50626593_pgfId-1003369]## _transportGuarantee_

[#50626593_pgfId-1003371]##The data protection requirements that must be
satisfied by the connections on which requests arrive.

[#50626593_pgfId-1003373]##NONE

[#50626593_pgfId-1003375]##The _@ServletSecurity_ annotation may be
specified on (that is, targeted to) a _Servlet_ implementation class,
and its value is inherited by subclasses according to the rules defined
for the _@Inherited_ meta-annotation. At most one instance of the
_@ServletSecurity_ annotation may occur on a Servlet implementation
class, and the _@ServletSecurity_ annotation MUST NOT be specified on
(that is, targeted to) a Java method.

[#50626593_pgfId-1003376]##When one or more _@HttpMethodConstraint_
annotations are defined within a _@ServletSecurity_ annotation, each
_@HttpMethodConstraint_ defines the _security-constraint_ that applies
to the HTTP protocol method identified within the
_@HttpMethodConstraint_ . Except for the case where its
_@HttpConstraint_ returns all default values, and where it contains at
least one _@HttpMethodConstraint_ that returns other than all default
values, the _@ServletSecurity_ annotation defines another
_security-constraint_ that applies to all HTTP protocol methods for
which a corresponding _@HttpMethodConstraint_ has not been defined.

[#50626593_pgfId-1003377]##The _security-constraint_ elements defined in
the portable deployment descriptors are authoritative for all the
_url-patterns_ occurring within the constraints.

[#50626593_pgfId-1003378]##When a _security-constraint_ in the portable
deployment descriptor includes a _url-pattern_ that is an exact match
for a pattern mapped to a class annotated with _@ServletSecurity_ , the
annotation must have no effect on the constraints enforced by the
Servlet container on the pattern.

[#50626593_pgfId-1003379]##When _metadata-complete=true_ is defined for
a portable deployment descriptor, the _@ServletSecurity_ annotation does
not apply to any of the _url-patterns_ mapped to (any servlet mapped to)
the annotated class in the deployment descriptor.

[#50626593_pgfId-1003380]##The _@ServletSecurity_ annotation is not
applied to the _url-patterns_ of a _ServletRegistration_ created using
the _addServlet(String, Servlet)_ method of the _ServletContext_
interface, unless the _Servlet_ was constructed by the _createServlet_
method of the _ServletContext_ interface.

[#50626593_pgfId-1003382]##With the exceptions listed above, when a
Servlet class is annotated with _@ServletSecurity_ , the annotation
defines the security constraints that apply to all the _url-patterns_
mapped to all the Servlets mapped to the class.

[#50626593_pgfId-1003383]##When a class has not been annotated with the
_@ServletSecurity_ annotation, the access policy that is applied to a
servlet mapped from that class is established by the applicable
_security-constraint_ elements, if any, in the corresponding portable
deployment descriptor, or barring any such elements, by the constraints,
if any, established programmatically for the target servlet via the
_setServletSecurity_ method of the _ServletRegistration_ interface.

====== [#50626593_pgfId-1003384]##Examples

[#50626593_pgfId-1003385]##The following examples demonstrate the use of
the ServletSecurity annotation.

[#50626593_pgfId-1003386]##for all HTTP methods, no constraints

[#50626593_pgfId-1003387]##@ServletSecurity

[#50626593_pgfId-1003388]##public class Example1 extends HttpServlet \{

[#50626593_pgfId-1003389]##}

[#50626593_pgfId-1003390]##for all HTTP methods, no auth-constraint,
confidential transport required

[#50626593_pgfId-1003391]##@ServletSecurity(@HttpConstraint(transportGuarantee
= TransportGuarantee.CONFIDENTIAL))

[#50626593_pgfId-1003392]##public class Example2 extends HttpServlet \{

[#50626593_pgfId-1003393]##}

[#50626593_pgfId-1003394]##for all HTTP methods, all access denied

[#50626593_pgfId-1003395]##@ServletSecurity(@HttpConstraint(EmptyRoleSemantic.DENY))

[#50626593_pgfId-1003396]##public class Example3 extends HttpServlet \{

[#50626593_pgfId-1003397]##}

[#50626593_pgfId-1003398]##for all HTTP methods, auth-constraint
requiring membership in Role R1

[#50626593_pgfId-1003399]##@ServletSecurity(@HttpConstraint(rolesAllowed
= "R1"))

[#50626593_pgfId-1003400]##public class Example4 extends HttpServlet \{

[#50626593_pgfId-1003401]##}

[#50626593_pgfId-1003402]##for All HTTP methods except GET and POST, no
constraints; for methods GET and POST, auth-constraint requiring
membership in Role R1; for POST, confidential transport required

[#50626593_pgfId-1003403]##@ServletSecurity((httpMethodConstraints = \{

[#50626593_pgfId-1003404]## @HttpMethodConstraint(value = "GET",
rolesAllowed = "R1"),

[#50626593_pgfId-1003405]## @HttpMethodConstraint(value = "POST",
rolesAllowed = "R1",

[#50626593_pgfId-1003406]## transportGuarantee =
TransportGuarantee.CONFIDENTIAL)

[#50626593_pgfId-1003407]## })

[#50626593_pgfId-1003408]##public class Example5 extends HttpServlet \{

[#50626593_pgfId-1003409]##}

[#50626593_pgfId-1003410]##for all HTTP methods except GET
auth-constraint requiring membership in Role R1; for GET, no constraints

[#50626593_pgfId-1003411]##@ServletSecurity(value =
@HttpConstraint(rolesAllowed = "R1"),

[#50626593_pgfId-1003412]## httpMethodConstraints =
@HttpMethodConstraint("GET"))

[#50626593_pgfId-1003413]##public class Example6 extends HttpServlet \{

[#50626593_pgfId-1003414]##}

[#50626593_pgfId-1003415]##for all HTTP methods except TRACE,
auth-constraint requiring membership in Role R1; for TRACE, all access
denied

[#50626593_pgfId-1003416]##@ServletSecurity(value =
@HttpConstraint(rolesAllowed = "R1"),

[#50626593_pgfId-1003417]## httpMethodConstraints =
@HttpMethodConstraint(value="TRACE", emptyRoleSemantic =
EmptyRoleSemantic.DENY))

[#50626593_pgfId-1003418]##public class Example7 extends HttpServlet \{

[#50626593_pgfId-1003419]##}

====== [#50626593_pgfId-1003421]##[#50626593_72879]##Mapping @ServletSecurity to security-constraint

[#50626593_pgfId-1003422]##This section describes the mapping of the
_@ServletSecurity_ annotation to its equivalent representation as
_security-constraint_ elements. It is provided to facilitate enforcement
using the existing _security-constraint_ enforcement mechanism of the
container. The enforcement by Servlet containers, of the
_@ServletSecurity_ annotation must be equivalent in effect to
enforcement, by the container, of the _security-constraint_ elements
resulting from the mapping defined in this section.

[#50626593_pgfId-1003423]##The _@ServletSecurity_ annotation is used to
define one method-independent _@HttpConstraint_ followed by a list of
zero or more _@HttpMethodConstraint_ specifications. The
method-independent constraint is applied to all HTTP methods for which
no HTTP method-specific constraint has been defined.

[#50626593_pgfId-1003424]##When no _@HttpMethodConstraint_ elements are
included, a _@ServletSecurity_ annotation corresponds to a single
_security-constraint_ element containing a _web-resource-collection_
that contains no _http-method_ elements, and thus pertains to all HTTP
methods.

{empty}[#50626593_pgfId-1003425]##The following example depicts the
representation of a _@ServletSecurity_ annotation with no contained
_@HttpMethodConstraint_ annotations as a single _security-constraint_
element. The _url-pattern_ elements defined by the corresponding servlet
(registration) would be included in the _web-resource-collection_ , and
the presence and value of any contained _auth-constraint_ and
_user-data-constraint_ elements would be determined by the mapping of
the _@HttpConstraint_ value as defined in
link:servlet.htm#50626593_82840[See Mapping @HttpConstraint and
@HttpMethodConstraint to XML.]

[#50626593_pgfId-1003429]##mapping @ServletSecurity with no contained
@HttpMethodConstraint

[#50626593_pgfId-1003430]##@ServletSecurity(@HttpConstraint(rolesAllowed
= "Role1"))

[#50626593_pgfId-1003431]##<security-constraint>

[#50626593_pgfId-1003432]## <web-resource-collection>

[#50626593_pgfId-1003433]## <url-pattern>...</url-pattern>

[#50626593_pgfId-1003434]## </web-resource-collection>

[#50626593_pgfId-1003435]## <auth-constraint>

[#50626593_pgfId-1004156]## <role-name>Role1</role-name>

[#50626593_pgfId-1004157]## </auth-constraint>

[#50626593_pgfId-1004158]##</security-constraint>

[#50626593_pgfId-1004917]##When one or more _@HttpMethodConstraint_
elements are specified, the method-independent constraint corresponds to
a single _security-constraint_ containing a _web-resource-collection_
that contains on _http-method-omission_ for each of the HTTP methods
named in the _@HttpMethodConstraint_ elements. The _security-constraint_
containing _http-method-omission_ elements must NOT be created if the
method-independent constraint returns all default values and at least
one _@HttpMethodConstraint_ does not. Each _@HttpMethodConstraint_
corresponds to another _security-constraint_ containing a
_web-resource-collection_ containing an _http-method_ element naming the
corresponding HTTP method.

{empty}[#50626593_pgfId-1003439]##The following example depicts the
mapping of a _@ServletSecurity_ annotation with a single contained
_@HttpMethodConstraint_ to two security-constraint elements. The
_url-pattern_ elements defined by the corresponding servlet
(registration) would be included in the _web-resource-collection_ of
both constraints, and the presence and value of any contained
_auth-constraint_ and _user-data-constraint_ elements would be
determined by the mapping of the associated _@HttpConstraint_ and
_@HttpMethodConstraint_ values as defined in
link:servlet.htm#50626593_82840[See Mapping @HttpConstraint and
@HttpMethodConstraint to XML.]

[#50626593_pgfId-1003443]##mapping @ServletSecurity with contained
@HttpMethodConstraint

[#50626593_pgfId-1003444]##@ServletSecurity(value=@HttpConstraint(rolesAllowed
= "Role1"),

[#50626593_pgfId-1003445]## httpMethodConstraints =
@HttpMethodConstraint(value = "TRACE",

[#50626593_pgfId-1003446]## emptyRoleSemantic = EmptyRoleSemantic.DENY))

[#50626593_pgfId-1003447]## 

[#50626593_pgfId-1004161]##<security-constraint>

[#50626593_pgfId-1003448]## <web-resource-collection>

[#50626593_pgfId-1003449]## <url-pattern>...</url-pattern>

[#50626593_pgfId-1003450]##
<http-method-omission>TRACE</http-method-omission>

[#50626593_pgfId-1003451]## </web-resource-collection>

[#50626593_pgfId-1003452]## <auth-constraint>

[#50626593_pgfId-1003453]## <role-name>Role1</role-name>

[#50626593_pgfId-1003454]## </auth-constraint>

[#50626593_pgfId-1003455]##</security-constraint>

[#50626593_pgfId-1003456]##<security-constraint>

[#50626593_pgfId-1003457]## <web-resource-collection>

[#50626593_pgfId-1003458]## <url-pattern>...</url-pattern>

[#50626593_pgfId-1003459]## <http-method>TRACE</http-method>

[#50626593_pgfId-1003460]## </web-resource-collection>

[#50626593_pgfId-1003461]## <auth-constraint/>

[#50626593_pgfId-1003462]##</security-constraint>

====== [#50626593_pgfId-1003464]##[#50626593_82840]##Mapping @HttpConstraint and @HttpMethodConstraint to XML.

[#50626593_pgfId-1003465]##This section describes the mapping of the
_@HttpConstraint_ and _@HttpMethodConstraint_ annotation values (defined
for use within _@ServletSecurity_ ) to their corresponding
_auth-constraint_ and _user-data-constraint_ representations, These
annotations share a common model for expressing the equivalent of the
_auth-constraint_ and _user-data-constraint_ elements used within the
portable deployment descriptor. That model is composed of the following
3 elements:

[#50626593_pgfId-1003466]## _emptyRoleSemantic_

[#50626593_pgfId-1005661]##the authorization semantic, either _PERMIT_
or _DENY_ , that applies when no roles are named in _rolesAllowed_ . The
default value for this element is _PERMIT_ , and _DENY_ is not supported
in combination with a non-empty _rolesAllowed_ list.

[#50626593_pgfId-1005662]## _rolesAllowed_

[#50626593_pgfId-1005663]## A list containing the names of the
authorized roles. When this list is empty, its meaning depends on the
value of the _emptyRoleSemantic_ . The role name “*” has no special
meaning when included in the list of allowed roles. When the special
role name “**” appears in _rolesAllowed_ , it indicates that user
authentication, independent of role, is required and sufficient. The
default value for this element is an empty list.

[#50626593_pgfId-1005653]## _transportGuarantee_

[#50626593_pgfId-1003471]##The data protection requirements, either
_NONE_ or _CONFIDENTIAL_ , that must be satisfied by the connections on
which requests arrive. This element is equivalent in meaning to a
_user-data-constraint_ containing a _transport-guarantee_ with the
corresponding value. The default value for this element is _NONE_ .

[#50626593_pgfId-1003472]##The following examples depict the
correspondence between the _@HttpConstraint_ model described above and
_auth-constraint_ and _user-data-constraint_ elements in web.xml.

[#50626593_pgfId-1003473]##emptyRoleSemantic=PERMIT, rolesAllowed=\{},
transportGuarantee=NONE

[#50626593_pgfId-1003474]##no constraints

[#50626593_pgfId-1003475]##emptyRoleSemantic=PERMIT, rolesAllowed=\{},
transportGuarantee=CONFIDENTIAL

[#50626593_pgfId-1003476]##<user-data-constraint>

[#50626593_pgfId-1003477]##
<transport-guarantee>CONFIDENTIAL</transport-guarantee>

[#50626593_pgfId-1003478]##</user-data-constraint>

[#50626593_pgfId-1003479]##emptyRoleSemantic=PERMIT,
rolesAllowed=\{Role1}, transportGuarantee=NONE

[#50626593_pgfId-1003480]##<auth-constraint>

[#50626593_pgfId-1003481]##
<security-role-name>Role1</security-role-name>

[#50626593_pgfId-1003482]##</auth-constraint>

[#50626593_pgfId-1003483]##emptyRoleSemantic=PERMIT,
rolesAllowed=\{Role1}, transportGuarantee=CONFIDENTIAL

[#50626593_pgfId-1003484]##<auth-constraint>

[#50626593_pgfId-1003485]##
<security-role-name>Role1</security-role-name>

[#50626593_pgfId-1003486]##</auth-constraint>

[#50626593_pgfId-1003487]##<user-data-constraint>

[#50626593_pgfId-1003488]##
<transport-guarantee>CONFIDENTIAL</transport-guarantee>

[#50626593_pgfId-1003489]##</user-data-constraint>

[#50626593_pgfId-1004040]## 

[#50626593_pgfId-1003490]##emptyRoleSemantic=DENY, rolesAllowed=\{},
transportGuarantee=NONE

[#50626593_pgfId-1003491]##<auth-constraint/>

[#50626593_pgfId-1003492]##emptyRoleSemantic=DENY, rolesAllowed=\{},
transportGuarantee=CONFIDENTIAL

[#50626593_pgfId-1003493]##<auth-constraint/>

[#50626593_pgfId-1003494]##<user-data-constraint>

[#50626593_pgfId-1003495]##
<transport-guarantee>CONFIDENTIAL</transport-guarantee>

[#50626593_pgfId-1003496]##</user-data-constraint>

===== [#50626593_pgfId-1003497]##setServletSecurity of ServletRegistration.Dynamic

[#50626593_pgfId-1003498]##The _setServletSecurity_ method may be used
within a _ServletContextListener_ to define the security constraints to
be applied to the mappings defined for a _ServletRegistration_ .

[#50626593_pgfId-1003499]## _Collection<String>
setServletSecurity(ServletSecurityElement arg);_

[#50626593_pgfId-1003500]##The _javax.servlet.ServletSecurityElement_
argument to _setServletSecurity_ is analogous in structure and model to
the _ServletSecurity_ interface of the _@ServletSecurity_ annotation. As
such, the mappings defined in link:servlet.htm#50626593_72879[See
Mapping @ServletSecurity to security-constraint], apply analogously to
the mapping of a _ServletSecurityElement_ with contained
_HttpConstraintElement_ and _HttpMethodConstraintElement_ values, to its
equivalent _security-constraint_ representation.

[#50626593_pgfId-1003504]##The _setServletSecurity_ method returns the
(possibly empty) Set of URL patterns that are already the exact target
of a _security-constraint_ element in the portable deployment descriptor
(and thus were unaffected by the call).

[#50626593_pgfId-1003505]##This method throws an _IllegalStateException_
if the _ServletContext_ from which the _ServletRegistration_ was
obtained has already been initialized.

[#50626593_pgfId-1003506]##When a _security-constraint_ in the portable
deployment descriptor includes a _url-pattern_ that is an exact match
for a pattern mapped by a _ServletRegistration_ , calls to
_setServletSecurity_ on the _ServletRegistration_ must have no effect on
the constraints enforced by the Servlet container on the pattern.

[#50626593_pgfId-1003507]##With the exceptions listed above and
including when the Servlet class is annotated with _@ServletSecurity_ ,
when _setServletSecurity_ is called on a _ServletRegistration_ it
establishes the security constraints that apply to the _url-patterns_ of
the registration.

[#50626593_pgfId-1002403]## 

==== [#50626593_pgfId-1000682]##

image:servlet-45.gif[image]

Roles

[#50626593_pgfId-999493]##A security role is a logical grouping of users
defined by the Application Developer or Assembler. When the application
is deployed, roles are mapped by a Deployer to principals or groups in
the runtime environment.

[#50626593_pgfId-999494]##A servlet container enforces declarative or
programmatic security for the principal associated with an incoming
request based on the security attributes of the principal. This may
happen in either of the following ways:

[#50626593_pgfId-999495]##A deployer has mapped a security role to a
user group in the operational environment. The user groups to which the
calling principal belongs are retrieved from its security attributes.
The principal is in the security role only if the principal belongs to
the user group to which the security role has been mapped by the
deployer.

[#50626593_pgfId-999496]##A deployer has mapped a security role to a
principal name in a security policy domain. In this case, the principal
name of the calling principal is retrieved from its security attributes.
The principal is in the security role only if the principal name is the
same as a principal name to which the security role was mapped.

==== [#50626593_pgfId-999497]##

image:servlet-45.gif[image]

Authentication

[#50626593_pgfId-999498]##A web client can authenticate a user to a web
server using one of the following mechanisms:

[#50626593_pgfId-999499]##HTTP Basic Authentication

[#50626593_pgfId-999500]##HTTP Digest Authentication

[#50626593_pgfId-999501]##HTTPS Client Authentication

[#50626593_pgfId-999502]##Form Based Authentication

===== [#50626593_pgfId-999503]##HTTP Basic Authentication

[#50626593_pgfId-999504]##HTTP Basic Authentication, which is based on a
username and password, is the authentication mechanism defined in the
HTTP/1.0 specification. A web server requests a web client to
authenticate the user. As part of the request, the web server passes the
_realm_ (a string) in which the user is to be authenticated. The web
client obtains the username and the password from the user and transmits
them to the web server. The web server then authenticates the user in
the specified realm.

[#50626593_pgfId-999505]##Basic Authentication is not a secure
authentication protocol. User passwords are sent in simple base64
encoding, and the target server is not authenticated. Additional
protection can alleviate some of these concerns: a secure transport
mechanism (HTTPS), or security at the network level (such as the IPSEC
protocol or VPN strategies) is applied in some deployment scenarios.

===== [#50626593_pgfId-999506]##HTTP Digest Authentication

[#50626593_pgfId-999507]##Like HTTP Basic Authentication, HTTP Digest
Authentication authenticates a user based on a username and a password.
However, unlike HTTP Basic Authentication, HTTP Digest Authentication
does not send user passwords over the network. In HTTP Digest
authentication the client sends a one-way cryptographic hash of the
password (and additional data). Although passwords are not sent on the
wire, HTTP Digest authentication requires that clear text password
equivalentslink:#pgfId-1002129[10] be avaialble to the authenticating
container so that it can validate received authenticators by calculating
the expected digest. Servlet containers SHOULD support HTTP_DIGEST
authentication.

===== [#50626593_pgfId-999509]##[#50626593_44518]##Form Based Authentication

[#50626593_pgfId-999510]##The look and feel of the “login screen” cannot
be varied using the web browser’s built-in authentication mechanisms.
This specification introduces a required form based authentication
mechanism which allows a Developer to control the look and feel of the
login screens.

[#50626593_pgfId-999511]##The web application deployment descriptor
contains entries for a login form and error page. The login form must
contain fields for entering a username and a password. These fields must
be named _j_username_ and _j_password_ , respectively.

[#50626593_pgfId-999512]##When a user attempts to access a protected web
resource, the container checks the user’s authentication. If the user is
authenticated and possesses authority to access the resource, the
requested web resource is activated and a reference to it is returned.
If the user is not authenticated, all of the following steps occur:

[#50626593_pgfId-999513]##The login form associated with the security
constraint is sent to the client and the URL path and HTTP protocol
method triggering the authentication is stored by the container.

[#50626593_pgfId-999514]##The user is asked to fill out the form,
including the username and password fields.

[#50626593_pgfId-999515]##The client posts the form back to the server.

[#50626593_pgfId-999516]##The container attempts to authenticate the
user using the information from the form.

[#50626593_pgfId-1005097]##If authentication fails, the error page is
returned using either a forward or a redirect, and the status code of
the response is set to 200. The error page contains information about
the failure.

[#50626593_pgfId-999518]##If authentication succeeds, the client is
redirected to the resource using the store URL path.

[#50626593_pgfId-1005195]##When the redirected and authenticated request
arrives at the container, the container restores the request and HTTP
protocol method, and the authenticated user’s principal is checked to
see if it is in an authorized role for accessing the resource.

[#50626593_pgfId-1005171]##If the user is authorized, the request is
accepted for processing by the container.

[#50626593_pgfId-1005261]##The HTTP protocol method of the redirected
request that arrives in step 7, may differ from the HTTP method of the
request that triggered the authentication. As such, following the
redirection of step 6, the form authenticator must process the
redirected request even if authentication is not required for the HTTP
method with which the request arrives. To improve the predictability of
the HTTP method of the redirected request, containers should redirect
(in step 6) using the 303 (SC_SEE_OTHER) status code, except where
interoperability with HTTP 1.0 user agents is required; in which cases
the 302 status code should be used.

[#50626593_pgfId-1005262]##When conducted over an unprotected transport,
Form Based Authentication is subject to some of the same vulnerabilities
as Basic Authentication.

[#50626593_pgfId-1005263]##When the request that is triggering
authentication arrives over a secure transport, or the login page is
subject to a user-data-constraint of CONFIDENTIAL, the login page must
be returned to the user, and submitted to the container over a secure
transport.

[#50626593_pgfId-1005264]##The login page should be subject to a
_user-data-constrain_ t of CONFIDENTIAL, and a _user-data-constraint_ of
CONFIDENTIAL should be included in every _security-constraint_ that
contains a requirement for authentication.

[#50626593_pgfId-1002646]##The login method of the HttpServletRequest
interface provides an alternative means for an application to control
the look and feel of it’s login screens.

====== [#50626593_pgfId-999522]##[#50626593_65870]##Login Form Notes

[#50626593_pgfId-999523]##Form based login and URL based session
tracking can be problematic to implement. Form based login should be
used only when sessions are being maintained by cookies or by SSL
session information.

[#50626593_pgfId-999524]##In order for the authentication to proceed
appropriately, the action of the login form must always be
_j_security_check_ . This restriction is made so that the login form
will work no matter which resource it is for, and to avoid requiring the
server to specify the action field of the outbound form. The login form
should specify _autocomplete=”off”_ on the password form field.

[#50626593_pgfId-999525]##Here is an example showing how the form should
be coded into the HTML page:

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-999857]##<form method=”POST” action=”j_security_check”>

[#50626593_pgfId-999858]##<input type=”text” name=”j_username”>

[#50626593_pgfId-999859]##<input type=”password” name=”j_password”
autocomplete=”off”>

[#50626593_pgfId-999855]##</form>

|===

[#50626593_pgfId-999529]##If the form based login is invoked because of
an HTTP request, the original request parameters must be preserved by
the container for use if, on successful authentication, it redirects the
call to the requested resource.

[#50626593_pgfId-999530]##If the user is authenticated using form login
and has created an HTTP session, the timeout or invalidation of that
session leads to the user being logged out in the sense that subsequent
requests must cause the user to be re-authenticated. The scope of the
logout is the same as that of the authentication: for example, if the
container supports single signon, such as Java EE technology compliant
web containers, the user would need to reauthenticate with any of the
web applications hosted on the web container.

===== [#50626593_pgfId-999531]##HTTPS Client Authentication

[#50626593_pgfId-999532]##End user authentication using HTTPS (HTTP over
SSL) is a strong authentication mechanism. This mechanism requires the
client to possess a Public Key Certificate (PKC). Currently, PKCs are
useful in e-commerce applications and also for a single-signon from
within the browser.

===== [#50626593_pgfId-1001086]##Additional Container Authentication Mechanisms

[#50626593_pgfId-1001087]##Servlet containers should provide public
interfaces that may be used to integrate and configure additional HTTP
message layer authentication mechanisms for use by the container on
behalf of deployed applications. These interfaces should be offered for
use by parties other than the container vendor (including application
developers, system administrators, and system integrators).

[#50626593_pgfId-1001343]##To facilitate portable implementation and
integration of additional container authentication mechanisms, it is
recommended that all Servlet containers implement the Servlet Container
Profile of The Javatm Authentication SPI for Containers (i.e., JSR 196).
The SPI is available for download at:
http://www.jcp.org/en/jsr/detail?id=196

[#50626593_pgfId-1001084]## 

==== [#50626593_pgfId-999533]##

image:servlet-45.gif[image]

Server Tracking of Authentication Information

[#50626593_pgfId-999534]##As the underlying security identities (such as
users and groups) to which roles are mapped in a runtime environment are
environment specific rather than application specific, it is desirable
to:

[#50626593_pgfId-999535]##Make login mechanisms and policies a property
of the environment the web application is deployed in.

[#50626593_pgfId-999536]##Be able to use the same authentication
information to represent a principal to all applications deployed in the
same container, and

[#50626593_pgfId-999537]##Require re-authentication of users only when a
security policy domain boundary has been crossed.

[#50626593_pgfId-999538]##Therefore, a servlet container is required to
track authentication information at the container level (rather than at
the web application level). This allows users authenticated for one web
application to access other resources managed by the container permitted
to the same security identity.

==== [#50626593_pgfId-999540]##

image:servlet-45.gif[image]

Specifying Security Constraints

[#50626593_pgfId-999541]##Security constraints are a declarative way of
defining the protection of web content. A security constraint associates
authorization and or user data constraints with HTTP operations on web
resources. A security constraint, represented as a _security-constraint_
in a deployment descriptor, consists of the following elements:

[#50626593_pgfId-999542]##web resource collection (
_web-resource-collection_ in deployment descriptor)

[#50626593_pgfId-999543]##authorization constraint ( _auth-constraint_
in deployment descriptor)

[#50626593_pgfId-999544]##user data constraint ( _user-data-constraint_
in deployment descriptor)

[#50626593_pgfId-999545]##The HTTP operations and web resources to which
a security constraint applies (i.e. the constrained requests) are
identified by one or more web resource collections. A web resource
collection consists of the following elements:

[#50626593_pgfId-999546]##URL patterns ( _url-pattern_ in deployment
descriptor)

[#50626593_pgfId-999547]##HTTP methods ( _http-method_ or
_http-method-omission_ elements in the deployment descriptor)

[#50626593_pgfId-999548]##An authorization constraint establishes a
requirement for authentication and names the authorization roles
permitted to perform the constrained requests. A user must be a member
of at least one of the named roles to be permitted to perform the
constrained requests. The special role name “*” is a shorthand for all
role names defined in the deployment descriptor. The special role name
“**” is a shorthand for any authenticated user independent of role. When
the special role name “**” appears in an authorization constraint, it
indicates that any authenticated user, independent of role, is
authorized to perform the constrained requests. An authorization
constraint that names no roles indicates that access to the constrained
requests must not be permitted under any circumstances. An authorization
constraint consists of the following element:

[#50626593_pgfId-999549]##role name ( _role-name_ in deployment
descriptor)

[#50626593_pgfId-999550]##A user data constraint establishes a
requirement that the constrained requests be received over a protected
transport layer connection. The strength of the required protection is
defined by the value of the transport guarantee. A transport guarantee
of INTEGRAL is used to establish a requirement for content integrity and
a transport guarantee of CONFIDENTIAL is used to establish a requirement
for confidentiality. The transport guarantee of “NONE” indicates that
the container must accept the constrained requests when received on any
connection including an unprotected one. Containers may impose a
confidential transport guarantee in response to the INTEGRAL value. A
user data constraint consists of the following element:

[#50626593_pgfId-999551]##transport guarantee ( _transport-guarantee_ in
deployment descriptor)

[#50626593_pgfId-999552]##If no authorization constraint applies to a
request, the container must accept the request without requiring user
authentication. If no user data constraint applies to a request, the
container must accept the request when received over any connection
including an unprotected one.

===== [#50626593_pgfId-999553]##[#50626593_36825]##Combining Constraints

[#50626593_pgfId-999554]##For the purpose of combining constraints, an
HTTP method is said to occur within a _web-resource-collection_ when no
HTTP methods are named in the collection, or the collection specifically
names the HTTP method in a contained _http-method_ element, or the
collection contains one or more _http-method-omission_ elements, none of
which names the HTTP method.

[#50626593_pgfId-1001105]##When a url-pattern and HTTP method pair
occurs in combination( i.e, within a _web-resource-collection_ ) in
multiple security constraints, the constraints (on the pattern and
method) are defined by combining the individual constraints. The rules
for combining constraints in which the same pattern and method occur are
as follows:

[#50626593_pgfId-999555]##The combination of authorization constraints
that name roles or that imply roles via the name “*” shall yield the
union of the role names in the individual constraints as permitted
roles. An authorization constraint that names the role “**” shall
combine with authorization constraints that name or imply roles to
permit any authenticated user independent of role. A security constraint
that does not contain an authorization constraint shall combine with
authorization constraints that name or imply roles to allow
unauthenticated access. The special case of an authorization constraint
that names no roles shall combine with any other constraints to override
their affects and cause access to be precluded.

[#50626593_pgfId-999556]##The combination of _user-data-constraints_
that apply to a common _url-pattern_ and _http-method_ shall yield the
union of connection types accepted by the individual constraints as
acceptable connection types. A security constraint that does not contain
a _user-data-constraint_ shall combine with other _user-data-constraint_
to cause the unprotected connection type to be an accepted connection
type.

===== [#50626593_pgfId-999557]##Example

[#50626593_pgfId-999558]##The following example illustrates the
combination of constraints and their translation into a table of
applicable constraints. Suppose that a deployment descriptor contained
the following security constraints.

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1001207]##<security-constraint>

[#50626593_pgfId-1001208]## 

[#50626593_pgfId-1001209]## <web-resource-collection>

[#50626593_pgfId-1001210]## <web-resource-name>precluded
methods</web-resource-name>

[#50626593_pgfId-1001211]## <url-pattern>/*</url-pattern>

[#50626593_pgfId-1001212]## <url-pattern>/acme/wholesale/*</url-pattern>

[#50626593_pgfId-1001213]## <url-pattern>/acme/retail/*</url-pattern>

[#50626593_pgfId-1001214]##
<http-method-omission>GET</http-method-omission>

[#50626593_pgfId-1001215]##
<http-method-omission>POST</http-method-omission>

[#50626593_pgfId-1001216]## </web-resource-collection>

[#50626593_pgfId-1001217]## 

[#50626593_pgfId-1001218]## <auth-constraint/>

[#50626593_pgfId-1001219]## 

[#50626593_pgfId-1001220]##</security-constraint>

[#50626593_pgfId-1001221]## 

[#50626593_pgfId-1001222]##<security-constraint>

[#50626593_pgfId-1001223]## 

[#50626593_pgfId-1001224]## <web-resource-collection>

[#50626593_pgfId-1001225]##
<web-resource-name>wholesale</web-resource-name>

[#50626593_pgfId-1001226]## <url-pattern>/acme/wholesale/*</url-pattern>

[#50626593_pgfId-1001227]## <http-method>GET</http-method>

[#50626593_pgfId-1001228]## <http-method>PUT</http-method>

[#50626593_pgfId-1001229]## </web-resource-collection>

[#50626593_pgfId-1001230]## 

[#50626593_pgfId-1001231]## <auth-constraint>

[#50626593_pgfId-1001232]## <role-name>SALESCLERK</role-name>

[#50626593_pgfId-1001233]## </auth-constraint>

[#50626593_pgfId-1001234]## 

[#50626593_pgfId-1001235]##</security-constraint>

[#50626593_pgfId-1000083]## 

|===

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1000158]##<security-constraint>

[#50626593_pgfId-1000159]## 

[#50626593_pgfId-1000160]## <web-resource-collection>

[#50626593_pgfId-1000161]## <web-resource-name>wholesale
2</web-resource-name>

[#50626593_pgfId-1000162]## <url-pattern>/acme/wholesale/*</url-pattern>

[#50626593_pgfId-1000163]## <http-method>GET</http-method>

[#50626593_pgfId-1000164]## <http-method>POST</http-method>

[#50626593_pgfId-1000165]## </web-resource-collection>

[#50626593_pgfId-1000166]## 

[#50626593_pgfId-1000167]## <auth-constraint>

[#50626593_pgfId-1000168]## <role-name>CONTRACTOR</role-name>

[#50626593_pgfId-1000169]## </auth-constraint>

[#50626593_pgfId-1000170]## 

[#50626593_pgfId-1000171]## <user-data-constraint>

[#50626593_pgfId-1000172]##
<transport-guarantee>CONFIDENTIAL</transport-guarantee>

[#50626593_pgfId-1000173]## </user-data-constraint>

[#50626593_pgfId-1000174]## 

[#50626593_pgfId-1000175]##</security-constraint>

[#50626593_pgfId-1000176]## 

[#50626593_pgfId-1000177]##<security-constraint>

[#50626593_pgfId-1000178]## 

[#50626593_pgfId-1000179]## <web-resource-collection>

[#50626593_pgfId-1000180]##
<web-resource-name>retail</web-resource-name>

[#50626593_pgfId-1000181]## <url-pattern>/acme/retail/*</url-pattern>

[#50626593_pgfId-1000182]## <http-method>GET</http-method>

[#50626593_pgfId-1000183]## <http-method>POST</http-method>

[#50626593_pgfId-1000184]## </web-resource-collection>

[#50626593_pgfId-1000185]## 

[#50626593_pgfId-1000186]## <auth-constraint>

[#50626593_pgfId-1000187]## <role-name>CONTRACTOR</role-name>

[#50626593_pgfId-1000188]## <role-name>HOMEOWNER</role-name>

[#50626593_pgfId-1000189]## </auth-constraint>

[#50626593_pgfId-1000190]## 

[#50626593_pgfId-1000156]##</security-constraint>

|===

[#50626593_pgfId-999625]##The translation of this hypothetical
deployment descriptor would yield the constraints defined in
link:servlet.htm#50626593_50390[See Security Constraint Table].

======= [#50626593_pgfId-999632]##[#50626593_50390]##Security Constraint Table

[#50626593_pgfId-999640]##url-pattern

[#50626593_pgfId-999642]##http-method

[#50626593_pgfId-999644]##permitted roles

[#50626593_pgfId-999646]##supported connection types

[#50626593_pgfId-999648]##/*

[#50626593_pgfId-999650]##all methods except GET, POST

[#50626593_pgfId-1001238]##access

[#50626593_pgfId-999653]##precluded

[#50626593_pgfId-999655]##not constrained

[#50626593_pgfId-999666]##/acme/wholesale/*

[#50626593_pgfId-999668]##all methods except GET, POST

[#50626593_pgfId-999670]##access precluded

[#50626593_pgfId-999672]##not constrained

[#50626593_pgfId-999674]##/acme/wholesale/*

[#50626593_pgfId-999676]##GET

[#50626593_pgfId-999678]##CONTRACTOR

[#50626593_pgfId-999679]##SALESCLERK

[#50626593_pgfId-999681]##not constrained

[#50626593_pgfId-999683]##/acme/wholesale/*

[#50626593_pgfId-999685]##POST

[#50626593_pgfId-999687]##CONTRACTOR

[#50626593_pgfId-999689]##CONFIDENTIAL

[#50626593_pgfId-999700]##/acme/retail/*

[#50626593_pgfId-999702]##all methods except GET, POST

[#50626593_pgfId-999704]##access precluded

[#50626593_pgfId-999706]##not constrained

[#50626593_pgfId-999708]##/acme/retail/*

[#50626593_pgfId-999710]##GET

[#50626593_pgfId-999712]##CONTRACTOR

[#50626593_pgfId-999713]##HOMEOWNER

[#50626593_pgfId-999715]##not constrained

[#50626593_pgfId-999717]##/acme/retail/*

[#50626593_pgfId-999719]##POST

[#50626593_pgfId-999721]##CONTRACTOR

[#50626593_pgfId-999722]##HOMEOWNER

[#50626593_pgfId-999724]##not constrained

===== [#50626593_pgfId-999734]##Processing Requests

[#50626593_pgfId-999735]##When a Servlet container receives a request,
it shall use the algorithm described in
link:servlet.htm#50626594_20146[See Use of URL Paths] to select the
constraints (if any) defined on the _url-pattern_ that is the best match
to the request URI. If no constraints are selected, the container shall
accept the request. Otherwise the container shall determine if the HTTP
method of the request is constrained at the selected pattern. If it is
not, the request shall be accepted. Otherwise, the request must satisfy
the constraints that apply to the HTTP method at the _url-pattern_ .
Both of the following rules must be satisfied for the request to be
accepted and dispatched to the associated servlet.

{empty}[#50626593_pgfId-999736]##The characteristics of the connection
on which the request was received must satisfy at least one of the
supported connection types defined by the constraints. If this rule is
not satisfied, the container shall reject the request and redirect it to
the HTTPS port.link:#pgfId-999739[11]

[#50626593_pgfId-999740]##The authentication characteristics of the
request must satisfy any authentication and role requirements defined by
the constraints. If this rule is not satisfied because access has been
precluded (by an authorization constraint naming no roles), the request
shall be rejected as forbidden and a 403 (SC_FORBIDDEN) status code
shall be returned to the user. If access is restricted to permitted
roles and the request has not been authenticated, the request shall be
rejected as unauthorized and a 401 (SC_UNAUTHORIZED) status code shall
be returned to cause authentication. If access is restricted to
permitted roles and the authentication identity of the request is not a
member of any of these roles, the request shall be rejected as forbidden
and a 403 (SC_FORBIDDEN) status code shall be returned to the user.

===== [#50626593_pgfId-1005375]##[#50626593_93176]##Uncovered HTTP Protocol Methods

[#50626593_pgfId-1005376]##The _security-constraint_ schema provides the
ability to enumerate (including by omission) the HTTP protocol methods
to which the protection requirements defined in a _security-constraint_
apply. When HTTP methods are enumerated within a s _ecurity-constraint_
, the protections defined by the constraint apply only to the methods
established by the enumeration. We refer to the HTTP methods that are
not established by the enumeration as "uncovered" HTTP methods.
Uncovered HTTP methods are NOT protected at all request URLs for which a
_url-pattern_ of the _security-constraint_ is a best match.

[#50626593_pgfId-1005377]##When HTTP methods are not enumerated within a
_security-constrain_ t, the protections defined by the constraint apply
to the complete set of HTTP (extension) methods. In that case, there are
no uncovered HTTP methods at all request URLs for which a _url-pattern_
of the _security-constraint_ is a best match.

[#50626593_pgfId-1005378]##The examples that follow depict the three
ways in which HTTP protocol methods may be left uncovered. The
determination of whether methods are uncovered is made after all the
constraints that apply to a _url-pattern_ have been combined as
described in link:servlet.htm#50626593_36825[See Combining Constraints].

[#50626593_pgfId-1005417]##A _security-constraint_ names one or more
HTTP methods in _http-metho_ d elements. All HTTP methods other than
those named in the constraint are uncovered. +
All HTTP Methods except GET are uncovered.

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1005420]##<security-constraint>

[#50626593_pgfId-1005421]## 

[#50626593_pgfId-1005422]## <web-resource-collection>

[#50626593_pgfId-1005423]##
<web-resource-name>wholesale</web-resource-name>

[#50626593_pgfId-1005424]## <url-pattern>/acme/wholesale/*</url-pattern>

[#50626593_pgfId-1005425]## <http-method>GET</http-method>

[#50626593_pgfId-1005426]## </web-resource-collection>

[#50626593_pgfId-1005427]## 

[#50626593_pgfId-1005428]## <auth-constraint>

[#50626593_pgfId-1005429]## <role-name>SALESCLERK</role-name>

[#50626593_pgfId-1005430]## </auth-constraint>

[#50626593_pgfId-1005431]## 

[#50626593_pgfId-1005432]##</security-constraint>

|===

[#50626593_pgfId-1005434]##A _security-constraint_ names one or more
HTTP methods in _http-method-omissio_ n elements. All HTTP methods named
in the constraint are uncovered. +
GET is uncovered. All other methods are covered by the excluding
_auth-contraint_ .

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1005437]##<security-constraint>

[#50626593_pgfId-1005438]## 

[#50626593_pgfId-1005439]## <web-resource-collection>

[#50626593_pgfId-1005440]##
<web-resource-name>wholesale</web-resource-name>

[#50626593_pgfId-1005441]## <url-pattern>/acme/wholesale/*</url-pattern>

[#50626593_pgfId-1005442]##
<http-method-omission>GET</http-method-omission>

[#50626593_pgfId-1005443]## </web-resource-collection>

[#50626593_pgfId-1005444]## <auth-constraint/>

[#50626593_pgfId-1005445]## 

[#50626593_pgfId-1005446]##</security-constraint>

|===

[#50626593_pgfId-1006477]##A _@ServletSecurity_ annotation includes an
_@HttpConstraint_ that returns all default values and it also includes
at least one _@HttpMethodConstraint_ that returns other than all default
values. All HTTP methods other than those named in an
_@HTTPMethodConstraint_ are uncovered by the annotation. This case is
analogous to case 1, and equivalent use of the _setServletSecurity_
method of the _ServletRegistration_ interface will also produce an
analogous result. +
All HTTP Methods except GET and POST are uncovered.

[width="100%",cols="100%",]
|===
a|
[#50626593_pgfId-1006480]##@ServletSecurity((httpMethodConstraints = \{

[#50626593_pgfId-1006481]## @HttpMethodConstraint(value = "GET",
rolesAllowed = "R1"),

[#50626593_pgfId-1006482]## @HttpMethodConstraint(value = "POST",
rolesAllowed = "R1",

[#50626593_pgfId-1006483]## transportGuarantee =
TransportGuarantee.CONFIDENTIAL)

[#50626593_pgfId-1006484]## })

[#50626593_pgfId-1006485]##public class Example5 extends HttpServlet \{

[#50626593_pgfId-1006486]##}

|===

====== [#50626593_pgfId-1006487]##Rules for Security Constraint Configuration

[#50626593_pgfId-1006488]##Objective: Make sure all HTTP methods at all
constrained URL patterns have the intended security protections (that
is, are covered).

[#50626593_pgfId-1006093]##Do not name HTTP methods in constraints; in
which case, the security protections defined for the URL patterns will
apply to all HTTP methods.

[#50626593_pgfId-1006098]##If you can’t follow rule #1, add the
_<deny-uncovered-http-methods>_ and declare (using the _<http-method>_
element, or equivalent annotation) all the HTTP methods (with security
protections) that are to be allowed at the constrained URL patterns.

[#50626593_pgfId-1006104]##If you can’t follow rule #2, declare
constraints to cover all HTTP methods at each constrained URL pattern.
Use the _<http-method-omission>_ element or the _HttpMethodConstraint_
annotation to represent the set of all HTTP methods other than those
named by _<http-method>_ or _HttpMethodConstraint_ . When using
annotations, use the _HttpConstraint_ annotation to define the security
semantic to be applied to all other HTTP methods and configure
_EmptyRoleSemantic=DENY_ to cause all other HTTP methods to be denied.

====== [#50626593_pgfId-1005509]##Handling Uncovered HTTP Methods

[#50626593_pgfId-1005510]##During application deployment, the container
must inform the deployer of any uncovered HTTP methods present in the
application security constraint configuration resulting from the
combination of the constraints defined for the application. The provided
information must identify the uncovered HTTP protocol methods, and the
corresponding URL patterns at which the HTTP methods are uncovered. The
requirement to notify the deployer may be satisfied by logging the
required information.

[#50626593_pgfId-1005511]##When the _deny-uncovered-http-methods_ flag
is set in the web.xml of an application, the container must deny any
HTTP protocol method when it is used with a request URL for which the
HTTP method is uncovered at the combined security constraint that
applies to the url-pattern that is the best match for the request URL.
The denied request shall be rejected as forbidden and a 403
(SC_FORBIDDEN) status code shall be returned.

[#50626593_pgfId-1005513]##To cause uncovered HTTP methods to be denied,
the deployment system should establish additional excluding
auth-constraints, to cover these HTTP methods at the constrained
url-patterns at which the HTTP methods are uncovered.

[#50626593_pgfId-1005529]##When an application’s security configuration
contains no uncovered methods, the _deny-uncovered-http-methods_ flag
must have no effect on the effective security configuration of the
application.

[#50626593_pgfId-1005530]##Applying the _deny-uncovered-http-methods_
flag to an application whose security configuration contains uncovered
methods, may, in some cases, deny access to resources that must be
accessible in order for the application to function. In such cases, the
security configuration of the application should be completed such that
all uncovered methods are covered by an appropriate constraint
configuration.

[#50626593_pgfId-1005531]##Application Developers should define security
constraint configurations that leave no HTTP methods uncovered, and they
should set the _deny-uncovered-http-methods_ flag to ensure that their
applications do not become dependent on being accessible via uncovered
methods.

[#50626593_pgfId-1005413]##A Servlet container may provide a
configurable option to select whether the default behavior for uncovered
methods is ALLOW or DENY. This option may be configured on a
per-application granularity or larger. Note that setting this default to
DENY may cause some applications to fail.

==== [#50626593_pgfId-999741]##

image:servlet-45.gif[image]

Default Policies

[#50626593_pgfId-1001263]##By default, authentication is not needed to
access resources. Authentication is required when the security
constraints (if any) that contain the _url-pattern_ that is the best
match for the request URI combine to impose an _auth-constraint_ (naming
roles) on the HTTP method of the request. Similarly, a protected
transport is not required unless the security constraints that apply to
the request combine to impose a _user-data-constraint_ (with a protected
_transport-guarantee_ ) on the HTTP method of the request.

==== [#50626593_pgfId-999743]##

image:servlet-45.gif[image]

Login and Logout

[#50626593_pgfId-1001286]##The container establishes the caller identity
of a request prior to dispatching the request to the servlet engine. The
caller identity remains unchanged throughout the processing of the
request or until the application sucessfully calls _authenticate_ ,
_login_ or _logout_ on the request. For asynchronous requests, the
caller identity established at the initial dispatch remains unchanged
until the processing of the overall request completes, or the
application successfully calls _authenticate_ , _login_ or _logout_ on
the request.

[#50626593_pgfId-999744]##Being logged into an application during the
processing of a request, corresponds precisely to there being a valid
non-null caller identity associated with the request as may be
determined by calling _getRemoteUser_ or _getUserPrincipal_ on the
request. A _null_ return value from either of these methods indicates
that the caller is not logged into the application with respect to the
processing of the request.

[#50626593_pgfId-999745]##Containers may create HTTP Session objects to
track login state. If a developer creates a session while a user is not
authenticated, and the container then authenticates the user, the
session visible to developer code after login must be the same session
object that was created prior to login occurring so that there is no
loss of session information.

[#50626593_pgfId-998874]## 

== [#50626592_pgfId-874]## 

=== [#50626592_pgfId-1009100]##

image:servlet-46.gif[image]

[#50626592_84118]##Deployment Descriptor

image:servlet-47.gif[image]

[#50626592_pgfId-1009101]##This chapter specifies the Java™ Servlet
Specification requirements for Web container support of deployment
descriptors. The deployment descriptor conveys the elements and
configuration information of a Web application between Application
Developers, Application Assemblers, and Deployers.

[#50626592_pgfId-999464]##For Java Servlets v.2.4 and greater, the
deployment descriptor is defined in terms of an XML schema document.

[#50626592_pgfId-999465]##For backwards compatibility of applications
written to previous versions of the API, any deployment descriptors
written to comply with earlier versions of the specification, must still
be supported such that apps continue to deploy. For the actual XSD files
(and DTD files for J2EE 1.3 and earlier) please visit <
_http://xmlns.jcp.org/xml/ns/javaee/_ >.

==== [#50626592_pgfId-1009123]##

image:servlet-48.gif[image]

Deployment Descriptor Elements

[#50626592_pgfId-1009124]##The following types of configuration and
deployment information are required to be supported in the Web
application deployment descriptor for all servlet containers:

[#50626592_pgfId-999468]## _ServletContext_ Init Parameters

[#50626592_pgfId-999469]##Session Configuration

[#50626592_pgfId-999470]##Servlet Declaration

[#50626592_pgfId-999471]##Servlet Mappings

[#50626592_pgfId-999472]##Application Lifecyle Listener classes

[#50626592_pgfId-999473]##Filter Definitions and Filter Mappings

[#50626592_pgfId-999474]##MIME Type Mappings

[#50626592_pgfId-999475]##Welcome File list

[#50626592_pgfId-999476]##Error Pages

[#50626592_pgfId-999477]##Locale and Encoding Mappings

[#50626592_pgfId-1009118]##Security configuration, including
login-config, security-constraint, deny-uncovered-http-methods,
security-role, security-role-ref and run-as

==== [#50626592_pgfId-999481]##

image:servlet-48.gif[image]

[#50626592_89500]##Rules for Processing the Deployment Descriptor

[#50626592_pgfId-999482]##This section lists some general rules that Web
containers and developers must note concerning the processing of the
deployment descriptor for a Web application.

[#50626592_pgfId-999483]##Web containers must remove all leading and
trailing whitespace, which is defined as “S(white space)” in XML 1.0 (
_http://www.w3.org/TR/2000/WD-xml-2e-20000814_ ), for the element
content of the text nodes of a deployment descriptor.

[#50626592_pgfId-1011286]##The deployment descriptor must be valid
against the schema. Web containers and tools that manipulate Web
applications have a wide range of options for checking the validity of a
WAR. This includes checking the validity of the deployment descriptor
document held within.

[#50626592_pgfId-1011287]##Additionally, it is recommended that Web
containers and tools that manipulate Web applications provide a level of
semantic checking. For example, it should be checked that a role
referenced in a security constraint has the same name as one of the
security roles defined in the deployment descriptor.

[#50626592_pgfId-999486]##In cases of non-conformant Web applications,
tools and containers should inform the developer with descriptive error
messages. High-end application server vendors are encouraged to supply
this kind of validity checking in the form of a tool separate from the
container.

[#50626592_pgfId-999487]##The sub elements under _web-app_ can be in an
arbitrary order in this version of the specification. Because of the
restriction of XML Schema, The multiplicity of the elements
_distributable_ , _session-config_ , _welcome-file-list_ , _jsp-config_
, _login-config_ , and _locale-encoding-mapping-list_ was changed from
“optional” to “0 or more”. The containers must inform the developer with
a descriptive error message when the deployment descriptor contains more
than one element of _session-config_ , _jsp-config_ , and _login-config_
. The container must concatenate the items in _welcome-file-list_ and
_locale-encoding-mapping-list_ when there are multiple occurrences. The
multiple occurrence of _distributable_ must be treated exactly in the
same way as the single occurrence of _distributable_ .

[#50626592_pgfId-999488]##URI paths specified in the deployment
descriptor are assumed to be in URL-decoded form. The containers must
inform the developer with a descriptive error message when URL contains
_CR(#xD)_ or _LF(#xA)_ . The containers must preserve all other
characters including whitespace in URL.

[#50626592_pgfId-999489]##Containers must attempt to canonicalize paths
in the deployment descriptor. For example, paths of the form _/a/../b_
must be interpreted as _/b_ . Paths beginning or resolving to paths that
begin with _../_ are not valid paths in the deployment descriptor.

[#50626592_pgfId-999490]##URI paths referring to a resource relative to
the root of the WAR, or a path mapping relative to the root of the WAR,
unless otherwise specified, should begin with a leading _/_ .

[#50626592_pgfId-999491]##In elements whose value is an enumerated type,
the value is case sensitive.

==== [#50626592_pgfId-1004357]##

image:servlet-48.gif[image]

[#50626592_12370]##Deployment Descriptor

[#50626592_pgfId-1012705]##The deployment descriptor for this revision
of the specification is available at
_http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd_

==== [#50626592_pgfId-1012707]##

image:servlet-48.gif[image]

[#50626592_34618]##Deployment Descriptor Diagram

[#50626592_pgfId-1011260]##This section illustrates the elements in
deployment descriptor. Attributes are not shown in the diagrams. See
Deployment Descriptor Schema for the detailed information.

[#50626592_pgfId-1011261]##web-app Element

[#50626592_pgfId-1010000]##The _web-app_ element is the root deployment
descriptor for a Web application. This element contains the following
elements.This element has a required attribute _version_ to specify to
which version of the schema the deployment descriptor conforms. All sub
elements under this element can be in an arbitrary order.

======= [#50626592_pgfId-1000736]##[#50626592_87190]##web-app Element Structure

image:servlet-49.gif[image]

[#50626592_pgfId-1000738]##description Element

[#50626592_pgfId-1000739]##The _description_ element is to provide a
text describing the parent element. This element occurs not only under
the _web-app_ element but also under other multiple elements. It has an
optional attribute _xml:lang_ to indicate which language is used in the
description. The default value of this attribute is English (“en”).

[#50626592_pgfId-1000741]##display-name Element

[#50626592_pgfId-1000742]##The _display-name_ contains a short name that
is intended to be displayed by tools. The display name need not to be
unique. This element has an optional attribute _xml:lang_ to specify the
language.

[#50626592_pgfId-1000744]##icon Element

[#50626592_pgfId-1000745]##The _icon_ contains small-icon and large-icon
elements that specify the file names for small and large GIF or JPEG
icon images used to represent the parent element in a GUI tool.

[#50626592_pgfId-1000750]##distributable Element

[#50626592_pgfId-1000751]##The _distributable_ indicates that this Web
application is programmed appropriately to be deployed into a
distributed servlet container.

[#50626592_pgfId-1000753]##context-param Element

[#50626592_pgfId-1000754]##The _context-param_ contains the declaration
of a Web application’s servlet context initialization parameters.

[#50626592_pgfId-1000756]##filter Element

[#50626592_pgfId-1000757]##The _filter_ declares a filter in the Web
application. The filter is mapped to either a servlet or a URL pattern
in the _filter-mapping_ element, using the _filter-name_ value to
reference. Filters can access the initialization parameters declared in
the deployment descriptor at runtime via the FilterConfig interface. The
_filter-name_ element is the logical name of the filter. It must be
unique within the Web application. The element content of _filter-name_
element must not be empty. The _filter-class_ is the fully qualified
class name of the filter. The _init-param_ element contains name-value
pair as an initialization parameter of this filter. The optional
_async-supported_ element, when specified, indicates that the filter
supports asynchronous request processing.

======= [#50626592_pgfId-1000761]##filter Element Structure

image:servlet-50.gif[image]

[#50626592_pgfId-1000762]##filter-mapping Element

[#50626592_pgfId-1000763]##The _filter-mapping_ is used by the container
to decide which filters to apply to a request in what order. The value
of the _filter-name_ must be one of the filter declarations in the
deployment descriptor. The matching request can be specified either
_url-pattern_ or _servlet-name_ .

======= [#50626592_pgfId-1000767]##filter-mapping Element Structure

image:servlet-51.gif[image]

[#50626592_pgfId-1000770]##listener Element

[#50626592_pgfId-1000771]##The _listener_ indicates the deployment
properties for an application listener bean. The sub-element
_listener-class_ declares that a class in the application must be
registered as a Web application listener bean. The value is the fully
qualified classname of the listener class.

======= [#50626592_pgfId-1000775]##listener Element Structure

image:servlet-52.gif[image]

[#50626592_pgfId-1000776]##servlet Element

[#50626592_pgfId-1000777]##The _servlet_ is used to declare a servlet.
It contains the declarative data of a servlet. The _jsp-file_ element
contains the full path to a JSP file within the web application
beginning with a “/”. If a _jsp-file_ is specified and the
_load-on-startup_ element is present, then the JSP should be precompiled
and loaded. The _servlet-name_ element contains the canonical name of
the servlet. Each servlet name is unique within the web application. The
element content of _servlet-name_ must not be empty. The _servlet-class_
contains the fully qualified class name of the servlet. The _run-as_
element specifies the identity to be used for the execution of a
component. It contains an optional _description_ , and the name of a
security role specified by the _role-name_ element. The element
_load-on-startup_ indicates that this servlet should be loaded
(instantiated and have its init() called) on the startup of the Web
application. The element content of this element must be an integer
indicating the order in which the servlet should be loaded. If the value
is a negative integer, or the element is not present, the container is
free to load the servlet whenever it chooses. If the value is a positive
integer or 0, the container must load and initialize the servlet as the
application is deployed. The container must guarantee that servlets
marked with lower integers are loaded before servlets marked with higher
integers. The container may choose the order of loading of servlets with
the same _load-on-startup_ value. The _security-role-ref_ element
declares the security role reference in a component’s or in a deployment
component’s code. It consists of an optional _description_ , the
security role name used in the code ( _role-name_ ), and an optional
link to a security role ( _role-link_ ). If the security role is not
specified, the deployer must choose an appropriate security role. The
optional _async-supported_ element, when specified, indicates that the
Servlet can support asynchronous request processing. If a servlet
supports fileupload functionality and processing of mime-multipart
requests, the configuration for the same can be provided via the
_multipart-config_ element in the descriptor. The _multipart-config_
element can be used to specify the location where the files can be
stored, maximum size of the file being uploaded, maximum request size
and the size threshold after which the file will be written to the disk.

======= [#50626592_pgfId-1000781]##servlet Element Structure

image:servlet-53.gif[image]

[#50626592_pgfId-1000789]##servlet-mapping Element

[#50626592_pgfId-1000790]##The _servlet-mapping_ defines a mapping
between a servlet and a URL pattern.

======= [#50626592_pgfId-1000794]##servlet-mapping Element Structure

image:servlet-54.gif[image]

[#50626592_pgfId-1000795]##session-config Element

[#50626592_pgfId-1010681]##The _session-config_ defines the session
parameters for this Web application. The sub-element _session-timeout_
defines the default session time out interval for all sessions created
in this Web application. The specified time out must be expressed in a
whole number of minutes. If the time out is 0 or less, the container
ensures the default behavior of sessions is never to time out. If this
element is not specified, the container must set its default time out
period.

======= [#50626592_pgfId-1010685]##session-config Element Structure

image:servlet-55.gif[image]

[#50626592_pgfId-1000801]##mime-mapping Element

[#50626592_pgfId-1000802]##The _mime-mapping_ defines a mapping between
an extension and a mime type. The _extension_ element contains a string
describing an extension, such as “txt”.

======= [#50626592_pgfId-1000806]##mime-mapping Element Structure

image:servlet-56.gif[image]

[#50626592_pgfId-1000811]##welcome-file-list Element

[#50626592_pgfId-1000812]##The _welcome-file-list_ contains an ordered
list of welcome files. The sub-element _welcome-file_ contains a file
name to use as a default welcome file, such as index.html

======= [#50626592_pgfId-1000816]##welcome-file-list Element Structure

image:servlet-57.gif[image]

[#50626592_pgfId-1000817]##error-page Element

[#50626592_pgfId-1000818]##The _error-page_ contains a mapping between
an error code or an exception type to the path of a resource in the Web
application. However, the _error-code_ or the _exception-type_ element
can be omitted to specify a default error page. The sub-element
_exception-type_ contains a fully qualified class name of a Java
exception type. The sub-element _location_ element contains the location
of the resource in the web application relative to the root of the web
application. The value of the location must have a leading ‘/’.

======= [#50626592_pgfId-1000822]##error-page Element Structure

image:servlet-58.gif[image]

[#50626592_pgfId-1000833]##jsp-config Element

[#50626592_pgfId-1000834]##The _jsp-config_ is used to provide global
configuration information for the JSP files in a web application. It has
two sub-elements, _taglib_ and _jsp-property-group_ . The _taglib_
element can be used to provide information on a tag library that is used
by a JSP page within the Web application. See JavaServer Pages
specification version 2.1 for detail.

======= [#50626592_pgfId-1000838]##jsp-config Element Structure

image:servlet-59.gif[image]

[#50626592_pgfId-1000839]##security-constraint Element

[#50626592_pgfId-1000840]##The _security-constraint_ is used to
associate security constraints with one or more web resource
collections. The sub-element _web-resource-collection_ indentifies a
subset of the resources and HTTP methods on those resources within a Web
application to which a security constraint applies. The
_auth-constraint_ indicates the user roles that should be permitted
access to this resource collection. The _role-name_ used here must
either correspond to the _role-name_ of one of the _security-role_
elements defined for this Web application, or be the specially reserved
role-name "*" that is a compact syntax for indicating all roles in the
web application. If both "*" and role names appear, the container
interprets this as all roles. If no roles are defined, no user is
allowed access to the portion of the Web application described by the
containing _security-constraint_ . The container matches role names case
sensitively when determining access. The _user-data-constraint_
indicates how data communicated between the client and container should
be protected by the sub-element _transport-guarantee_ . The legal values
of the _transport-guarantee_ is either one of _NONE_ , _INTEGRAL_ , or
_CONFIDENTIAL_ .

======= [#50626592_pgfId-1000845]##security-constraint Element Structure

image:servlet-60.gif[image]

[#50626592_pgfId-1000846]##deny-uncovered-http-methods Element

[#50626592_pgfId-1013521]##The _deny-uncovered-http-methods_ is used to
indicate whether the uncovered http methods are to be denied. For every
url-pattern that is the target of a security-constraint, this element
causes all HTTP methods that are NOT covered (by a security constraint)
at the url-pattern to be denied.

[#50626592_pgfId-1013151]##login-config Element

[#50626592_pgfId-1000847]##The _login-config_ is used to configure the
authentication method that should be used, the realm name that should be
used for this application, and the attributes that are needed by the
form login mechanism. The sub-element _auth-method_ configures the
authentication mechanism for the Web application. The element content
must be either _BASIC_ , _DIGEST_ , _FORM_ , _CLIENT-CERT_ , or a
vendor-specific authentication scheme. The _realm-name_ indicates the
realm name to use for the authentication scheme chosen for the Web
application. The _form-login-config_ specifies the login and error pages
that should be used in FORM based login. If FORM based login is not
used, these elements are ignored.

======= [#50626592_pgfId-1000852]##login-config Element Structure

image:servlet-61.gif[image]

[#50626592_pgfId-1000853]##security-role Element

[#50626592_pgfId-1000854]##The _security-role_ defines a security role.
The sub-element _role-name_ designates the name of the security role.
The name must conform to the lexical rules for _NMTOKEN_ .

======= [#50626592_pgfId-1000858]##security-role Element Structure

image:servlet-62.gif[image]

[#50626592_pgfId-1000859]##env-entry Element

[#50626592_pgfId-1000860]##The _env-entry_ declares an application’s
environment entry. The sub-element _env-entry-name_ contains the name of
a deployment component’s environment entry. The name is a JNDI name
relative to the _java:comp/env_ context. The name must be unique within
a deployment component. The _env-entry-type_ contains the
fully-qualified Java type of the environment entry value that is
expected by the application’s code. The sub-element _env-entry-value_
designates the value of a deployment component’s environment entry. The
value must be a _String_ that is valid for the constructor of the
specified type that takes a single _String_ as a parameter, or a single
character for _java.lang.Character_ . The optional _injection-target_
element is used to define the injection of the named resource into
fields or JavaBeans properties. An _injection-target_ specifies a class
and a name within that class into which a resource should be injected.
The _injection-target-class_ specifies the fully qualified class name
that is the target of the injection. The _injection-target-name_
specifies the target within the specified class. The target is first
looked for as a JavaBean property name. If not found, the target is
looked for as a field name. The specified resource will be injected into
the target during initialization of the class by either calling the set
method for the target property or by setting a value into the name
filed. If an _injection-target_ is specified for the environment entry,
the _env-entry-type_ may be ommitted or MUST match the type of the
injection target. If no _injection-target_ is specified, the
_env-entry-type_ is required.

======= [#50626592_pgfId-1000864]##env-entry Element Structure

image:servlet-63.gif[image]

[#50626592_pgfId-1000865]##ejb-ref Element

[#50626592_pgfId-1011048]##The _ejb-ref_ declares the reference to an
enterprise bean’s home. The _ejb-ref-name_ specifies the name used in
the code of the deployment component that is referencing the enterprise
bean. The _ejb-ref-type_ is the expected type of the referenced
enterprise bean, which is either _Entity_ or _Session_ . The _home_
defines the fully qualified name of the referenced enterprise bean’s
home interface. The _remote_ defines the fully qualified name of the
referenced enterprise bean’s remote interface. The _ejb-link_ specifies
that an EJB reference is linked to the enterprise bean. See Java
Platform, Enterprise Edition, version 6 for more detail. In addition to
these elements, the injection-target element can be used to define
injection of the named enterprise bean into a component field or
property.

======= [#50626592_pgfId-1011052]##ejb-ref Element Structure

image:servlet-64.gif[image]

[#50626592_pgfId-1000873]##ejb-local-ref Element

[#50626592_pgfId-1000874]##The _ejb-local-ref_ declares the reference to
the enterprise bean’s local home. The _local-home_ defines the fully
qualified name of the enterprise bean’s local home interface. The
_local_ defines the fully qualified name of the enterprise bean’s local
interface.

======= [#50626592_pgfId-1000878]##ejb-local-ref Element Structure

image:servlet-65.gif[image]

[#50626592_pgfId-1000879]##service-ref Element

[#50626592_pgfId-1000880]##The _service-ref_ declares the reference to a
Web service. The _service-ref-name_ declares the logical name that the
components in the module use to look up the Web service. It is
recommended that all service reference names start with _/service/_ .
The _service-interface_ defines the fully qualified class name of the
JAX-WS Service interface that the client depends on. In most cases, the
value will be javax.xml.rpc.Service. A JAX-WS generated Service
Interface class may also be specified. The _wsdl-file_ element contains
the URI location of a WSDL file. The location is relative to the root of
the module. The _jaxrpc-mapping-file_ contains the name of a file that
describes the JAX-WS mapping between the Java interaces used by the
application and the WSDL description in the _wsdl-file_ . The file name
is a relative path within the module file. The _service-qname_ element
declares the specific WSDL service element that is being referred to. It
is not specified if no _wsdl-file_ is declared. The _port-component-ref_
element declares a client dependency on the container for resolving a
Service Endpoint Interface to a WSDL port. It optionally associates the
Service Endpoint Interface with a particular port-component. This is
only used by the container for a Service.getPort(Class) method call. The
_handler_ element declares the handler for a port-component. Handlers
can access the _init-param_ name-value pairs using the _HandlerInfo_
interface. If _port-name_ is not specified, the handler is assumed to be
associated with all ports of the service. See JSR-109 Specification
_http://www.jcp.org/en/jsr/detail?id=109_ for detail. The container that
is not a part of a Java EE implementation is not required to support
this element.

======= [#50626592_pgfId-1000884]##service-ref Element Structure

image:servlet-66.gif[image]

[#50626592_pgfId-1000885]##resource-ref Element

[#50626592_pgfId-1000886]##The _resource-ref_ contains the declaration
of a deployment component’s reference to the external resource. The
_res-ref-name_ specifies the name of a resource manager connection
factory reference. The name is a JNDI name relative to the
_java:comp/env_ context. The name must be unique within a deployment
file. The _res-type_ element specifies the type of the data source.The
type is the fully qualified Java language class or the interface
expected to be implemented by the data source. The _res-auth_ specifies
whether the deployment component code signs on programmatically to the
resource manager, or whether the container will sign on to the resource
manager on behalf of the deployment component. In the latter case, the
container uses the information supplied by the deployer. The
_res-sharing-scope_ specifies whether connections obtained through the
given resource manager connection factory reference can be shared. The
value, if specified, must be either _Shareable_ or _Unshareable_ . The
optional _injection-target_ element is used to define injection of the
named resource into fields or JavaBeans properties.

======= [#50626592_pgfId-1000890]##resource-ref Element Structure

image:servlet-67.gif[image]

[#50626592_pgfId-1000891]##resource-env-ref Element

[#50626592_pgfId-1000892]##The _resource-env-ref_ contains the
deployment component’s reference to the administered object associated
with a resource in the deployment component’s environment. The
_resource-env-ref-name_ specifies the name of the resource environment
reference. The value is the environment entry name used in the
deployment component code and is a JNDI name relative to the
_java:comp/env_ context and must be unique within the deployment
component. The _resource-env-ref-type_ specifies the type of the
resource environment reference. It is the fully qualified name of a Java
language class or the interface. The optional _injection-target_ element
is used to define injection of the named resource into fields or
JavaBeans properties. The _resource-env-ref-type_ MUST be supplied
unless an injection target is specified, in which case the type of the
target is used. If both are specified, the type MUST be assignment
compatible with the type of the injection target.

======= [#50626592_pgfId-1000896]##resource-env-ref Element Structure

image:servlet-68.gif[image]

[#50626592_pgfId-1000897]##message-destination-ref Element

[#50626592_pgfId-1000898]##The _message-destination-ref_ element
contains a declaration of deployment component’s reference to a message
destination associated with a resource in deployment component’s
environment. The _message-destination-ref-name_ element specifies the
name of a message destination reference; its value is the environment
entry name used in deployment component code. The name is a JNDI name
relative to the _java:comp/env_ context and must be unique within an
ejb-jar for enterprise beans or a deployment file for others. The
_message-destination-type_ specifies the type of the destination. The
type is specified by the Java interface expected to be implemented by
the destination. The _message-destination-usage_ specifies the use of
the message destination indicated by the reference. The value indicates
whether messages are consumed from the message destination, produced for
the destination, or both. The Assembler makes use of this information in
linking producers of a destination with its consumers. The
_message-destination-link_ links a message destination reference or
message-driven bean to a message destination. The Assembler sets the
value to reflect the flow of messages between producers and consumers in
the application. The value must be the _message-destination-name_ of a
message destination in the same deployment file or in another deployment
file in the same Java EE application unit. Alternatively, the value may
be composed of a path name specifying a deployment file containing the
referenced message destination with the _message-destination-name_ of
the destination appended and separated from the path name by "#". The
path name is relative to the deployment file containing deployment
component that is referencing the message destination. This allows
multiple message destinations with the same name to be uniquely
identified. The optional _injection-target_ element is used to define
injection of the named resource into fields or JavaBeans properties. The
message-destination-type MUST be specified unless an injection target is
specified, in which case the type of the target is used. If both are
specified, the type MUST be assignment compatible with the type of the
injection target.

[#50626592_pgfId-1000900]##Example:

[width="100%",cols="100%",]
|===
a|
[#50626592_pgfId-1001635]##<message-destination-ref>

[#50626592_pgfId-1001636]## <message-destination-ref-name>

[#50626592_pgfId-1001671]## jms/StockQueue

[#50626592_pgfId-1001672]## </message-destination-ref-name>

[#50626592_pgfId-1001637]## <message-destination-type>

[#50626592_pgfId-1001673]## javax.jms.Queue

[#50626592_pgfId-1001674]## </message-destination-type>

[#50626592_pgfId-1001638]## <message-destination-usage>

[#50626592_pgfId-1001675]## Consumes

[#50626592_pgfId-1001676]## </message-destination-usage>

[#50626592_pgfId-1001639]## <message-destination-link>

[#50626592_pgfId-1001677]## CorporateStocks

[#50626592_pgfId-1001678]## </message-destination-link>

[#50626592_pgfId-1001633]##</message-destination-ref>

|===

======= [#50626592_pgfId-1000911]##message-destination-ref Element Structure

image:servlet-69.gif[image]

[#50626592_pgfId-1000912]##message-destination Element

[#50626592_pgfId-1000913]##The message-destination specifies a message
destination. The logical destination described by this element is mapped
to a physical destination by the deployer. The message-destination-name
element specifies a name for a message destination. This name must be
unique among the names of message destinations within the deployment
file.

[#50626592_pgfId-1000915]##Example:

[width="100%",cols="100%",]
|===
a|
[#50626592_pgfId-1001701]##<message-destination>

[#50626592_pgfId-1001702]## <message-destination-name>

[#50626592_pgfId-1001713]## CorporateStocks

[#50626592_pgfId-1001714]## </message-destination-name>

[#50626592_pgfId-1001699]##</message-destination>

|===

======= [#50626592_pgfId-1000923]##message-destination Element Structure

image:servlet-70.gif[image]

[#50626592_pgfId-1000926]##locale-encoding-mapping-list Element

[#50626592_pgfId-1000927]##The _locale-encoding-mapping-list_ contains
the mapping between the locale and the encoding. specified by the
sub-element _locale-encoding-mapping_ .

[#50626592_pgfId-1000929]##Example:

[width="100%",cols="100%",]
|===
a|
[#50626592_pgfId-1001739]##<locale-encoding-mapping-list>

[#50626592_pgfId-1001740]## <locale-encoding-mapping>

[#50626592_pgfId-1001741]## <locale>ja</locale>

[#50626592_pgfId-1001742]## <encoding>Shift_JIS</encoding>

[#50626592_pgfId-1001743]## </locale-encoding-mapping>

[#50626592_pgfId-1001737]##</locale-encoding-mapping-list>

|===

======= [#50626592_pgfId-1000939]##locale-encoding-mapping-list Element Structure

image:servlet-71.gif[image]

[#50626592_pgfId-1014016]##[#50626592_20617]##default-context-path
Element

[#50626592_pgfId-1014064]##The _default-context-path_ provides a default
context path of the web application. An empty value for this element
must cause the web application to be deployed at the root for the
container. Otherwise, the default context path must start with a “/”
character but not end with a “/” character. Servlet containers may
provide vendor specific configuration options that allows specifying a
value that overrides the value specified here.

[#50626592_pgfId-1015557]##[#50626592_70192]##request-character-encoding
Element

[#50626592_pgfId-1015630]##The _request-character-encoding_ provides a
default request character encoding of the web application.

[#50626592_pgfId-1015594]##[#50626592_86146]##response-character-encoding
Element

[#50626592_pgfId-1015735]##The _response-character-encoding_ provides a
default response character encoding of the web application.

==== [#50626592_pgfId-1000940]##

image:servlet-48.gif[image]

Examples

[#50626592_pgfId-1000941]##The following examples illustrate the usage
of the definitions listed in the deployment descriptor schema.

===== [#50626592_pgfId-1000942]##A Basic Example

======= [#50626592_pgfId-1008272]##Basic Deployment Descriptor Example

[#50626592_pgfId-1008274]##<?xml version="1.0" encoding="UTF-8"?>

[#50626592_pgfId-1015133]##<web-app
xmlns="http://xmlns.jcp.org/xml/ns/javaee" +
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
web-app_4_0.xsd" +
version="4.0">

[#50626592_pgfId-1008288]## <display-name>A Simple
Application</display-name>

[#50626592_pgfId-1008290]## <context-param>

[#50626592_pgfId-1008292]## <param-name>Webmaster</param-name>

[#50626592_pgfId-1008294]##
<param-value>webmaster@example.com</param-value>

[#50626592_pgfId-1008296]## </context-param>

[#50626592_pgfId-1008298]## <servlet>

[#50626592_pgfId-1008300]## <servlet-name>catalog</servlet-name>

[#50626592_pgfId-1008302]## <servlet-class>com.example.CatalogServlet

[#50626592_pgfId-1008304]## </servlet-class>

[#50626592_pgfId-1008306]## <init-param>

[#50626592_pgfId-1008308]## <param-name>catalog</param-name>

[#50626592_pgfId-1008310]## <param-value>Spring</param-value>

[#50626592_pgfId-1008312]## </init-param>

[#50626592_pgfId-1008314]## </servlet>

[#50626592_pgfId-1008316]## <servlet-mapping>

[#50626592_pgfId-1008318]## <servlet-name>catalog</servlet-name>

[#50626592_pgfId-1008320]## <url-pattern>/catalog/*</url-pattern>

[#50626592_pgfId-1008322]## </servlet-mapping>

[#50626592_pgfId-1008324]## <session-config>

[#50626592_pgfId-1008326]## <session-timeout>30</session-timeout>

[#50626592_pgfId-1008328]## </session-config>

[#50626592_pgfId-1008330]## <mime-mapping>

[#50626592_pgfId-1008332]## <extension>pdf</extension>

[#50626592_pgfId-1008334]## <mime-type>application/pdf</mime-type>

[#50626592_pgfId-1008336]## </mime-mapping>

[#50626592_pgfId-1008338]## <welcome-file-list>

[#50626592_pgfId-1008340]## <welcome-file>index.jsp</welcome-file>

[#50626592_pgfId-1008342]## <welcome-file>index.html</welcome-file>

[#50626592_pgfId-1008344]## <welcome-file>index.htm</welcome-file>

[#50626592_pgfId-1008346]## </welcome-file-list>

[#50626592_pgfId-1008348]## <error-page>

[#50626592_pgfId-1008350]## <error-code>404</error-code>

[#50626592_pgfId-1008352]## <location>/404.html</location>

[#50626592_pgfId-1008354]## </error-page>

[#50626592_pgfId-1008356]## </web-app>

[#50626592_pgfId-1008228]## 

===== [#50626592_pgfId-1000944]##An Example of Security

======= [#50626592_pgfId-1008125]##Deployment Descriptor Example Using Security

[#50626592_pgfId-1008127]##<?xml version="1.0" encoding="UTF-8"?>

[#50626592_pgfId-1015232]##<web-app
xmlns="http://xmlns.jcp.org/xml/ns/javaee" +
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
web-app_4_0.xsd" +
version="4.0">

[#50626592_pgfId-1008141]## <display-name>A Secure
Application</display-name>

[#50626592_pgfId-1008143]## <servlet>

[#50626592_pgfId-1008145]## <servlet-name>catalog</servlet-name>

[#50626592_pgfId-1008147]## <servlet-class>com.example.CatalogServlet

[#50626592_pgfId-1008149]## </servlet-class>

[#50626592_pgfId-1008151]## <init-param>

[#50626592_pgfId-1008153]## <param-name>catalog</param-name>

[#50626592_pgfId-1008155]## <param-value>Spring</param-value>

[#50626592_pgfId-1008157]## </init-param>

[#50626592_pgfId-1008159]## <security-role-ref>

[#50626592_pgfId-1008161]## <role-name>MGR</role-name>

[#50626592_pgfId-1008163]## <!-- role name used in code -->

[#50626592_pgfId-1008165]## <role-link>manager</role-link>

[#50626592_pgfId-1008167]## </security-role-ref>

[#50626592_pgfId-1008169]## </servlet>

[#50626592_pgfId-1008171]## <security-role>

[#50626592_pgfId-1008173]## <role-name>manager</role-name>

[#50626592_pgfId-1008175]## </security-role>

[#50626592_pgfId-1008177]## <servlet-mapping>

[#50626592_pgfId-1008179]## <servlet-name>catalog</servlet-name>

[#50626592_pgfId-1008181]## <url-pattern>/catalog/*</url-pattern>

[#50626592_pgfId-1008183]## </servlet-mapping>

[#50626592_pgfId-1008185]## <security-constraint>

[#50626592_pgfId-1008187]## <web-resource-collection>

[#50626592_pgfId-1008189]## <web-resource-name>SalesInfo

[#50626592_pgfId-1008191]## </web-resource-name>

[#50626592_pgfId-1008193]## <url-pattern>/salesinfo/*</url-pattern>

[#50626592_pgfId-1008195]## <http-method>GET</http-method>

[#50626592_pgfId-1008197]## <http-method>POST</http-method>

[#50626592_pgfId-1008199]## </web-resource-collection>

[#50626592_pgfId-1008201]## <auth-constraint>

[#50626592_pgfId-1008203]## <role-name>manager</role-name>

[#50626592_pgfId-1008205]## </auth-constraint>

[#50626592_pgfId-1008207]## <user-data-constraint>

[#50626592_pgfId-1008209]## <transport-guarantee>CONFIDENTIAL

[#50626592_pgfId-1008211]## </transport-guarantee>

[#50626592_pgfId-1008213]## </user-data-constraint>

[#50626592_pgfId-1008215]## </security-constraint>

[#50626592_pgfId-1008217]##</web-app>

[#50626592_pgfId-998874]## 

== [#50626607_pgfId-874]## 

=== [#50626607_pgfId-999462]##

image:servlet-72.gif[image]

[#50626607_13295]##Requirements related to other Specifications

image:servlet-73.gif[image]

[#50626607_pgfId-1002266]##This chapter lists the requirements for web
containers that are included in products that also include other Java
technologies.

[#50626607_pgfId-1002340]##In the following sections any reference to
Java EE applies to not only the full Java EE profile but also any
profile that includes support for Servlet, like the Java EE Web Profile.
For more information on profiles please refer to the Java EE platform
specification.

==== [#50626607_pgfId-999467]##

image:servlet-74.gif[image]

Sessions

[#50626607_pgfId-999468]##Distributed servlet containers that are part
of a Java EE implementation must support the mechanism necessary for
migrating other Java EE objects from one JVM to another.

==== [#50626607_pgfId-1002827]##

image:servlet-74.gif[image]

Web Applications

===== [#50626607_pgfId-1002829]##Web Application Class Loader

[#50626607_pgfId-999474]##Servlet containers that are part of a Java EE
product should not allow the application to override Java SE or Java EE
platform classes, such as those in _java.*_ and _javax.*_ namespaces,
that either Java SE or Java EE do not allow to be modified.

===== [#50626607_pgfId-999477]##[#50626607_Web Application Environment]##Web Application Environment

[#50626607_pgfId-999478]##Java __ EE defines a naming environment that
allows applications to easily access resources and external information
without explicit knowledge of how the external information is named or
organized.

[#50626607_pgfId-1001802]##As servlets are an integral component type of
Java EE technology, provision has been made in the Web application
deployment descriptor for specifying information allowing a servlet to
obtain references to resources and enterprise beans. The deployment
elements that contain this information are:

[#50626607_pgfId-1001803]## _env-entry_

[#50626607_pgfId-1001804]## _ejb-ref_

[#50626607_pgfId-1001805]## _ejb-local-ref_

[#50626607_pgfId-1001806]## _resource-ref_

[#50626607_pgfId-1001807]## _resource-env-ref_

[#50626607_pgfId-1001808]## _service-ref_

[#50626607_pgfId-1002341]## _message-destination-ref_

[#50626607_pgfId-1002342]## _persistence-context-ref_

[#50626607_pgfId-1002343]## _persistence-unit-ref_

[#50626607_pgfId-1001809]##The developer uses these elements to describe
certain objects that the Web application requires to be registered in
the JNDI namespace in the Web container at runtime.

[#50626607_pgfId-1001810]##The requirements of the Java EE environment
with regard to setting up the environment are described in Chapter 5 of
the Java EE Specification.

[#50626607_pgfId-1001876]##Servlet containers that are part of a Java EE
technology-compliant implementation are required to support this syntax.
Consult the Java EE Specification for more details. This type of servlet
container must support lookups of such objects and calls made to those
objects when performed on a thread managed by the servlet container.
This type of servlet container should support this behavior when
performed on threads created by the developer, but are not currently
required to do so. Such a requirement will be added in the next version
of this specification. Developers are cautioned that depending on this
capability for application-created threads is not recommended, as it is
non-portable.

===== [#50626607_pgfId-1001877]##JNDI Name for Web Module Context Root URL

[#50626607_pgfId-1001881]##The Java EE Platform Specification defines a
standardized global JNDI namespace and a series of related namespaces
that map to various scopes of a Java EE application. These namespaces
can be used by applications to portably retrieve references to
components and resources. This section defines the JNDI names by which
the base url for a web application is required to be registered.

[#50626607_pgfId-1001886]##The name of the pre-defined _java.net.URL_
resource for the context root of a web application has the following
syntax:

[#50626607_pgfId-1001889]##
_java:global[/<app-name>]/<module-name>!ROOT_ in the global namespace
and

[#50626607_pgfId-1002315]## _java:app/<module-name>!ROOT_ in the
application-specific namespace.

[#50626607_pgfId-1002313]##Plese see section EE 8.1.1 (Component
creation) and EE 8.1.2 (Application assembly) for the rules to determine
the app name and module name

[#50626607_pgfId-1001890]##The _<app-name>_ is applicable only when the
webapp is packaged within a _.ear_ file.

[#50626607_pgfId-1002080]##The _java:app_ prefix allows a component
executing within a Java EE application to access an application-specific
namespace. The _java:app_ name allows a module in an enterprise
application to reference the context root of another module in the same
enterprise application. The _<module-name>_ is a required part of the
syntax for _java:app_ url.

======= [#50626607_pgfId-1002077]##Examples

[#50626607_pgfId-1001924]##The above URL can then be used within an
application as follows:

[#50626607_pgfId-1001929]##If a web application is deployed standalone
with _module-name_ as _myWebApp._ The URL can then be injected into
another web module as follows:

[#50626607_pgfId-1001972]## 

[#50626607_pgfId-1001949]##
_@Resource(lookup=“java:global/myWebApp!ROOT”)_

[#50626607_pgfId-1001942]## _URL myWebApp;_

[#50626607_pgfId-1001951]##When packaged in an ear file named _myApp_ it
can be used as follows:

[#50626607_pgfId-1001976]## __  

[#50626607_pgfId-1001957]##
_@Resource(lookup=“java:global/myApp/myWebApp!ROOT”)_

[#50626607_pgfId-1001958]## _URL myWebApp;_

[#50626607_pgfId-1002044]## 

==== [#50626607_pgfId-1001878]##

image:servlet-74.gif[image]

Security

[#50626607_pgfId-999492]##This section details the additional security
requirements for web containers when included in a product that also
contains EJB, JACC and or JASPIC. The following sections call out the
requirements

===== [#50626607_pgfId-999494]##[#50626607_Propagation of Security Identity in EJB Calls]##Propagation of Security Identity in EJB™ Calls

[#50626607_pgfId-999495]##A security identity, or principal, must always
be provided for use in a call to an enterprise bean. The default mode in
calls to enterprise beans from web applications is for the security
identity of a web user to be propagated to the EJB container.

[#50626607_pgfId-999496]##In other scenarios, web containers are
required to allow web users that are not known to the web container or
to the EJB __ container to make calls:

[#50626607_pgfId-999497]##Web containers are required to support access
to web resources by clients that have not authenticated themselves to
the container. This is the common mode of access to web resources on the
Internet.

[#50626607_pgfId-999498]##Application code may be the sole processor of
signon and customization of data based on caller identity.

[#50626607_pgfId-999499]##In these scenarios, a web application
deployment descriptor may specify a _run-as_ element. When a _run-as_
role is specified for a Servlet, the Servlet container must propagate a
principal mapped to the role as the security identity in any call from
the Servlet to an EJBs, including calls originating from the Servlet’s
_init_ and _destroy_ methods. The security role name must be one of the
security role names defined for the web application.

[#50626607_pgfId-999500]##For web containers running as part of a Java
EE platform, the use of _run-as_ elements must be supported both for
calls to EJB components within the same Java EE application, and for
calls to EJB components deployed in other Java EE applications.

===== [#50626607_pgfId-1002577]##Container Authorization Requirements

[#50626607_pgfId-1002578]##In a Java EE product or in a product that
includes support for Java Authorization Contracts for Containers (JACC,
i.e, JSR 115), all Servlet containers MUST implement support for JACC.
The JACC Specification is available for download at
_http://www.jcp.org/en/jsr/detail?id=115_

===== [#50626607_pgfId-1001652]##Container Authentication Requirements

[#50626607_pgfId-1001340]##In a Java EE product, or a product that
includes support for The Java Authentication SPI for Containers (JASPIC,
i.e, JSR 196), all Servlet containers MUST implement the Servlet
Container Profile of the JASPIC specification. The JASPIC Specification
is available for download at _http://www.jcp.org/en/jsr/detail?id=196_

==== [#50626607_pgfId-999501]##

image:servlet-74.gif[image]

Deployment

[#50626607_pgfId-999502]##This section details the deployment
descriptor, packaging and deployment descriptor processing requirements
of a Java EE technology compliant container and products that include
support for JSP and or Web Services.

===== [#50626607_pgfId-999503]##Deployment Descriptor Elements

[#50626607_pgfId-999504]##The following additional elements exist in the
Web application deployment descriptor to meet the requirements of Web
containers that are JSP pages enabled or part of a Java EE application
server. They are not required to be supported by containers wishing to
support only the servlet specification:

[#50626607_pgfId-999505]## _jsp-config_

[#50626607_pgfId-999506]##Syntax for declaring resource references (
_env-entry_ , _ejb-ref_ , _ejb-local-ref_ , _resource-ref_ ,
_resource-env-ref_ )

[#50626607_pgfId-999507]##Syntax for specifying the message destination
( _message-destination_ , _message-destination-ref_ )

[#50626607_pgfId-999508]##Reference to a Web service ( _service-ref_ )

[#50626607_pgfId-1002608]##Reference to a Persistence context (
_persistence-context-ref_ )

[#50626607_pgfId-1002609]##Reference to a Persistence Unit (
_persistence-unit-ref_ )

[#50626607_pgfId-999509]##The syntax for these elements is now held in
the JavaServer Pages specification version 2.2, and the Java EE
specification.

===== [#50626607_pgfId-999510]##Packaging and Deployment of JAX-WS Components

[#50626607_pgfId-999511]##Web containers may choose to support running
components written to implement a Web service endpoint as defined by the
JAX-RPC and/or JAX-WS specifications. Web containers embedded in a Java
EE conformant implementation are required to support JAX-RPC and JAX-WS
web service components. This section describes the packaging and
deployment model for web containers when included in a product which
also supports JAX-RPC and JAX-WS.

[#50626607_pgfId-999512]##JSR-109 _http://jcp.org/jsr/detail/109.jsp_
defines the model for packaging a Web service interface with its
associated WSDL description and associated classes. It defines a
mechanism for JAX-WS and JAX-RPC enabled Web containers to link to a
component that implements this Web service. A JAX-WS or JAX-RPC Web
service implementation component uses the APIs defined by the JAX-WS
and/or JAX-RPC specifications, which defines its contract with the
JAX-WS and/or JAX-RPC enabled Web containers. It is packaged into the
WAR file. The Web service developer makes a declaration of this
component using the usual _<servlet>_ declaration.

[#50626607_pgfId-999513]##JAX-WS and JAX-RPC enabled Web containers must
support the developer in using the Web deployment descriptor to define
the following information for the endpoint implementation component,
using the same syntax as for HTTP Servlet components using the _servlet_
element. The child elements are used to specify endpoint information in
the following way:

[#50626607_pgfId-999514]##the _servlet-name_ element defines a logical
name which may be used to locate this endpoint description among the
other Web components in the WAR

[#50626607_pgfId-999515]##the _servlet-class_ element provides the fully
qualified Java class name of this endpoint implementation

[#50626607_pgfId-999516]##the _description_ element(s) may be used to
describe the component and may be displayed in a tool

[#50626607_pgfId-999517]##the _load-on-startup_ element specifies the
order in which the component is initialized relative to other Web
components in the Web container

[#50626607_pgfId-999518]##the _security-role-ref_ element may be used to
test whether the authenticated user is in a logical security role

[#50626607_pgfId-999519]##the _run-as_ element may be used to override
the identity propagated to EJBs called by this component

[#50626607_pgfId-999520]##Any servlet initialization parameters defined
by the developer for this Web component may be ignored by the container.
Additionally, the JAX-WS and JAX-RPC enabled Web component inherits the
traditional Web component mechanisms for defining the following
information:

[#50626607_pgfId-999521]##mapping of the component to the Web
container’s URL namespace using the servlet mapping technique

[#50626607_pgfId-999522]##authorization constraints on Web components
using security constraints

[#50626607_pgfId-999523]##the ability to use servlet filters to provide
low-level byte stream support for manipulating JAX-WS and/or JAX-RPC
messages using the filter mapping technique

[#50626607_pgfId-999524]##the time out characteristics of any HTTP
sessions that are associated with the component

[#50626607_pgfId-999525]##links to Java EE objects stored in the JNDI
namespace

[#50626607_pgfId-1002543]##All of the above requirements can be met
using the pluggability mechanism defined in
link:servlet.htm#50626585_57616[See Pluggability].

===== [#50626607_pgfId-999527]##[#50626607_89500]##Rules for Processing the Deployment Descriptor

[#50626607_pgfId-999528]##The containers and tools that are part of Java
EE technology-compliant implementation are required to validate the
deployment descriptor against the XML schema for structural correctness.
The validation is recommended, but not required for the web containers
and tools that are not part of a Java EE technology compliant
implementation.

==== [#50626607_pgfId-999531]##

image:servlet-74.gif[image]

[#50626607_45908]##Annotations and Resource Injection

[#50626607_pgfId-999532]##The Java Metadata specification (JSR-175),
which is part of J2SE 5.0 and later versions, provides a means of
specifying configuration data in Java code. Metadata in Java code is
also referred to as annotations. In Java EE, annotations are used to
declare dependencies on external resources and configuration data in
Java code without the need to define that data in a configuration file.

[#50626607_pgfId-999533]##This section describes the behavior of
annotations and resource injection in Java EE technology compliant
Servlet containers. This section expands on the Java EE specification
section 5 titled “Resources, Naming, and Injection.”

[#50626607_pgfId-1001697]##Annotations must be supported on the
following container managed classes that implement the following
interfaces and are declared in the web application deployment descriptor
or using the annotations defined in link:servlet.htm#50626585_45908[See
Annotations and pluggability] or added programmatically.

======= [#50626607_pgfId-1004375]##Components and Interfaces supporting Annotations and Resource Injection

[#50626607_pgfId-1004379]##Component Type

[#50626607_pgfId-1004381]##Classes implementing the following interfaces

[#50626607_pgfId-1004383]##Servlets

[#50626607_pgfId-1004385]##javax.servlet.Servlet

[#50626607_pgfId-1004387]##Filters

[#50626607_pgfId-1004389]##javax.servlet.Filter

[#50626607_pgfId-1004391]##Listeners

[#50626607_pgfId-1004393]## _javax.servlet.ServletContextListener_

[#50626607_pgfId-1004394]##
_javax.servlet.ServletContextAttributeListener_

[#50626607_pgfId-1004395]## _javax.servlet.ServletRequestListener_

[#50626607_pgfId-1004396]##
_javax.servlet.ServletRequestAttributeListener_

[#50626607_pgfId-1004397]## _javax.servlet.http.HttpSessionListener_

[#50626607_pgfId-1004398]##
_javax.servlet.http.HttpSessionAttributeListener_

[#50626607_pgfId-1004399]## _javax.servlet.http.HttpSessionIdListener_

[#50626607_pgfId-1004400]##javax.servlet.AsyncListener

[#50626607_pgfId-1004402]##Handlers

[#50626607_pgfId-1004404]##javax.servlet.http.HttpUgradeHandler

[#50626607_pgfId-1001724]##Web containers are not required to perform
resource injection for annotations occurring in classes other than those
listed above in TABLE 15-1.

[#50626607_pgfId-1001562]##References must be injected prior to any
lifecycle methods being called and the component instance being made
available the application.

[#50626607_pgfId-999567]##In a web application, classes using resource
injection will have their annotations processed only if they are located
in the _WEB-INF/classes_ directory, or if they are packaged in a jar
file located in _WEB-INF/lib_ . Containers may optionally process
resource injection annotations for classes found elsewhere in the
application’s classpath.

===== [#50626607_pgfId-1004561]##[#50626607_43555]##Handling of metadata-complete

[#50626607_pgfId-1002368]##The web application deployment descriptor
contains a _metadata-complete_ attribute on the _web-app_ element. The
_metadata-complete_ attribute defines whether the _web.xml_ descriptor
is complete, or whether other sources of metadata used by the deployment
process should be considered. Metadata may come from the _web.xml_ file,
_web-fragment.xml_ files, annotations on class files in
_WEB-INF/classes_ , and annotations on classes in jar files in the
_WEB-INF/lib_ directory. If _metadata-complete_ is set to " _true_ ",
the deployment tool only examines the _web.xml_ file and must ignore
annotations such as _@WebServlet_ , _@WebFilter_ , and _@WebListener_
present in the class files of the application, and must also ignore any
_web-fragment.xml_ descriptor packaged in a jar file in _WEB-INF/lib_ .
If the _metadata-complete_ attribute is not specified or is set to "
_false_ ", the deployment tool must examine the class files and
_web-fragment.xml_ files for metadata,as previously specified.

[#50626607_pgfId-1002477]##The _web-fragment.xml_ also contains the
_metadata-complete_ attribute on the _web-fragment_ element. The
attribute defines whether the _web-fragment.xml_ descriptor is complete
for the given fragment, or whether it should scan for annotations in the
classes in the associated jar file. If _metadata-complete_ is set to “
_true_ ” the deployment tool only examines the _web-fragment.xml_ and
must ignore annotations such as _@WebServlet_ , _@WebFilter_ and
_@WebListener_ present in the class files of the fragment. If
_metadata-complete_ is not specified or is set to “ _false_ ” the
deployment tool must examine the class files for metadata.

[#50626607_pgfId-999569]##Following are the annotations that are
required by a Java EE technology compliant web container.

===== [#50626607_pgfId-999570]##@DeclareRoles

[#50626607_pgfId-999571]##This annotation is used to define the security
roles that comprise the security model of the application. This
annotation is specified on a class, and it is used to define roles that
could be tested (i.e., by calling _isUserInRole_ ) from within the
methods of the annotated class. Roles that are implicitly declared as a
result of their use in a _@RolesAllowed_ need not be explicitly declared
using the _@DeclareRoles_ annotaion. The _@DeclareRoles_ annotation may
only be defined in classes implementing the _javax.servlet.Servlet_
interface or a subclass thereof.

[#50626607_pgfId-1000075]##Following is an example of how this
annotation would be used.

[#50626607_pgfId-1000085]## _@DeclareRoles_ Annotation Example

[#50626607_pgfId-1000087]##@DeclareRoles("BusinessAdmin")

[#50626607_pgfId-1000089]## public class CalculatorServlet \{

[#50626607_pgfId-1000091]## //...

[#50626607_pgfId-1000093]## }

[#50626607_pgfId-1000080]##Declaring _@DeclareRoles_ ("BusinessAdmin")
is equivalent to defining the following in the web.xml.

[#50626607_pgfId-1000099]##@DeclareRoles web.xml

[#50626607_pgfId-1000101]##<web-app>

[#50626607_pgfId-1000103]## <security-role>

[#50626607_pgfId-1000105]## <role-name>BusinessAdmin</role-name>

[#50626607_pgfId-1000107]## </security-role>

[#50626607_pgfId-1000109]## </web-app>

[#50626607_pgfId-999587]##This annotation is not used to relink
application roles to other roles. When such linking is necessary, it is
accomplished by defining an appropriate security-role-ref in the
associated deployment descriptor.

[#50626607_pgfId-999588]##When a call is made to _isUserInRole_ from the
annotated class, the caller identity associated with the invocation of
the class is tested for membership in the role with the same name as the
argument to _isCallerInRole_ . If a _security-role-ref_ has been defined
for the argument role-name the caller is tested for membership in the
role mapped to the _role-name_ .

[#50626607_pgfId-999589]##For further details on the _@DeclareRoles_
annotation refer to the Common Annotations for the Java™ Platform™
specification (JSR 250) section 2.12.

===== [#50626607_pgfId-999590]##@EJB Annotation

[#50626607_pgfId-999591]##Enterprise __ JavaBeans™ 3.2 (EJB) components
may be referenced from a web component using the _@EJB_ annotation. The
_@EJB_ annotation provides the equivalent functionality of declaring the
_ejb-ref_ or _ejb-local-ref_ elements in the deployment descriptor.
Fields that have a corresponding _@EJB_ annotation are injected with the
a reference to the corresponding EJB component.

[#50626607_pgfId-999593]##An example:

[#50626607_pgfId-999595]##@EJB private ShoppingCart myCart;

[#50626607_pgfId-999597]##In the case above a reference to the EJB
component “ _myCart_ ” is injected as the value of the private field “
_myCart_ ” prior to the classs declaring the injection being made
available.

[#50626607_pgfId-999598]##The behavior the _@ EJB_ annotation is further
detailed in section 11.5.1 of the EJB 3.2 specification (JSR 345).

===== [#50626607_pgfId-999599]##@EJBs Annotation

[#50626607_pgfId-999600]##The _@EJBs_ annotation allows more than one
_@EJB_ annotations to be declared on a single resource.

[#50626607_pgfId-999602]##An example:

[#50626607_pgfId-1000145]##@EJBs Annotation Example

[#50626607_pgfId-1000147]##@EJBs(\{@EJB(Calculator),
@EJB(ShoppingCart)})

[#50626607_pgfId-1000149]##public class ShoppingCartServlet \{

[#50626607_pgfId-1000151]##//...

[#50626607_pgfId-1000153]##}

[#50626607_pgfId-999608]##The example above the EJB components
_ShoppingCart_ and _Calculator_ are made available to
_ShoppingCartServlet_ . The _ShoppingCartServlet_ must still look up the
references using JNDI but the EJBs do not need to declared in the
web.xml file.

===== [#50626607_pgfId-999611]##@Resource Annotation

[#50626607_pgfId-999612]##The _@Resource_ annotation is used to declare
a reference to a resource such as a data source, Java Messaging Service
(JMS) destination, or environment entry. This annotation is equivalent
to declaring a _resource-ref_ , _message-destination-ref_ or _env-ref_ ,
or _resource-env-ref_ element in the deployment descriptor.

[#50626607_pgfId-999613]##The _@Resource_ annotation is specified on a
class, method or field. The container is responsible injecting
references to resources declared by the _@Resource_ annotation and
mapping it to the proper JNDI resources. See the Java EE Specification
Chapter 5 for further details.

[#50626607_pgfId-999615]##An example of a @Resource annotation follows:

[#50626607_pgfId-1000479]##@Resource Example

[#50626607_pgfId-1000481]##@Resource private javax.sql.DataSource
catalogDS;

[#50626607_pgfId-1000483]##public getProductsByCategory() \{

[#50626607_pgfId-1000485]## // get a connection and execute the query

[#50626607_pgfId-1000487]## Connection conn = catalogDS.getConnection();

[#50626607_pgfId-1000489]##..

[#50626607_pgfId-1000491]##}

[#50626607_pgfId-999624]##In the example code above, a servlet, filter,
or listener declares a field _catalogDS_ of type _javax.sql.DataSource_
for which the reference to the data source is injected by the container
prior to the component being made available to the application. The data
source JNDI mapping is inferred from the field name “ _catalogDS_ ” and
type ( _javax.sql.DataSource_ ). Moreover, the _catalogDS_ resource no
longer needs to be defined in the deployment descriptor.

[#50626607_pgfId-999625]##The semantics of the _@Resource_ annotation
are further detailed in the Common Annotations for the Java™ Platform™
specification (JSR 250) Section 2.3 and Java EE 7 Specification
specification 5.2.5.

===== [#50626607_pgfId-999626]##@PersistenceContext Annotation

[#50626607_pgfId-999627]##This annotation specifies the container
managed entity manager for referenced persistence units.

[#50626607_pgfId-999629]##An example:

[#50626607_pgfId-1000170]##@PersistenceContext Example

[#50626607_pgfId-1000172]##@PersistenceContext (type=EXTENDED)

[#50626607_pgfId-1000174]##EntityManager em;

[#50626607_pgfId-999634]##The behavior the _@PersistenceContext_
annotation is further detailed in section 10.5.1 of the Java Persistence
API, Version 2.1 (JSR 338).

===== [#50626607_pgfId-999635]##@PersistenceContexts Annotation

[#50626607_pgfId-999636]##The _PersistenceContexts_ annotation allows
more than one _@PersistenceContext_ to be declared on a resource. The
behavior the _@PersistenceContexts_ annotation is further detailed in
section 10.5.1 of the Java Persistence API, version 2.1 (JSR 338).

===== [#50626607_pgfId-999637]##@PersistenceUnit Annotation

[#50626607_pgfId-999638]##The _@PersistenceUnit_ annotation provides
Enterprise Java Beans components declared in a servlet a reference to a
entity manager factory. The entity manager factory is bound to a
separate persistence.xml configuration file as described in section
11.10 of the EJB 3.2 specification (JSR 345).

[#50626607_pgfId-999640]##An example:

[#50626607_pgfId-1000191]##@PersistenceUnit Example

[#50626607_pgfId-1000193]##@PersistenceUnit

[#50626607_pgfId-1000195]##EntityManagerFactory emf;

[#50626607_pgfId-999645]##The behavior the _@PersistenceUnit_ annotation
is further detailed in section 10.5.2 of the Java Persistence API,
version 2.1 (JSR 338).

===== [#50626607_pgfId-999646]##@PersistenceUnits Annotation

[#50626607_pgfId-999647]##This annotation allows for more than one
_@PersistentUnit_ annotations to be declared on a resource. The behavior
the _@PersistenceUnits_ annotation is further detailed in section 10.5.2
of the Java Persistence API, version 2.1 (JSR 338).

===== [#50626607_pgfId-999648]##@PostConstruct Annotation

[#50626607_pgfId-999649]##The _@PostConstruct_ annotation is declared on
a method that does not take any arguments, and must not throw any
checked exceptions. The return value must be void. The method MUST be
called after the resources injections have been completed and before any
lifecycle methods on the component are called.

[#50626607_pgfId-1003859]##An example:

[#50626607_pgfId-1003850]##@PostConstruct Example

[#50626607_pgfId-1003852]##@PostConstruct

[#50626607_pgfId-1003854]##public void postConstruct() \{

[#50626607_pgfId-1003856]## ...

[#50626607_pgfId-1003858]##}

[#50626607_pgfId-1003860]##The example above shows a method using the
_@PostConstruct_ annotation.

[#50626607_pgfId-1003861]##The _@PostConstruct_ annotation MUST be
supported by all classes that support dependency injection and called
even if the class does not request any resources to be injected. If the
method throws an unchecked exception the class MUST not be put into
service and no method on that instance can be called.

[#50626607_pgfId-999661]##Refer to the Java EE specification section 2.5
and the Common Annotations for the Java™ Platform™ specification section
2.5 for more details.

===== [#50626607_pgfId-999662]##@PreDestroy Annotation

[#50626607_pgfId-1002514]##The @PreDestroy annotation is declared on a
method of a container managed component. The method is called prior to
component being removed by the container.

[#50626607_pgfId-1002528]##An example:

[#50626607_pgfId-1002517]##@PreDestroy Example

[#50626607_pgfId-1002519]##@PreDestroy

[#50626607_pgfId-1002521]##public void cleanup() \{

[#50626607_pgfId-1002523]## // clean up any open resources

[#50626607_pgfId-1002525]## ...

[#50626607_pgfId-1002527]##}

[#50626607_pgfId-999673]##The method annotated with _@PreDestroy_ must
return void and must not throw a checked exception. The method may be
public, protected, package private or private. The method must not be
static however it may be final.

[#50626607_pgfId-999675]##Refer to the JSR 250 section 2.6 for more
details.

===== [#50626607_pgfId-999677]##@Resources Annotation

[#50626607_pgfId-999678]##The _@Resources_ annotation acts as a
container for multiple _@Resource_ annotations because the Java MetaData
specification does not allow for multiple annotations with the same name
on the same annotation target.

[#50626607_pgfId-999680]##An example:

[#50626607_pgfId-1000212]##@Resources Example

[#50626607_pgfId-1000214]##@Resources (\{

[#50626607_pgfId-1000216]##@Resource(name=”myDB”
type=javax.sql.DataSource),

[#50626607_pgfId-1000218]##@Resource(name=”myMQ”
type=javax.jms.ConnectionFactory)

[#50626607_pgfId-1000220]##})

[#50626607_pgfId-1000222]##public class CalculatorServlet \{

[#50626607_pgfId-1000224]##//...

[#50626607_pgfId-1000226]##}

[#50626607_pgfId-999690]##In the example above a JMS connection factory
and a data source are made available to the _CalculatorServlet_ by means
of an _@Resources_ annotation.

[#50626607_pgfId-999691]##The semantics of the _@Resources_ annotation
are further detailed in the Common Annotations for the Java™ Platform™
specification (JSR 250) section 2.4.

===== [#50626607_pgfId-999692]##@RunAs Annotation

[#50626607_pgfId-999693]##The _@RunAs_ annotation is equivalent to the
_run-as_ element in the deployment descriptor. The _@RunAs_ annotation
may only be defined in classes implementing the _javax.servlet.Servlet_
interface or a subclass thereof.

[#50626607_pgfId-999695]##An example:

[#50626607_pgfId-1000239]##@RunAs Example

[#50626607_pgfId-1000241]##@RunAs(“Admin”)

[#50626607_pgfId-1000243]##public class CalculatorServlet \{

[#50626607_pgfId-1000245]## 

[#50626607_pgfId-1000247]##@EJB private ShoppingCart myCart;

[#50626607_pgfId-1000249]## 

[#50626607_pgfId-1000251]## public void doGet(HttpServletRequest, req,
HttpServletResponse res) \{

[#50626607_pgfId-1000253]## //....

[#50626607_pgfId-1000255]## myCart.getTotal();

[#50626607_pgfId-1000257]## //....

[#50626607_pgfId-1000259]## }

[#50626607_pgfId-1000261]##}

[#50626607_pgfId-1000263]## //....

[#50626607_pgfId-1000265]##}

[#50626607_pgfId-999711]##The _@RunAs(“Admin”)_ statement would be
equivalent to defining the following in the web.xml.

[#50626607_pgfId-1000627]##@RunAs web.xml Example

[#50626607_pgfId-1000629]##<servlet>

[#50626607_pgfId-1000631]##
<servlet-name>CalculatorServlet</servlet-name>

[#50626607_pgfId-1000633]## <run-as>Admin</run-as>

[#50626607_pgfId-1000635]##</servlet>

[#50626607_pgfId-999718]##The example above shows how a servlet uses the
_@RunAs_ annotation to propagate the security identity “ _Admin_ ” to an
EJB component when the _myCart.getTotal()_ method is called. For further
details on propagating identities see
link:servlet.htm#50626607_Propagation%20of%20Security%20Identity%20in%20EJB%20Calls[See
Propagation of Security Identity in EJB™ Calls].

[#50626607_pgfId-999722]##For further details on the _@RunAs_ annotation
refer to the Common Annotations for the Java™ Platform™ specification
(JSR 250) section 2.7.

===== [#50626607_pgfId-999723]##@WebServiceRef Annotation

[#50626607_pgfId-999724]##The @WebServiceRef annotation provides a
reference to a web service in a web component in same way as a
_resource-ref_ element would in the deployment descriptor.

[#50626607_pgfId-999726]##An example:

[#50626607_pgfId-999728]##@WebServiceRef private MyService service;

[#50626607_pgfId-999730]##In this example a reference to the web service
“ _MyService_ ” will be injected to the class declaring the annotation.

[#50626607_pgfId-999731]##This annotation and behavior are further
detailed in the JAX-WS Specification (JSR 224) section 7.

===== [#50626607_pgfId-999732]##@WebServiceRefs Annotation

[#50626607_pgfId-1001791]##This annotation allows for more than one
_@WebServiceRef_ annotations to be declared on a single resource. The
behavior of this annotation is further detailed in the JAX-WS
Specification (JSR 224) section 7.

===== [#50626607_pgfId-1002115]##[#50626607_29754]##Contexts and Dependency Injection for Java EE requirements

[#50626607_pgfId-1004081]##In a product that supports Contexts and
Dependency Injection for Java EE (CDI) and in which CDI is enabled,
implementations MUST support the use of CDI managed beans. Servlets,
Filters, Listeners and HttpUpgradeHandlers MUST support CDI injection
and the use of interceptors as described in Section EE.5.24, "Support
for Dependency Injection" of the Java EE 7 Platform specification.

[#50626607_pgfId-1004116]## 

== [#50626587_pgfId-874]## 

=== [#50626587_pgfId-1007323]##

image:servlet-75.gif[image]

Change Log

image:servlet-76.gif[image]

[#50626587_pgfId-1007327]##This document is the final release of the
Java Servlet 4.0 Servlet specification developed under the Java
Community ProcessSM (JCP).

==== [#50626587_pgfId-1004208]##

image:servlet-77.gif[image]

Changes Since Servlet 3.1

[#50626587_pgfId-1007357]##Requirement to support HTTP/2, see
link:servlet.htm#50626602_95812[See What is a Servlet Container?] and
link:servlet.htm#50626602_52497[See What is a Servlet?]. This includes
HTTP/2 server push, see link:servlet.htm#50626597_76986[See HTTP/2
Server Push].

[#50626587_pgfId-1008511]##Modify javadoc for _ServletContext
getAttribute()_ and _getInitParameter()_ , specify that
_NullPointerException_ must be thrown if the argument “name” is null.

[#50626587_pgfId-1007515]##Modify javadoc for
_ServletContext.setAttribute()_ and _setInitParameter()_ to specify that
_NullPointerException_ must be thrown if the “name” argument is null.

[#50626587_pgfId-1007694]##Deprecate
_HttpServletRequestWrapper.isRequestedSessionIdFromUrl()_ .

[#50626587_pgfId-1007790]##Add _@Deprecated_ to classes and methods with
_@deprecated_ in javadoc: _ServletContext_ , _ServletRequestWrapper_ ,
_SingleThreadModel_ , _UnavailableException_ , _HttpServletRequest_ ,
_HttpServletResponse_ , _HttpServletResponseWrapper_ , _HttpSession_ ,
_HttpSessionContext_ , _HttpUtils_ .

[#50626587_pgfId-1008168]##Add _default-context-path_ in the schema of
_web.xml_ and the description in link:servlet.htm#50626592_20617[See
default-context-path Element] and the figure,
link:servlet.htm#50626592_87190[See web-app Element Structure].

[#50626587_pgfId-1008343]##Modify link:servlet.htm#50626609_[See
Threading Issues] to clarify non-thread safety of objects vended from
requests and responses.

[#50626587_pgfId-1008447]##Clarify _metadata-complete_ in
link:servlet.htm#50626585_45908[See Annotations and pluggability].

[#50626587_pgfId-1008609]##Add _default_ to methods in
_ServletContextAttributeListener_ , _ServletContextListener_ ,
_ServletRequestAttributeListener_ , _ServletRequestListener_ ,
_HttpSessionActivationListener_ , _HttpSessionAttributeListener_ ,
_HttpSessionBindingListener_ , _HttpSessionListener_ .

[#50626587_pgfId-1009144]##Add _javax.servlet.GenericFilter_ and
_javax.servlet.http.HttpFilter_

[#50626587_pgfId-1009147]##Clarify the merging of _<distributable>_ in
_web.xml_ and _web-fragment.xml_ in link:servlet.htm#50626585_83472[See
Assembling the descriptor from web.xml, web-fragment.xml and
annotations].

[#50626587_pgfId-1009480]##Modify javadoc for
_ServletContext.getEffectiveSessionTrackingModes()_ without specifying
the default value.

[#50626587_pgfId-1009481]##Remove DTDs and Schemas from binary artifact
for Servlet API.

[#50626587_pgfId-1009491]##Add _getSessionTimeout_ and
_setSessionTimeout_ in _ServletContext_ . See javadoc,
link:servlet.htm#50626599_46668[See Programmatically configuring session
time out] and link:servlet.htm#50626609_33387[See Session Timeouts].

[#50626587_pgfId-1009487]##Add _addJspFile()_ in _ServletContext_ . See
javadoc, link:servlet.htm#50626599_71088[See addJspFile(String
servletName, String jspfile)] and link:servlet.htm#50626599_75024[See
Map<String, ? extends ServletRegistration> getServletRegistrations()].

{empty}[#50626587_pgfId-1010154]##Add _request-character-encoding_ and
_response-character-encoding_ in the schema of _web.xml_ . See the
corresponding descriptions of the elements in
link:servlet.htm#50626592_70192[See request-character-encoding Element]
and link:servlet.htm#50626592_86146[See response-character-encoding
Element]

[#50626587_pgfId-1009655]##Add _getRequestCharacterEncoding_ ,
_setRequestCharacterEncoding,_ _getResponseCharacterEncoding_ and
_setResponseCharacterEncoding_ in _ServletContext_ . Update the
corresponding javadoc of _ServletContext_ , _ServletRequest_ and
_ServletResponse_ . See link:servlet.htm#50626599_33517[See
Programmatically configuring character encoding],
link:servlet.htm#50626597_21428[See Request data encoding] and
link:servlet.htm#50626600_10199[See Internationalization].

[#50626587_pgfId-1010268]##Describe mapping discovery API. See
link:servlet.htm#50626594_44995[See Runtime Discovery of Mappings].

[#50626587_pgfId-1010365]##Update the javadoc of _Registration_ ,
_ServletContext_ , _ServletRegistration_ for the behaviors of returned
sets.

[#50626587_pgfId-1010509]##Clarify the behaviors of _complete_ and
_dispatch_ in _AsyncContext_ before the container-initiated dispatch
that called _startAsync_ has returned to the container. See
link:servlet.htm#50626601_73767[See AsyncContext].

[#50626587_pgfId-1010734]##Clarify interpretation of fileName parameter
for method _Part.write()_ . See the javadoc for details.

[#50626587_pgfId-1010878]##Clarify encoding used for reading the request
URL. See link:servlet.htm#50626594_20146[See Use of URL Paths] for
details.

[#50626587_pgfId-1010962]##Specified support for HTTP trailer. See
link:servlet.htm#50626600_49483[See HTTP Trailer] for details. Add
_getTrailerFields_ and _isTrailerFieldsReady_ in _HttpServletRequest_ ,
and _getTrailerFields_ and _setTrailerFields_ in _HttpServletResponse_ .
See the corresponding javadoc.

==== [#50626587_pgfId-1007297]##

image:servlet-77.gif[image]

Changes since Servlet 3.0

[#50626587_pgfId-1004212]##link:servlet.htm#50626602_67310[See
Compatibility with Java Servlet Specification Version 2.5]. Remove
subsection 1.6.1 “Listener ordering”.

[#50626587_pgfId-1004190]##link:servlet.htm#50626601_53655[See
Asynchronous processing]. And javadoc of _AsyncContext_ .

[#50626587_pgfId-1003146]##Clarified the behavior of
_AsyncListener.onStartAsync_ .

[#50626587_pgfId-1003147]##Fixed errors and comments in Code Examples.

[#50626587_pgfId-1003148]##Clarified the behavior of
_AsyncContext.getRequest_ and _AsyncContext.getResponse_ after the
asynchronous request is completed or dispatched.

[#50626587_pgfId-1007116]##Specify the default async time out value.

[#50626587_pgfId-1005773]##Clarified the behavior of _AsyncListener_
when there is an error.

[#50626587_pgfId-1002162]##Added link:servlet.htm#50626601_49366[See
Upgrade Processing], and new classes _ProtocolHandler_ and
_WebConnection_ .

[#50626587_pgfId-1003514]##link:servlet.htm#50626597_23510[See File
upload]. Clarified when _multi-part/form-data_ are processed.

[#50626587_pgfId-1005134]##Added Asynchronous IO in
link:servlet.htm#50626597_non-blocking-io-request[See Non Blocking IO]
and link:servlet.htm#50626600_68517[See Lifetime of the Response
Object].

[#50626587_pgfId-1006896]##Clarified link:servlet.htm#50626599_22463[See
Configuration methods] that the ServletContextListener must be declared
in the descriptor or annotated with @WebListener

[#50626587_pgfId-1005136]##Added _HttpSessionIdListener_ to the list
listeners in link:servlet.htm#50626599_49795[See void addListener(String
className)], link:servlet.htm#50626599_73584[See <T extends
EventListener> void addListener(T t)],
link:servlet.htm#50626599_73210[See void addListener(Class <? extends
EventListener> listenerClass)], link:servlet.htm#50626599_81110[See <T
extends EventListener> void createListener(Class<T> clazz)],
link:servlet.htm#50626585_48654[See @WebListener] and
link:servlet.htm#50626607_45908[See Annotations and Resource Injection].

[#50626587_pgfId-1006539]##link:servlet.htm#50626599_11622[See
Annotation processing requirements for programmatically added Servlets,
Filters and Listeners]. Update the reference.

[#50626587_pgfId-1006921]##link:servlet.htm#50626599_95664[See Multiple
Hosts and Servlet Contexts]. Add _ServletContext.getVirtualServerName_
method.

[#50626587_pgfId-1005140]##link:servlet.htm#50626600_76361[See
Buffering]. And javadoc of _ServletResponse_ . +
Clarified the behavior of _ServletResponse.reset_ .

[#50626587_pgfId-1007024]##link:servlet.htm#50626600_40116[See Headers].
Update X-Powered-By header.

[#50626587_pgfId-1005049]##link:servlet.htm#50626598_92626[See Filter
Lifecycle] (4). Required filters and servlet processing in the same
thread.

[#50626587_pgfId-1005238]##link:servlet.htm#50626609_90938[See Creating
a Session]. Add change session id.

[#50626587_pgfId-1006310]##link:servlet.htm#50626585_45908[See
Annotations and pluggability], link:servlet.htm#50626585_77230[See
Modularity of web.xml] and link:servlet.htm#50626602_31045[See
Processing annotations]. Clarify the behavior of _metadata-complete_ .

[#50626587_pgfId-1006318]##link:servlet.htm#50626585_69390[See
@WebServlet]. Programmatically adding servlet with a name different from
that specified in annotation.

[#50626587_pgfId-1004797]##link:servlet.htm#50626585_69625[See Ordering
of web.xml and web-fragment.xml] and link:servlet.htm#50626585_49176[See
Shared libraries / runtimes pluggability]. The processing of
_HandlesTypes_ annotation is applied irrespective to setting of
_metadata-complete_ .

[#50626587_pgfId-1004328]##link:servlet.htm#50626585_83472[See
Assembling the descriptor from web.xml, web-fragment.xml and
annotations]. Clarify the order in which listeners are invoked.

[#50626587_pgfId-1004996]##link:servlet.htm#50626585_49176[See Shared
libraries / runtimes pluggability]Clarify the creation of instance of
_ServletCotnainerInitilizer_ .

[#50626587_pgfId-1005000]##link:servlet.htm#50626608_48495[See The
Forward Method]. Clarified the behavior of the response when the request
is put in asynchronous mode.

[#50626587_pgfId-1005176]##link:servlet.htm#50626595_71870[See HTTP
Session Events]. Add a “Changes to id” events.

[#50626587_pgfId-1006330]##link:servlet.htm#50626596_49990[See Error
Pages] and link:servlet.htm#50626592_34618[See Deployment Descriptor
Diagram]. Add description for default error page.

[#50626587_pgfId-1004268]##link:servlet.htm#50626595_58164[See Listener
Registration]. Clarify on ordering.

[#50626587_pgfId-1006204]##link:servlet.htm#50626594_44611[See
Specification of Mappings]. Clarify the behavior of servlets mapped to
the same url-pattern.

[#50626587_pgfId-1006603]##link:servlet.htm#50626593_85024[See
Programmatic Security], link:servlet.htm#50626593_82840[See Mapping
@HttpConstraint and @HttpMethodConstraint to XML.] and
link:servlet.htm#50626593_36825[See Combining Constraints]. Add
descriptions for role “*” and “**”.

[#50626587_pgfId-1006747]##link:servlet.htm#50626593_44518[See Form
Based Authentication]. Add status code 303.

[#50626587_pgfId-1006861]##link:servlet.htm#50626593_65870[See Login
Form Notes]. Add autocomplete=”off’.

[#50626587_pgfId-1006751]##Add link:servlet.htm#50626593_93176[See
Uncovered HTTP Protocol Methods].

[#50626587_pgfId-1007078]##link:servlet.htm#50626592_12370[See
Deployment Descriptor]. Update the schema url.

[#50626587_pgfId-1006755]##link:servlet.htm#50626607_Propagation%20of%20Security%20Identity%20in%20EJB%20Calls[See
Propagation of Security Identity in EJB™ Calls]. Explicitly mentioned
the _Servlet.init_ and _Servlet.destroy_ .

[#50626587_pgfId-1005732]##link:servlet.htm#50626607_29754[See Contexts
and Dependency Injection for Java EE requirements]. Add
_HttpUpgradeHandler_ and add reference to Java EE 7 specification.

[#50626587_pgfId-1003031]##Added generic in _ServletRequestWrapper_ ,
_ServletResponseWrapper_ and _HandlesTypes_ .

[#50626587_pgfId-1002927]##Javadoc of _HttpServletResponse.sendRedirect_
: Supported network-path reference.

[#50626587_pgfId-1003853]##Add new methods
_ServletRequest.getContentLengthLong_ and
_ServletResponse.setContentLengthLong_ .

[#50626587_pgfId-1006781]##Add the new _Part.getSubmittedFileName_ .

==== [#50626587_pgfId-1002163]##

image:servlet-77.gif[image]

Changes since Servlet 3.0 Proposed Final Draft

[#50626587_pgfId-1001457]##Re-factored some of the Async APIs - moved
addAsyncListener to AsyncContext and renamed it to addListener. Moved
setAsyncTimeout to AsyncContext and renamed it to setTimeout.

[#50626587_pgfId-1001463]##Clarified some of the semantics around
concurrent access to the request and response in async processing.

[#50626587_pgfId-1001464]##Updated pluggability rules for resource
reference elements.

[#50626587_pgfId-1001465]##Added a new annotation - @ServletSecurity
(and associated annotation for the fields) for defining security as
opposed to re-using the @RolesAllowed, @PermitAll, @DenyAll

==== [#50626587_pgfId-1001456]##

image:servlet-77.gif[image]

Changes since Servlet 3.0 Public Review

[#50626587_pgfId-1001420]##Updated isAsyncStarted to return false once a
dispatch to the container or a call to complete is done from the async
handler

[#50626587_pgfId-1001424]##Added ordering support for fragments

[#50626587_pgfId-1001425]##Added support for file upload

[#50626587_pgfId-1001426]##Added support for loading static resources
and JSPs from JAR files that are included in the META-INF/resources
directory of the JAR file which is then bundled in the WEB-INF/lib
directory

[#50626587_pgfId-1001430]##Changed annotation names based on feedback on
Public Review of the specification

[#50626587_pgfId-1001431]##Added programmatic login / logout support

[#50626587_pgfId-1001432]##Added support for security related common
annotations - @RolesAllowed, @PermitAll, @DenyAll

[#50626587_pgfId-1001433]##Clarified welcome files

==== [#50626587_pgfId-1001416]##

image:servlet-77.gif[image]

Changes since Servlet 3.0 EDR

[#50626587_pgfId-1001382]##The suspend / resume APIs are no longer
present in the specification. They have been replaced by startAsync and
AsyncContext which now has forward and complete methods.

[#50626587_pgfId-1001386]##Annotation names have changed and there are
only top level annotations. The method level annotations for declaring
the servlet methods are no longer being used.

[#50626587_pgfId-1001387]##The rules for assembling web.xml from
fragments and annotations is described.

==== [#50626587_pgfId-1001381]##

image:servlet-77.gif[image]

Changes since Servlet 2.5 MR6

[#50626587_pgfId-1001365]##Added support for annotations and web
fragments

[#50626587_pgfId-1001374]##Added support for suspend / resume to allow
async support in servlets.

[#50626587_pgfId-1001375]##Added support for initializing servlets and
filters from the ServletContext at initialization time.

[#50626587_pgfId-1001376]##Added support for HttpOnly cookies and allow
configuring cookies.

[#50626587_pgfId-1001373]##Added convenience methods to ServletRequest
to get Response and ServletContext

==== [#50626587_pgfId-1001360]##

image:servlet-77.gif[image]

Changes since Servlet 2.5 MR 5

[#50626587_pgfId-1000067]##Clarify SRV 8.4 "The Forward Method"

[#50626587_pgfId-1000068]##Change the last sentence of the section which
currently is:

[#50626587_pgfId-1000070]##"Before the forward method of the
_RequestDispatcher_ interface returns, the response content must be sent
and committed, and closed by the servlet container."

[#50626587_pgfId-1000450]##to read:

[#50626587_pgfId-1000072]##"Before the forward method of the
_RequestDispatcher_ interface returns without exception, the response
content must be sent and committed, and closed by the servlet container.
If an error occurs in the target of the _RequestDispatcher.forward()_
the exception may be propogated back through all the calling filters and
servlets and eventually back to the container."

[#50626587_pgfId-1000073]##Update Deployment descriptor "http-method
values allowed"

[#50626587_pgfId-1000074]##The facet for _http-method_ element in the
deployment descriptor is currently more restrictive than the http
specification. The following change is being made to the descriptor to
allow the set of method names as defined by the http specification. The
pattern value of _http-methodType_ is being changed from

[#50626587_pgfId-1000075]##<xsd:pattern
value="[\p\{L}-[\p\{Cc}\p\{Z}]]+"/>

[#50626587_pgfId-1000076]##to closely match what the HTTP specification
lists as allowable HTTP methods names.

[#50626587_pgfId-1000078]##<xsd:pattern
value="[&#33;-&#126;-[\(\)&#60;&#62;@,;:&#34;/\[\]?=\\{\}\\\p\{Z}]]+"/>

[#50626587_pgfId-1000079]##Clarify SRV 7.7.1 "Threading Issues"

[#50626587_pgfId-1000080]##Change the paragraph which currently is:

[#50626587_pgfId-1000082]##"Multiple servlets executing request threads
may have active access to a single session object at the same time. The
Developer has the responsibility for synchronizing access to session
resources as appropriate."

[#50626587_pgfId-1000674]##to read:

[#50626587_pgfId-1000084]##"Multiple servlets executing request threads
may have active access to the same session object at the same time. The
container must ensure that manipulation of internal data structures
representing the session attributes is performed in a threadsafe manner.
The Developer has the responsibility for threadsafe access to the
attribute objects themselves. This will protect the attribute collection
inside the HttpSession object from concurrent access, eliminating the
opportunity for an application to cause that collection to become
corrupted."

==== [#50626587_pgfId-1000085]##

image:servlet-77.gif[image]

Changes Since Servlet 2.5 MR 2

[#50626587_pgfId-1000086]##Updated Annotation Requirements for Java EE
containers

[#50626587_pgfId-1000087]##Added EJBs, PreDestroy, PeristenceContext,
PersistenceContexts, PersistenceUnit, and PersistenceUnits with
descriptions to the list of required Java EE cdontainer annotations in
link:servlet.htm#50626607_45908[See Annotations and Resource Injection].

[#50626587_pgfId-1000091]##Updated Java Enterprise Edition Requirements

[#50626587_pgfId-1000092]##Updated the Annotations to the final Java EE
annotation names. Also updated the "full" attribute in the _web.xml_ to
be "metadata-complete".

[#50626587_pgfId-1000093]##Clarified HttpServletRequest.getRequestURL()

[#50626587_pgfId-1000094]##The API documentation for
_javax.servlet.http.HttpServletRequest.getRequestURL()_ was clarified.

[#50626587_pgfId-1000096]##The text in italics was added:

[#50626587_pgfId-1000098]## _If this request has been forwarded using
RequestDispatcher.forward(ServletRequest, ServletResponse), the server
path in the reconstructed URL must reflect the path used to obtain the
RequestDispatcher, and not the server path specified by the client._
Because this method returns a _StringBuffer_ , not a string, you can
modify the URL easily, for example, to append query parameters.

[#50626587_pgfId-1000100]##Removal of IllegalStateException from
HttpSession.getId()

[#50626587_pgfId-1000101]##The HttpSessionBindingListener calls the
valueUnbound event after the session has been expired, unfortunately,
the HttpSession.getId() method is often used in this scenario and is
supposed to throw an IllegalStateException. The servlet EG agreed to
remove the exception from the API to prevent these types of exceptions.

[#50626587_pgfId-1000103]##ServletContext.getContextPath()

[#50626587_pgfId-1000104]##The method _getContextPath()_ was added to
the _ServletContext_ in the API. The description is as follows:

[#50626587_pgfId-1000108]##public java.lang.String getContextPath()

[#50626587_pgfId-1000109]##Returns the context path of the web
application. The context path is the portion of the request URI that is
used to select the context of the request. The context path always comes
first in a request URI. The path starts with a "/" character but does
not end with a "/" character. For servlets in the default (root)
context, this method returns "".

[#50626587_pgfId-1000110]##It is possible that a servlet container may
match a context by more than one context path. In such cases
getContextPath() will return the actual context path used by the request
and it may differ from the path returned by this method. The context
path returned by this method should be considered as the prime or
preferred context path of the application.

[#50626587_pgfId-1000111]## _Returns_ : The context path of the web
application.

[#50626587_pgfId-1000117]##HttpServletRequest.getContextPath() was
updated to clarify its relationship with the
ServletContext.getContextPath() method. The clarification is as follows.

[#50626587_pgfId-1000119]##It is possible that a servlet container may
match a context by more than one context path. In such cases this method
will return the actual context path used by the request and it may
differ from the path returned by the ServletContext.getContextPath()
method. The context path returned by ServletContext.getContextPath()
should be considered as the prime or preferred context path of the
application.

[#50626587_pgfId-1000121]##Requirement for web.xml in web applications

[#50626587_pgfId-1000125]##link:servlet.htm#50626596_45251[See Inclusion
of a web.xml Deployment Descriptor] was added which removes requirement
for Java EE compliant web applications. The section is as follows:

[#50626587_pgfId-1000127]##A web application is NOT required to contain
a web.xml if it does NOT contain any Servlet, Filter, or Listener
components. In other words an application containing only static files
or JSP pages does not require a web.xml to be present.

==== [#50626587_pgfId-1000128]##

image:servlet-77.gif[image]

Changes Since Servlet 2.4

[#50626587_pgfId-1000129]##Session Clarification

[#50626587_pgfId-1000133]##Clarified link:servlet.htm#50626609_38534[See
Session Scope] to allow for better support of session ids being used in
more than one context. This was done to support the Portlet
specification (JSR 168). Added the following paragraph at the end of
link:servlet.htm#50626609_38534[See Session Scope]:

[#50626587_pgfId-1000138]##“Additionally, sessions of a context must be
resumable by requests into that context regardless of whether their
associated context was being accessed directly or as the target of a
request dispatch at the time the sessions were created."

[#50626587_pgfId-1000143]##Made the changes in
link:servlet.htm#50626608_61967[See The Include Method] by replacing the
following text:

[#50626587_pgfId-1000145]##"It cannot set headers or call any method
that affects the headers of the response. Any attempt to do so must be
ignored."

[#50626587_pgfId-1000147]##with the following:

[#50626587_pgfId-1000149]##"It cannot set headers or call any method
that affects the headers of the response, with the exception of the
HttpServletRequest.getSession() and
HttpServletRequest.getSession(boolean) methods. Any attempt to set the
headers must be ignored, and any call to HttpServletRequest.getSession()
or HttpServletRequest.getSession(boolean) that would require adding a
Cookie response header must throw an IllegalStateException if the
response has been committed."

[#50626587_pgfId-1000150]##Filter All Dispatches

[#50626587_pgfId-1000154]##Modified link:servlet.htm#50626598_69819[See
Filters and the RequestDispatcher] to clarify a way to map a filter to
all servlet dispatches by appending the following text to the end of the
section:

[#50626587_pgfId-1000156]##Finally, the following code uses the special
servlet name '*':

======= [#50626587_pgfId-1001144]##Example of special servlet name ‘*’

[#50626587_pgfId-1001146]##<filter-mapping>

[#50626587_pgfId-1001148]## <filter-name>All Dispatch
Filter</filter-name>

[#50626587_pgfId-1001150]## <servlet-name>*</servlet-name>

[#50626587_pgfId-1001152]## <dispatcher>FORWARD</dispatcher>

[#50626587_pgfId-1001154]##</filter-mapping>

[#50626587_pgfId-1000164]##This code would result in the All Dispatch
Filter being invoked on request dispatcher forward() calls for all
request dispatchers obtained by name or by path.

[#50626587_pgfId-1000165]##Multiple Occurrences of Servlet Mappings

[#50626587_pgfId-1006088]##Previous versions of the servlet schema
allows only a single url-pattern or servlet name per servlet mapping.
For servlets mapped to multiple URLs this results in needless repetition
of whole mapping clauses.

[#50626587_pgfId-1006108]##The deployment descriptor
_servlet-mappingType_ was updated to:

== [#50626587_pgfId-1006091]## _servlet-mappingType_ descriptor

[#50626587_pgfId-1006093]##<xsd:complexType name="servlet-mappingType">

[#50626587_pgfId-1006095]## <xsd:sequence>

[#50626587_pgfId-1006097]## <xsd:element name="servlet-name"
type="j2ee:servlet-nameType"/>

[#50626587_pgfId-1006099]## <xsd:element name="url-pattern"
type="j2ee:url-patternType" minOccurs="1"

[#50626587_pgfId-1006101]##maxOccurs="unbounded"/>

[#50626587_pgfId-1006103]## </xsd:sequence>

[#50626587_pgfId-1006105]## <xsd:attribute name="id" type="xsd:ID"/>

[#50626587_pgfId-1006107]##</xsd:complexType>

[#50626587_pgfId-1006109]##Multiple Occurrences Filter Mappings

[#50626587_pgfId-1000815]##Previous versions of the servlet schema
allows only a single url-pattern in a filter mapping. For filters mapped
to multiple URLs this results in needless repetition of whole mapping
clauses.

[#50626587_pgfId-1000180]##The deployment descriptor schema the
_filter-mappingType_ was updated to:

== [#50626587_pgfId-1001114]##Updated _filter-mappingType_ schema

[#50626587_pgfId-1001116]##<xsd:complexType name="filter-mappingType">

[#50626587_pgfId-1001118]## <xsd:sequence>

[#50626587_pgfId-1001120]## <xsd:element name="filter-name"
type="j2ee:filter-nameType"/>

[#50626587_pgfId-1001122]## <xsd:choice minOccurs="1"
maxOccurs="unbounded">

[#50626587_pgfId-1001124]## <xsd:element name="url-pattern"
type="j2ee:url-patternType"/>

[#50626587_pgfId-1001126]## <xsd:element name="servlet-name"
type="j2ee:servlet-nameType"/>

[#50626587_pgfId-1001128]## </xsd:choice>

[#50626587_pgfId-1001130]## <xsd:element name="dispatcher"
type="j2ee:dispatcherType" minOccurs="0"

[#50626587_pgfId-1001132]##maxOccurs="4"/>

[#50626587_pgfId-1001134]## </xsd:sequence>

[#50626587_pgfId-1001136]## <xsd:attribute name="id" type="xsd:ID"/>

[#50626587_pgfId-1001138]##</xsd:complexType>

[#50626587_pgfId-1000195]##This change allows multiple patterns and
servlet names to be defined in a single mapping as can be seen in the
following example:

== [#50626587_pgfId-1000982]##Filter mapping example

[#50626587_pgfId-1000984]##<filter-mapping>

[#50626587_pgfId-1000986]## <filter-name>Demo Filter</filter-name>

[#50626587_pgfId-1000988]## <url-pattern>/foo/*</url-pattern>

[#50626587_pgfId-1000990]## <url-pattern>/bar/*</url-pattern>

[#50626587_pgfId-1000992]## <servlet-name>Logger</servlet-name>

[#50626587_pgfId-1000994]## <dispatcher>REQUEST</dispatcher>

[#50626587_pgfId-1000996]## <dispatcher>ERROR</dispatcher>

[#50626587_pgfId-1000998]##</filter-mapping>

[#50626587_pgfId-1000209]##link:servlet.htm#50626598_62972[See
Configuration of Filters in a Web Application] was updated to clarify
the cases where there are multiple mappings with the following text:

[#50626587_pgfId-1000211]##"If a filter mapping contains both
<servlet-name> and <url-pattern>, the container must expand the filter
mapping into multiple filter mappings (one for each <servlet-name> and
<url-pattern>), preserving the order of the <servlet-name> and
<url-pattern> elements."

[#50626587_pgfId-1000213]##An examples was also provided to clarify
cases when there are multiple mappings.

[#50626587_pgfId-1000214]##Support Alternative HTTP Methods with
Authorization Constraints

[#50626587_pgfId-1000215]##The previous Servlet 2.4 schema restricted
HTTP methods to GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE. The
schema http-methodType was changed from:

== [#50626587_pgfId-1001037]##Servlet 2.4 _http-methodType_ schema

[#50626587_pgfId-1001039]##<xsd:complexType name="http-methodType">

[#50626587_pgfId-1001041]##...

[#50626587_pgfId-1001043]## <xsd:simpleContent>

[#50626587_pgfId-1001045]## <xsd:restriction base="j2ee:string">

[#50626587_pgfId-1001047]## <xsd:enumeration value="GET"/>

[#50626587_pgfId-1001049]## <xsd:enumeration value="POST"/>

[#50626587_pgfId-1001051]## <xsd:enumeration value="PUT"/>

[#50626587_pgfId-1001053]## <xsd:enumeration value="DELETE"/>

[#50626587_pgfId-1001055]## <xsd:enumeration value="HEAD"/>

[#50626587_pgfId-1001057]## <xsd:enumeration value="OPTIONS"/>

[#50626587_pgfId-1001059]## <xsd:enumeration value="TRACE"/>

[#50626587_pgfId-1001061]## </xsd:restriction>

[#50626587_pgfId-1001063]## </xsd:simpleContent>

[#50626587_pgfId-1001065]##</xsd:complexType>

[#50626587_pgfId-1000232]##To the following:

== [#50626587_pgfId-1001010]##Servlet 2.5 _http-methodType_ schema

[#50626587_pgfId-1001012]##<xsd:simpleType name="http-methodType">

[#50626587_pgfId-1001014]## <xsd:annotation>

[#50626587_pgfId-1001016]## <xsd:documentation>

[#50626587_pgfId-1001018]## A HTTP method type as defined in HTTP 1.1
section 2.2.

[#50626587_pgfId-1001020]## </xsd:documentation>

[#50626587_pgfId-1001022]## </xsd:annotation>

[#50626587_pgfId-1001024]## 

[#50626587_pgfId-1001026]## <xsd:restriction base="xsd:token">

[#50626587_pgfId-1001028]## <xsd:pattern
value="[\p\{L}-[\p\{Cc}\p\{Z}]]+"/>

[#50626587_pgfId-1001030]## </xsd:restriction>

[#50626587_pgfId-1001032]##</xsd:simpleType>

[#50626587_pgfId-1000246]##The http-method elements now need to be a
token as described in HTTP 1.1 specification section 2.2.

[#50626587_pgfId-1000247]##Minimum J2SE Requirement

[#50626587_pgfId-1000248]##Servlet 2.5 Containers now require J2SE 5.0
as the minimum Java version. link:servlet.htm#50626602_95812[See What is
a Servlet Container?] was updated to reflect this requirement.

[#50626587_pgfId-1000252]##Annotations and Resource Injection

[#50626587_pgfId-1000253]##Java EE technology compliant containers
require annotations and resource injection on servlets, filters, and
listeners. link:servlet.htm#50626607_45908[See Annotations and Resource
Injection] describes the annotations and resource injection in further
detail.

[#50626587_pgfId-1000258]##SRV.9.9 ("Error Handling") Requirement
Removed

[#50626587_pgfId-1000263]##link:servlet.htm#50626596_69376[See Request
Attributes] defines the following requirement:

[#50626587_pgfId-1000265]##If the location of the error handler is a
servlet or a JSP page:

{empty}[#50626587_pgfId-1000266]##[...]

[#50626587_pgfId-1000267]##The response setStatus method is disabled and
ignored if called.

{empty}[#50626587_pgfId-1000268]##[...]

[#50626587_pgfId-1000270]##The JSP 2.1 EG has asked that this
requirement above be removed to allow JSP error pages to update the
response status.

[#50626587_pgfId-1000271]##HttpServletRequest.isRequestedSessionIdValid()
Clarification

[#50626587_pgfId-1000272]##The API clarification better describes what
happens when a client did not specify a session id. The API
documentation was updated to specify when false is returned. The API
documentation now states:

[#50626587_pgfId-1000277]##Returns false if the client did not specify
any session ID.

[#50626587_pgfId-1000279]##SRV.5.5 ("Closure of Response Object")
Clarification

[#50626587_pgfId-1000283]##The behavior in
link:servlet.htm#50626600_39611[See Closure of Response Object] the
response's content length is set to 0 via
response.setHeader("Content-Length", "0") and any subsequently
setHeader() calls are ignored.

[#50626587_pgfId-1000288]##link:servlet.htm#50626600_39611[See Closure
of Response Object] was updated to allow all headers to be set by
changing:

[#50626587_pgfId-1000290]##"The amount of content specified in the
setContentLength method of the response and has been written to the
response"

[#50626587_pgfId-1000292]##To the following:

[#50626587_pgfId-1000294]##"The amount of content specified in the
setContentLength method of the response has been greater than zero and
has been written to the response"

[#50626587_pgfId-1000296]##ServletRequest.setCharacterEncoding()
Clarified

[#50626587_pgfId-1000300]##The API was updated to described the behavior
if the method is called after the getReader() was called. If the
getReader() is called there will be no effect.

[#50626587_pgfId-1000301]##Java Enterprise Edition Requirements

[#50626587_pgfId-1000305]##link:servlet.htm#50626607_13295[See
Requirements related to other Specifications] details all requirements
of a Java EE container. Previously the requirements were mixed into each
chapter.

[#50626587_pgfId-1000306]##Servlet 2.4 MR Change Log Updates Added

[#50626587_pgfId-1000307]##Added the changes from the Servlet 2.4
Maintenance Review. These changes include grammar and typographical
fixes.

[#50626587_pgfId-1000308]##Synchronized Access Session Object Clarified

[#50626587_pgfId-1000312]##link:servlet.htm#50626609_[See Threading
Issues] was updated to clarify that access to the session object should
be synchronized.

==== [#50626587_pgfId-1000313]##

image:servlet-77.gif[image]

Changes Since Servlet 2.3

[#50626587_pgfId-1000314]##Optional “X-Powered-By” header is added in
the response (5.2)

[#50626587_pgfId-1000315]##Clarification of “overlapping constraint”
(12.8.1, 12.8.2)

[#50626587_pgfId-1000316]##Add the section to clarify the process order
at the time of web application deployment (9.12)

[#50626587_pgfId-1000317]##Clarification that the security model is also
applied to filter (12.2)

[#50626587_pgfId-1000318]##Change the status code from 401 to 200 when
FORM authentication is failed as there is no appropriate error status
code in HTTP/1.1 (12.5.3)

[#50626587_pgfId-1000319]##Clarification of the wrapper objects (6.2.2)

[#50626587_pgfId-1000320]##Clarification of overriding the platform
classes (9.7.2)

[#50626587_pgfId-1000321]##Clarification of welcome file (9.10)

[#50626587_pgfId-1000322]##Clarification of internationalization - the
relationship among setLocale, setContentType, and setCharacterEncoding
(5.4, 14.2.22)

[#50626587_pgfId-1000323]##Clarification of ServletRequestListener and
ServletRequestAttributeListener description (14.2.18, 14.2.20)

[#50626587_pgfId-1000324]##Add HttpSessionActivationListener and
HttpSessionBindingListener into the Table 10-1.

[#50626587_pgfId-1000325]##Change the word "auth constraint" to
"authorization constraint" (12.8)

[#50626587_pgfId-1000326]##Add “Since” tag in the newly added methods in
javadoc(14.2.16, 14.2.22)

[#50626587_pgfId-1000327]##Fix the data type of _<session-timeout>_ to
_xsdIntegerType_ in schema(13.3)

[#50626587_pgfId-1000328]##Clarification when the listener throws the
unhandled exception(10.6)

[#50626587_pgfId-1000329]##Clarification of the “shared library”(9.7.1)

[#50626587_pgfId-1000330]##Clarification of the container’s mechanism
for the extension(9.7.1, third paragraph)

[#50626587_pgfId-1000331]## _HttpSession.logout_ method was removed. The
portable authentication mechanism will be addressed in the next version
of this specification and logout will also be discussed in that
scope.(12.10)

[#50626587_pgfId-1000332]##It is now a recommendation, instead of a
requirement, that the reference to the request and response object
should not be given to the object in other threads - based on the
requirement from JSR-168. Warnings are added when the thread created by
the application uses the objects managed by the container.(2.3.3.3)

[#50626587_pgfId-1000333]##It is now a recommendation, that the dispatch
should occur in the same thread of the same JVM as the original request
- based on the requirement from JSR-168(8.2)

[#50626587_pgfId-1000334]##Clarification of “wrap” (6.2.2)

[#50626587_pgfId-1000335]##Clarification of handling the path parameter
for the mapping(11.1)

[#50626587_pgfId-1000336]##Add the description about the “HTTP chunk” in
_HttpServlet.doGet_ method(15.1.2)

[#50626587_pgfId-1000337]##J2SE 1.3 is the minimum version of the
underlying Java platform with which servlet containers must be built
(1.2)

[#50626587_pgfId-1000338]##Clarification of
ServletResponse.setBufferSize method (5.1)

[#50626587_pgfId-1000339]##Clarification of ServletRequest.getServerName
and getServerPort (14.2.16.1)

[#50626587_pgfId-1000340]##Clarification of Internationalization (5.4,
14.2.22)

[#50626587_pgfId-1000341]##Clarification of the redirection of the
welcome file (9.10)

[#50626587_pgfId-1000342]##Clarification of
ServletContextListener.contextInitialized (14.2.12.1)

[#50626587_pgfId-1000343]##Clarification of
HttpServletRequest.getRequestedSessionId - making it clear that it
returns the session ID specified by the client (15.1.3.2)

[#50626587_pgfId-1000344]##Clarification of the class loader for the
extensions - the class loader must be the same for all web applications
within the same JVM (9.7.1)

[#50626587_pgfId-1000345]##Clarification of the case when
ServletRequestListener throws an unhandled exception (10.6, 14.2.20)

[#50626587_pgfId-1000346]##Clarification of the scope of
ServletRequestListener (14.2.20)

[#50626587_pgfId-1000347]##Add the description about the case when the
container has a caching mechanism (1.2)

[#50626587_pgfId-1000348]##Validating deployment descriptor against the
schema is required for Java EE containers (13.2)

[#50626587_pgfId-1000349]##Sub elements under _<web-app>_ can be in an
arbitrary order (13.2)

[#50626587_pgfId-1000350]##One example of the container’s rejecting the
web application was removed due to the contradiction with SRV.11.1 (9.5)

[#50626587_pgfId-1000351]##url-patternType is changed from j2ee:string
to xsd:string (13)

[#50626587_pgfId-1000352]##The sub-elements under _<web-app>_ in
deployment descriptor can be in the arbitrary order (13)

[#50626587_pgfId-1000353]##The container must inform a developer with a
descriptive error message when deployment descriptor file contains an
illegal character or multiple elements of _<session-config>_ ,
_<jsp-config>_ , or _<login-config>_ (13)

[#50626587_pgfId-1000354]##Extensibility of deployment descriptor was
removed (13)

[#50626587_pgfId-1000355]##Section SRV.1.6 added - describing the
compatibility issue with the previous version of this specification
(1.6)

[#50626587_pgfId-1000356]##New attributes are added in
RequestDispatcher.forward method (8.4.2)

[#50626587_pgfId-1000357]##New methods in ServletRequest interface and
ServletRequestWrapper (14.2.16.1)

[#50626587_pgfId-1000358]##The interface SingleThreadModel was
deprecated ((2.2.1, 2.3.3.1, 14.2.24)

[#50626587_pgfId-1000359]##Change the name of the method
ServletRequestEvent.getRequest to ServletRequestEvent.getServletRequest
(14.2.19.2)

[#50626587_pgfId-1000360]##Clarification of the “request” to access to
WEB-INF directory (9.5)

[#50626587_pgfId-1000361]##Clarification of the behavior of
ServletRequest.setAttribute - change “value” to “object” in “If the
value passed in is null,” (14.2.16.1)

[#50626587_pgfId-1000362]##Fix the inconsistency between this
specification and HttpServletRequest, getServletPath - the return value
starts with “/” (15.1.3.2)

[#50626587_pgfId-1000363]##Fix the inconsistency between this
specification and HttpServletRequest.getPathInfo - the return value
starts with “/” (15.1.3.2)

[#50626587_pgfId-1000364]##Fix the inconsistency between this
specification and HttpServletRequest.getPathTranslated - add the case
when the container cannot translate the path (15.1.3.2)

[#50626587_pgfId-1000365]##Allow HttpServletRequest.getAuthType to
return not only pre-defined four authentication scheme but also the
container-specific scheme (15.1.3.2)

[#50626587_pgfId-1000366]##Change the behavior of
ttpSessionListener.sessionDestroyed to notify before the session is
invalidated (15.1.14.1)

[#50626587_pgfId-1000367]##Fix the wrong status code of 403 to 404 (9.5,
9.6)

[#50626587_pgfId-1000368]##Element “taglib” should be “jsp-config”
(13.2)

[#50626587_pgfId-1000369]##Fix the version number of JSP specification
to 2.0

[#50626587_pgfId-1000370]##Fix the wrong formats (5.5, 6.2.5, 12.8.3,
12.9)

[#50626587_pgfId-1000371]##HTTP/1.1 is now required (1.2)

[#50626587_pgfId-1000372]##<url-pattern> in <web-resource-collection> is
mandatory (13.4)

[#50626587_pgfId-1000373]##Clarification of IllegalArgumentException in
the distributed environments (7.7.2)

[#50626587_pgfId-1000374]##Clarification of error page handling (9.9.1,
9.9.2, 9.9.3, 6.2.5)

[#50626587_pgfId-1000375]##Clarification of Security Constraints,
especially in the case of overlapping constraints (12.8)

[#50626587_pgfId-1000376]##Clarification of the case when
<session-timeout> element is not specified (13.4)

[#50626587_pgfId-1000377]##Clarification of the case when the resource
is permanently unavailable (2.3.3.2)

[#50626587_pgfId-1000378]##Add missing getParameterMap() in the
enumerated list (4.1)

[#50626587_pgfId-1000379]##Clarification of the status code when
/WEB-INF/ resource is accessed (9.5)

[#50626587_pgfId-1000380]##Clarification of the status code when
/META-INF/ resource is accessed (9.6)

[#50626587_pgfId-1000381]##Change xsd:string to j2ee:string in
deployment descriptor (13.4)

[#50626587_pgfId-1000383]##Extensibility of deployment descriptors
(SRV.13)

[#50626587_pgfId-1000384]##XML Schema definition of deployment
descriptor (SRV.13)

[#50626587_pgfId-1000385]##Request listeners (SRV.10 and API change) +
New API: ServletRequestListener, ServletRequestAttributeListener and
associated event classes

[#50626587_pgfId-1000386]##Ability to use Filters under the Request
Dispatcher (6.2.5)

[#50626587_pgfId-1000387]##Required class loader extension mechanism
(9.7.1)

[#50626587_pgfId-1000388]##Listener exception handling (10.6)

[#50626587_pgfId-1000389]##Listener order vs. servlet init()/destroy()
clarification (ServletContextListener javadoc change)

[#50626587_pgfId-1000390]##Servlets mapped to WEB-INF / response
handling (9.5)

[#50626587_pgfId-1000391]##Request dispatcher / path matching rules
(8.1)

[#50626587_pgfId-1000392]##Welcome files can be servlets (9.10)

[#50626587_pgfId-1000393]##Internationalization enhancements (5.4,
14,2,22, 15.1.5)

[#50626587_pgfId-1000394]##SC_FOUND(302) addition (15.1.5)

[#50626587_pgfId-1000395]##“Relative path” in getRequestDispatcher()
must be relative against the current servlet (8.1)

[#50626587_pgfId-1000396]##Bug fix in the example of XML (13.7.2)

[#50626587_pgfId-1000397]##Clarification of access by getResource “only
to the resource” (3.5)

[#50626587_pgfId-1000398]##Clarification of SERVER_NAME and SERVER_PORT
in getServerName() and getServerPort() (14.2.16)

[#50626587_pgfId-1000399]##Clarification: “run-as” identity must apply
to all calls from a servlet including init() and destroy() (12.7)

[#50626587_pgfId-1000400]##Login/logout description and methods added
(12.10, 15.1.7)

[#50626587_pgfId-999505]## 

==== [#50626584_pgfId-4995]##

image:servlet-78.gif[image]

Glossary

image:servlet-79.gif[image]

==== [#50626584_pgfId-999213]##

image:servlet-80.gif[image]

A

[#50626584_pgfId-999146]## _Application Developer_

[#50626584_pgfId-999147]##The producer of a web application. The output
of an Application Developer is a set of servlet classes, JSP pages, HTML
pages, and supporting libraries and files (such as images, compressed
archive files, etc.) for the web application. The Application Developer
is typically an application domain expert. The developer is required to
be aware of the servlet environment and its consequences when
programming, including concurrency considerations, and create the web
application accordingly.

[#50626584_pgfId-999223]## _Application Assembler_

[#50626584_pgfId-999247]##Takes the output of the Application Developer
and ensures that it is a deployable unit. Thus, the input of the
Application Assembler is the servlet classes, JSP pages, HTML pages, and
other supporting libraries and files for the web application. The output
of the Application Assembler is a web application archive or a web
application in an open directory structure.

==== [#50626584_pgfId-999255]##

image:servlet-80.gif[image]

D

[#50626584_pgfId-999248]## _Deployer_

[#50626584_pgfId-999249]##The Deployer takes one or more web application
archive files or other directory structures provided by an Application
Developer and deploys the application into a specific operational
environment. The operational environment includes a specific servlet
container and web server. The Deployer must resolve all the external
dependencies declared by the developer. To perform his role, the
deployer uses tools provided by the Servlet Container Provider.

[#50626584_pgfId-999152]##The Deployer is an expert in a specific
operational environment. For example, the Deployer is responsible for
mapping the security roles defined by the Application Developer to the
user groups and accounts that exist in the operational environment where
the web application is deployed.

==== [#50626584_pgfId-999414]##

image:servlet-80.gif[image]

P

[#50626584_pgfId-999153]## _principal_

[#50626584_pgfId-999154]##A principal is an entity that can be
authenticated by an authentication protocol. A principal is identified
by a _principal name_ and authenticated by using _authentication data_ .
The content and format of the principal name and the authentication data
depend on the authentication protocol.

==== [#50626584_pgfId-999418]##

image:servlet-80.gif[image]

R

[#50626584_pgfId-999155]## _role (development)_

[#50626584_pgfId-999156]##The actions and responsibilities taken by
various parties during the development, deployment, and running of a web
application. In some scenarios, a single party may perform several
roles; in others, each role may be performed by a different party.

[#50626584_pgfId-999157]## _role (security)_

[#50626584_pgfId-999158]##An abstract notion used by an Application
Developer in an application that can be mapped by the Deployer to a
user, or group of users, in a security policy domain.

==== [#50626584_pgfId-999422]##

image:servlet-80.gif[image]

S

[#50626584_pgfId-999159]## _security policy domain_

[#50626584_pgfId-999160]##The scope over which security policies are
defined and enforced by a security administrator of the security
service. A security policy domain is also sometimes referred to as a
_realm_ .

[#50626584_pgfId-999161]## _security technology domain_

[#50626584_pgfId-999162]##The scope over which the same security
mechanism, such as Kerberos, is used to enforce a security policy.
Multiple security policy domains can exist within a single technology
domain.

[#50626584_pgfId-999163]## _Servlet Container Provider_

[#50626584_pgfId-999164]##A vendor that provides the runtime
environment, namely the servlet container and possibly the web server,
in which a web application runs as well as the tools necessary to deploy
web applications.

[#50626584_pgfId-999165]##The expertise of the Container Provider is in
HTTP-level programming. Since this specification does not specify the
interface between the web server and the servlet container, it is left
to the Container Provider to split the implementation of the required
functionality between the container and the server.

[#50626584_pgfId-999166]## _servlet definition_

[#50626584_pgfId-999167]##A unique name associated with a fully
qualified class name of a class implementing the _Servlet_ interface. A
set of initialization parameters can be associated with a servlet
definition.

[#50626584_pgfId-999168]## _servlet mapping_

[#50626584_pgfId-999169]##A servlet definition that is associated by a
servlet container with a URL path pattern. All requests to that path
pattern are handled by the servlet associated with the servlet
definition.

[#50626584_pgfId-999170]## _System Administrator_

[#50626584_pgfId-999171]##The person responsible for the configuration
and administration of the servlet container and web server. The
administrator is also responsible for overseeing the well-being of the
deployed web applications at run time.

[#50626584_pgfId-999172]##This specification does not define the
contracts for system management and administration. The administrator
typically uses runtime monitoring and management tools provided by the
Container Provider and server vendors to accomplish these tasks.

==== [#50626584_pgfId-999426]##

image:servlet-80.gif[image]

U

[#50626584_pgfId-999173]## _uniform resource locator (URL)_

[#50626584_pgfId-999174]##A compact string representation of resources
available via the network. Once the resource represented by a URL has
been accessed, various operations may be performed on that
resource.link:#pgfId-999177[12] A URL is a type of uniform resource
identifier (URI). URLs are typically of the form:

[#50626584_pgfId-999178]## _<protocol>//<servername>/<resource>_

[#50626584_pgfId-999179]##For the purposes of this specification, we are
primarily interested in HTT- based URLs which are of the form:

[#50626584_pgfId-999180]##
_http[s]://<servername>[:port]/<url-path>[?<query-string>]_

[#50626584_pgfId-999181]##For example:

[#50626584_pgfId-999182]##
_http://www.example.com/products/servlet/index.html_

[#50626584_pgfId-999183]## _https://example.com/purchase_

[#50626584_pgfId-999184]##In HTTP-based URLs, the _‘/’_ character is
reserved to separate a hierarchical path structure in the URL-path
portion of the URL. The server is responsible for determining the
meaning of the hierarchical structure. There is no correspondence
between a URL-path and a given file system path.

==== [#50626584_pgfId-999437]##

image:servlet-80.gif[image]

W

[#50626584_pgfId-999185]## _web application_

[#50626584_pgfId-999186]##A collection of servlets, JSP pages , HTML
documents, and other web resources which might include image files,
compressed archives, and other data. A web application may be packaged
into an archive or exist in an open directory structure.

[#50626584_pgfId-999187]##All compatible servlet containers must accept
a web application and perform a deployment of its contents into their
runtime. This may mean that a container can run the application directly
from a web application archive file or it may mean that it will move the
contents of a web application into the appropriate locations for that
particular container.

[#50626584_pgfId-999188]## _web application archive_

[#50626584_pgfId-999189]##A single file that contains all of the
components of a web application. This archive file is created by using
standard JAR tools which allow any or all of the web components to be
signed.

[#50626584_pgfId-999190]##Web application archive files are identified
by the _.war_ extension. A new extension is used instead of _.jar_
because that extension is reserved for files which contain a set of
class files and that can be placed in the classpath or double clicked
using a GUI to launch an application. As the contents of a web
application archive are not suitable for such use, a new extension was
in order.

[#50626584_pgfId-999191]## _web application, distributable_

[#50626584_pgfId-999192]## _A web application that is written so that it
can be deployed in a web container distributed across multiple Java
virtual machines running on the same host or different hosts. The
deployment descriptor for such an application uses the_ _distributable_
_element._

[#50626584_pgfId-999408]## 

'''''

[.footnoteNumber]# 1.# [#50626604_pgfId-5149]##This reference is mostly
tongue-in-cheek although most of the concepts described in the HTCPCP
-TEA RFC are relevant to all well-designed Web servers.

[.footnoteNumber]# 2.# [#50626602_pgfId-999813]##Please see the Java™
Platform, Enterprise Edition specification available at
_http://www.oracle.com/technetwork/java/javaee/tech/index.html_

[.footnoteNumber]# 3.# [#50626601_pgfId-1000348]## _The terms "Java
virtual machine" and "JVM" mean a virtual machine for the Java(_ ™ _)
platform._

[.footnoteNumber]# 4.# [#50626597_pgfId-999494]##The Java Programming
Language Specification is available at
_http://docs.oracle.com/javase/specs/_

[.footnoteNumber]# 5.# [#50626599_pgfId-999494]##The JavaServer Pages™
specification can be found at _https://jcp.org/en/jsr/detail?id=245_

[.footnoteNumber]# 6.# [#50626599_pgfId-999505]##An exception is system
classes that the servlet may use in a different class loader.

[.footnoteNumber]# 7.# [#50626596_pgfId-999474]##See the JavaServer
Pages specification available from
_https://jcp.org/en/jsr/detail?id=245_ .

[.footnoteNumber]# 8.# [#50626594_pgfId-999465]##Versions of this
specification prior to 2.5 made use of these mapping techniques as a
suggestion rather than a requirement, allowing servlet containers to
each have their different schemes for mapping client requests to
servlets.

[.footnoteNumber]# 9.# [#50626593_pgfId-1004673]##From methods value(),
rolesAllowed(), and transportGuarantee().

[.footnoteNumber]# 10.# [#50626593_pgfId-1002129]##The password
equivalents can be such that they can only be used to authenticate as
the user at a specific realm.

[.footnoteNumber]# 11.# [#50626593_pgfId-999739]##As an optimization, a
container should reject the request as forbidden and return a 403
(SC_FORBIDDEN) status code if it knows that access will ultimately be
precluded (by an authorization constraint naming no roles).

[.footnoteNumber]# 12.# [#50626584_pgfId-999177]##See RFC 1738
